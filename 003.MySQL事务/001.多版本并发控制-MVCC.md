# 多版本并发控制-MVCC
&nbsp;&nbsp;**通过记录多个修改的历史版本代替锁，实现事务间的隔离效果，保证非阻塞读**

表的隐藏列：事务ID，上个版本数据地址  + undolog(记录各个版本修改历史即事务链) + ReadView读视图，用于判断那些版本可见。


事务A对数据进行修改了
1. 对数据行加排他锁
2. 将数据行拷贝到undolog中
3. 将数据行的上个版本数据地址这列（回滚指针 ）的值设置为undolog中的数据地址，数据行的事务id也需要加一
4. 
5. 当事务成功了什么也不做，失败了，则从undolog中回滚


## 当前读与快照读
### 当前读
&nbsp;&nbsp;他读取的是数据库记录，都是当前最新的版本，会对当前读取的数据进行加锁，防止其他事务修改数据，是悲观锁的一种操作。
1. select  lock in share mode(共享锁)
2. select  for update(排他锁)
3. update(排他锁)
4. insert(排他锁)
5. delete(排他锁)


#### 当前读如何解决幻读的问题？
通过间隙锁来实现的，因为在RR级别下是开启了间隙锁的。

##### 什么是幻读
- 数据库中id>2的数据有3，4，5这三条数据
- 时刻A P这个线程开始一个事务读取id>2的数据，此时查出3，4，5这三条数据，并且在这个时刻有一个线程Q插入了一条id=7的数据
- P再次(事务没有提交)读取的时候，此时读到了3，4，5，7这四条数据
- 因为当前读的方式是： select  for update , 且RR级别模式是开启了间隙锁的，所以id>2后面的范围都是被锁住了，所以id=7的数据插入流程就会被阻塞，则解决了幻读问题。

### 快照读
&nbsp;&nbsp;快照读的实现是基于多版本并发控制，即MVCC，既然是多版本，那么快照读读到的数据不一定是当前最新的数据，有可能是之前历史版本的数据。
1. 不加锁的select操作

#### MVCC
&nbsp;&nbsp;通过记录多个修改的历史版本代替锁，实现事务间的隔离效果，保证非阻塞读

表的隐藏列：事务ID，上个版本数据地址  + undolog(记录各个版本修改历史即事务链) + ReadView读视图，用于判断那些版本可见。

事务A对数据进行修改了
1. 对数据行加排他锁
2. 将数据行拷贝到undolog中
3. 将数据行的上个版本数据地址这列（回滚指针 ）的值设置为undolog中的数据地址，数据行的事务id也需要加一
4. 
5. 当事务成功了什么也不做，失败了，则从undolog中回滚



版本链中有很多版本，那么选择哪一个版本的数据呢? ReadView（快照）
1. m_ids 表示**在生成ReadView时当前系统中活跃的读写事务的事务id列表**，**什么是活跃的？即没有提交的事务id**
2. min_trx_id 表示在生成ReadView时系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值
3. max_trx_id 表示生成ReadView时系统中应该分配给下一个事务的id值
4. creator_trx_id 表示生成该readView的事务的事务id

ReadView如何判断版本链中的哪个版本可用？(以下trx_id是数据行(undolog中或者数据行中)事务id)
 - trx_id == creator_trx_id  可以访问这个版本，当是等于的情况，说明这条记录就是自己创建的，可以读取
 - trx_id < min_trx_id  可以读取，当trx_id小于min_trx_id时，说明trx_id对应的事务是已经提交了的，所以是可以读取到的
 - trx_id > max_trx_id 不可以访问max_trx_id 是即将要分配给下一个事务的id，因为读取只能读取版本链里面的数据，若trx_id 大于 max_trx_id ,则说明需要读取的事务id超过了版本链中最大的事务id，所以是读取不到的
 - min_trx_id <= trx_id <= max_trx_id 如果trx_id在m_ids中是不可以访问这个版本的，反之可以（属于这个范围，但是不在里面如m_ids{1,3,4,5},trx_id为2，则是可以读取到的，因为说明2是一个已经commit的事务）。（因为m_ids都是活跃的，没有commit的）

 MVCC之RR(REPEATABLE READ)
该级别事务下readview生成是以事务为单位的，即一个事务只会产生一个readview，即在事务中creator_trx_id生成一次且在本事务中不会变，那么读取的数据也就不会变了，则就解决了幻读的问题

 MVCC之RC(READ COMMITTED)，所以没有解决幻读问题
 以每一个select来生成readview的（即以每一个select来生成creator_trx_id）,即若此时开启一个事务，执行两个select，那么就会产生两个readview



