# redo log 
&nbsp;&nbsp;以恢复为目的，在数据库发生意外时重现操作。指数据库中修改的任何数据，将最新的数据备份存储的位置(redo log)，在事务提交时会将产生的redo log 写入到log buffer，并不是随着事务的提交就立即写入磁盘文件。等事务的脏页写入到磁盘之后，redo log的使命就完成了，redo log 占用的空间就可以被重用了。

&nbsp;&nbsp;redo log 记录的是物理操作日志，因此每个事务对应多个日志条目，并且事务的重做日志写入是并发的，并非在事务提交时写入。顾其在文件记录的顺序并非是事务开始的顺序。

## 文件存储
### log block(又称 redo log block)
&nbsp;&nbsp;在InnoDB存储引擎中，重做日志都是以512字节进行存储的，这意味着重做日志缓存、重做日志文件都是以块的方式保存的，即 重做日志块(redo log block),每块的大小是512字节。

&nbsp;&nbsp;若一个页中产生的重做日志数量大于512字节，则需要分割为多个log block进行保存。且log block的大小和磁盘扇区大小一样，都是512字节，因此重做日志的写入可以保证原子性<sup>磁盘IO的最小单位是512字节</sup>，不需要double write技术

&nbsp;&nbsp;重做日志块除了日志本身，还由日志块头(log block header，占用12字节) 以及 日志块尾(log block tailer，占用8字节)两部组成。因此，每个重做日志块实际可以存储的大小为 512 - 12 - 8 = 492字节。如下图，重做日志块缓存的结构: 
  - <img src="./pics/redo-log-struct-001.png"/>
  - log block header
    |字段|大小|含义|
    |---|---|---|
    | LOG_BLOCK_HDR_NO| 4字节|标记该log block在这个数组中的位置,且是递增并循环使用的且第一位用于判断是否是flush bit,所以最大值是2G|
    | LOG_BLOCK_HDR_DATA_LEN|2字节|表示log block所占用的大小,当log block被写满时，该值为0x200,表示占用全部log block空间，即512字节|
    | LOG_BLOCK_FIRST_REC_GROUP|2字节|表示log block中第一个日志所在的偏移量，若该值与LOG_BLOCK_HDR_DATA_LEN相等，表示该log block不包含新日志|
    | LOG_BLOCK_CHECKPOINT_NO|4字节|该 log_block 最后被写入时的 checkpoint 值(log_sys->next_checkpoint_no低4个字节的值)|
  - log block tailer 
    |字段|大小|含义|
    |---|---|---|
    |LOG_BLOCK_TRL_NO|4字节|值与LOG_BLOCK_HDR_NO相同|
#### log block 分析
- <img src="./pics/redo-log-struct-002.png"/>
  
  + T1的重做日志占用 762 字节，事务T2重做日志占用100字节，因为每个log block只能保存492个字节，因此对于T1、T2 log block各个字段的值:
      1. LOG_BLOCK_FIRST_REC_GROUP: 左侧log block对应字段值为12,右边的则为 12 + 270 = 282

### log group
&nbsp;&nbsp;重做日志由以下几个概念组成:
- 重做日志缓存(redo log buffer)
  > 大小由innodb_log_buffer_size控制，默认大小为1MB
- 重做日志组(redo log group)
- 每个重做日志包含多个重做日志文件(redo log file)
- 归档重做日志文件(archive redo log file)
  
&nbsp;&nbsp;每个重做日志文件组存储的内容是完全相同的，是镜像关系<sup>ha_innobase.cc文件中禁用了镜像功能，因此InnoDB中实际只有一个log group</sup>，目的是为了数据库的可用性<sup>即当一组中的重做日志发生介质损坏时，InnoDB存储引擎依旧能提供服务</sup>。关系如下图:(P49)
  - <img src="./pics/redo-log-struct-003.png"/>

&nbsp;&nbsp;log group由多个重做日志文件组成，每个log group中的日志文件大小是相同的，InnoDB1.2之前重做日志文件的总大小要小于4GB,从InnoDB1.2开始重做日志文件总大小的限制提高为了512GB。

&nbsp;&nbsp;重做日志文件中存储的就是之前在log buffer中保存的log block,因此重做日志文件也是根据块的方式进行物理存储的管理，每个块的大小与log block一样，同样为512字节。在InnoDB存储引擎运行过程中，log buffer会根据一定的规则将内存中的log block刷新到磁盘上。规则如下:
  1. 事务提交时
  2. 当log buffer中有一半的内存空间已经被使用时
  3. log checkpoint 时

&nbsp;&nbsp;重做日志文件是循环反复(round-robin)使用的，假设设置三个重做日志文件: ib_logfile0、ib_logfile1、ib_logfile2。重做日志缓存先写入到ib_logfile0中，当写满后再依次写文件 ib_logfile1、ib_logfile2,当ib_logfile2也写满，则再写ib_logfile0,而之前写入的重做日志条目将被覆盖。

&nbsp;&nbsp;由于重做日志文件是循环往复使用的，因此重做日志由于覆盖而导致丢失。归档重做日志的作用就是对重做日志进行备份(只对重做日志组1中的日志进行归档，且默认不开启)

### redo log file怎么写入的
&nbsp;&nbsp;redo log 实际上记录数据页的变更,而这种变更记录是没有必要全部保存的<sup>???</sup>,因此redo log 实际上采用了大小固定，循环写入的方式，写满时会回溯到第一个文件，进行覆盖写。如下图: 
- <img src="./pics/i53hgc1rtg.png"/>
  
  + 如上图，wtite pos 表示redo log当前记录的LSN（逻辑序列号）位置，checkpoint表示数据页更改记录刷盘后对应redo log所处的LSN位置。 <font color="red">**write pos 到 checkpoint之间的部分是redo log 空着的部分，用于记录新的记录**</font>。<font color="blue">**checkpoint到write pos 之间是记录待落盘的数据页变更记录**。</font>当write pos追上checkpoint时，会先推动checkpoint向前移动，空出的位置再记录新的日志。

#### > <font color="red">**redo log 存在的意义是什么?**</font>
> 在InnoDB中，既有redo log需要刷盘，还有数据页需要刷盘，**redo log 存在的意义主要就是降低数据页刷盘的要求**

&nbsp;&nbsp;启动InnoDB时，不论上次是正常关闭还是异常关闭，总是会进行恢复操作。因为redo log 记录的是数据页的物理变化，因此恢复时速度比逻辑日志(如 binlog)要快很多。

#### <font color="red">**数据页刷盘和redo log刷盘的关系**</font>
&nbsp;&nbsp;重启InnoDB时，首先会检查磁盘中数据页的LSN，如果数据页的LSN小于日志中的LSN，则会从checkpoint开始恢复。还有一种情况，在宕机前正处于checkpoint的刷盘过程，且数据页的刷盘进度超过了日志页的刷盘进度，此时会出现数据页中记录的LSN大于日志中的LSN，这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。













---
## 附录
### double write技术
1. Q: 为什么log write不需要doublewrite的支持？
   - A: 因为redolog写入的单位就是512字节，也就是磁盘IO的最小单位，所以无所谓数据损坏。


### LSN
### checkpoint

---
## 参考资料
1. [【图文详解】MySQL系列之redo log、undo log和binlog详解](https://cloud.tencent.com/developer/article/1801920)