# MySQL中的事务
&nbsp;&nbsp;事务的隔离性是由锁来实现的，原子性、一致性、持久性通过数据库的redo log和undo log来完成。

## 日志简介
&nbsp;&nbsp;InnoDB是事务的存储引擎，其通过Force Log at Commit机制实现事务的持久性，即当事务提交（COMMIT）时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的COMMIT操作完成才算完成。这里的日志是指重做日志，在InnoDB存储引擎中，由两部分构成：
> redo log 
  >> redo log 用于保证事务的持久性和原子性

>  undo log
  >> undo log用来帮助事务回滚以及MVCC功能，即保证事务的一致性。

&nbsp;&nbsp;redo log*基本*是顺序写的，在数据库运行时不需要对redo log的文件进行读取操作。而undo log 是需要进行随机读取的。

### 日志写入
&nbsp;&nbsp;为了确保每次日志都写入重做日志文件，在每次将重做日志缓冲写入重做日志文件时，InnoDB存储引擎都需要调用一次fsync操作。如下图：
  - <img src="./pics/log-write-to-file-001.png"/>

&nbsp;&nbsp;由于重做日志文件没有打开O_DIRECT选项，因此重做日志缓存先写入文件系统缓存。为了确保重做日志写入磁盘，必须进行一次fsync操作。<font color="#DC143C">**由于fsync的效率取决于磁盘的性能，因此磁盘的性能决定了事务提交的性能，也就是数据库的性能**</font>

&nbsp;&nbsp;InnoDB允许用户手动设置非持久性的情况发生，以此提高数据库的性能。即当事务提交的时候，日志不写入重做日志文件，而是等待一个时间周期后再执行fsync操作。由于并非强制在事务提交时进行一次fsync操作，显然这可以提升数据库的性能。但是当数据库发生宕机的时候，由于部分日志没有刷新到磁盘上，因此会丢失最后一段时间的事务。

&nbsp;&nbsp;参数: innodb_flush_log_at_trx_commit来控制重做日志刷新到磁盘的策略。

|参数值|策略介绍|是否事务安全|
|---|---|---|
|0|事务提交时不进行写入重做日志操作，这个操作尽在master thread中完成，而在master thread中每一秒会进行一次重做日志的fsync操作。|丧失ACID特性|
|1(默认)|表示事务提交时必须调用一次fsync操作||
|2|事务提交时将重做日志写入重做日志文件，但仅仅写入系统的缓存中，不进行fsync操作。在这个设置下，当MySQL宕机而操作系统没有宕机时并不会导致事务的丢失。但是当操作系统宕机时，重启数据库会丢失未从文件系统缓存刷新到重做日志文件那部分的事务。|丧失ACID特性|

---
### 日志的purge操作
&nbsp;&nbsp;purge用于最终完成delete和update操作，这样设计是因为InnoDB存储引擎支持MVCC，所以记录不能在事务提交时立即进行处理。这时其他事务可能正在引用这行，故InnoDB需要保存记录之前的版本。而是否可以删除该条记录通过purge来进行判断。若该行记录已不被任何其他事务引用，那么就可以进行真正的delete操作。因此，purge操作是清理之前的delete和update操作，将上述操作最终完成。而实际执行的操作为delete，清理之前行记录的版本。
> 当该行记录已经不被任何其他事务所引用，那么该行记录就可以进行真正的delete操作。

### 内部XA事务(**保证binlog 与 重做日志 写入的原子性**)
&nbsp;&nbsp;在MySQL数据库中还存在另外一种分布式事务，其在存储引擎和插件之间，又或者在存储引擎与存储引擎之间，称之为内部XA事务.

&nbsp;&nbsp;由于复制的需要，因此目前大多数的数据库都开启了binlog功能。在事务提交时，先写二进制日志，再写InnoDB存储引擎的重做日志，

- <img src="./pics/2021-12-19_14-39-xa-transactional.png"/>

    + 如图7-23，如果执行完1,2之后在步骤3之前MySQL数据库发生了宕机，则会发生主从不一致的情况。为了解决这个问题，MySQL数据库在binlog 与 InnoDB存储引擎之间采用XA事务。当事务提交时，InnoDB会先做一个prepare操作，将事务的xid写入，接着进行二进制日志的写入。

    + 如图7-24，如果在InnoDB存储引擎提交之前，MySQL数据库宕机了，那么MySQL数据库在重启后会先检查准备的UXID事务是否已经提交，若没有，则在存储引擎层再进行一次提交操作。

---
## 注意事项
### 1. 什么才算事务完成
&nbsp;&nbsp; 需要将事务的所有日志写入到重做日志文件<sup>从上文可以看出，这里的重做日志文件包括: redo log ， undo log)</sup>中，再COMMIT，事务才算完成
> <font color="red">即使某个事务**还没有**提交，InnoDB存储引擎仍然会每秒将重做日志缓冲中的内容刷新到重做日志文件中</font>，这也是为什么再大的事务提交的时间也是很短的原因。<sup>MySQL技术内幕 InnoDB存储引擎 第二版 P37</sup>

### 2. 日志写入对性能的影响
&nbsp;&nbsp;InnoDB在写入日志的时候，会受到磁盘性能的影响，从而影响数据的性能。

---
## 收获
1. 使用存储过程时，应当尽量将更新操作放到一个事务中去，不然会存在许多次fsync操作，影响执行效率。还有就是能够在事务回滚时能回滚到最开始确定的状态。
2. 数据采用的硬盘决定着数据库的性能。

## 二进制日志-BinLog
&nbsp;&nbsp;二进制日志-BinLog是用来进行POINT-IN-TIME（PIT）的恢复以及主从（Replication）环境的建立，二进制日志与重做日志非常相似，都是记录了对于数据库操作的日志，但从本质上来看，又有所不同:
1. 产生的场景不一致
   - 二进制日志实在MySQL数据库的上层产生的，并且二进制日志是针对于MySQL中的所有的存储引擎；
   - 重做日志是在InnoDB存储引擎层产生的。
2. 记录的内容形式不一致
   - BinLog是一种逻辑日志，记录的是对应的SQL语句；
   - InnoDB层重做日志是物理格式日志，记录的事对于每个页的修改。
3. 日志刷盘的时间不同
   - BinLog只在事务提交完成后进行一次写入；
   - InnoDB重做日志在事务进行中不断被写入，表现为日志并不是随着事务的提交顺序进行写入的。
---
## 参考资料
1. 《MySQL技术内幕 InnoDB存储引擎 第二版》