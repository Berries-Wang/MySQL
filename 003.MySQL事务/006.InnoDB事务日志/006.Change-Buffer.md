# Change Buffer(插入缓存)
## 简要
&nbsp;&nbsp;Change Buffer存在的目的是降低磁盘的I/O以及随机I/O（即降低磁盘的写入次数以及避免离散写入磁盘）,提升数据库性能.
- 辅助索引页的数据不那么急着刷入磁盘，与辅助索引页合并之后再刷入磁盘。
   + 什么时候合并? "merged later when the pages are loaded into the buffer pool by other read operations",即当加载数据页时合并
   + 什么时候刷入磁盘? 
      1. 由[Master Thread](../../013.存储引擎内核/000.InnoDB/000.InnoDB架构.md) 线程刷入到磁盘:
      2. 用户线程读取索引页，Insert Buffer数据会合并到辅助索引数据页，之后会将脏页刷入磁盘。
- 适用对象: 非唯一的辅助索引<sup>因为非唯一索引不要校验数据重复</sup>
- 图示: <img src="./pics/innodb-change-buffer.png"/>
  
    + periodic : 阶段性的
    + purge : 清除；排除；
- Change Buffer Merge 的 合并对象
   + 即 Insert Buffer 对象 和 缓冲池中辅助索引的页 进行合并，合并之后再将辅助索引页刷新到磁盘中。
     - Insert Buffer 和 数据页一样，也是物理页的一个组成部分。
  
---

## Insert Buffer
```SQL
   CREATE TABLE t(
       a INT AUTO_INCREMENT,
       b VARCHAR(30),
       PRIMARY KEY(a),
       KEY(b)
   );
```

+ a列是自增长的，若对a列插入NULL值，则由于其具有AUTO_INCREMENT属性，其值会自动增长，同时页中的记录按照顺序存放。在一般情况下，不需要随机读取另一个页中的记录，因此，对于这类情况的插入操作，速度是非常快的。
+ b列是非聚集的且不唯一的索引，在进行插入操作时，数据的存放还是按主键a进行存放的，但是对于非聚集索引(即辅助索引)的叶子节点的插入不再是顺序的了，这时候需要离散的访问非聚集索引页，由于随机读取的存在导致了插入操作性能的下降。

### Insert Buffer 在什么时候会有新数据加入
&nbsp;&nbsp;InnoDB 存储引擎中，对于非聚集索引的插入或者更新操作，不是每一次都直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中：
- 在：则直接插入: 即直接插入到索引页中，后续直接刷入到磁盘中。
- 不在：则先放入到一个Insert Buffer对象中,认为这个非聚集的索引已经插入到叶子节点上，而实际上并没有，只是存放在另一个位置。 最后再以一定的频率和情况<sup>一定的频率和情况，即Master Thread 的处理逻辑了，合并插入缓存的处理是由Master Thread处理的</sup>进行Insert Buffer和辅助索引页子节点的Merge(合并)操作<sup>将Insert Buffer对象和辅助索引页子节点进行合并，再刷新到磁盘中</sup>，这时候能将多个<sup>不仅是避免离散写入，也降低了I/O次数</sup>插入合并到一个操作中(因为在一个索引页中)，这就大大提高了对于非聚集索引的插入性能。

### Insert Buffer使用条件
&nbsp;&nbsp;Insert Buffer 的使用需要同时满足以下两个条件:
1. 索引是辅助索引(secondary index)
2. 索引不是唯一的（那么，唯一索引有什么区别呢? 因为唯一索引需要校验数据唯一性）
   
&nbsp;&nbsp;满足以上两个条件，InnoDB会使用Insert Buffer,这样就能提高插入操作的性能了。

---

## Change Buffer
&nbsp;&nbsp;Change Buffer 是Insert Buffer的一个升级版，Change Buffer 可以对DML操作-INSERT、DELETE、UPDATE操作都进行缓冲，他们分别是 Insert Buffer , Delete Buffer , Purge Buffer.

&nbsp;&nbsp;同Insert Buffer, Change Buffer 适用的对象依旧是非唯一的辅助索引。

&nbsp;&nbsp;对一条记录进行UPDATE 操作可能分为两个过程：
1. 将记录标记为已删除
   > ***Delete Buffer 对应UPDATE 的第一个过程，即将记录标记为已删除***
2. 真正将记录删除
   > ***Purge Buffer 对应UPDATE操作的第二个过程，即将记录真正地删除。***

---

## Merge Insert Buffer
&nbsp;&nbsp; 谁和谁合并呢？
+ 即 Insert Buffer 对象 和 缓冲池中辅助索引的页 进行合并，合并之后再将辅助索引页刷新到磁盘中。
  
&nbsp;&nbsp;Insert/Change Buffer 是一棵B+树，若需要实现插入记录的辅助索引页不在缓冲池中，则需要先将辅助索引记录插入到这棵B+树中。那么Insert Buffer中的记录何时合并到真正的辅助索引中呢 ? 主要有以下几种情况:
1. 辅助索引列被读取到缓冲池
   - 如正常执行SELECT操作，这时需要检查Insert Buffer Bitmap页，确认该辅助索引页是否有记录存放于Insert Buffer B+树中，有，则将Insert Buffer B+树中该页的插入到该辅助索引页中。
2. Insert Buffer Bitmap 页追踪到该辅助索引页已无可用空间时
   - Insert Buffer Bitmap页用来追踪每个辅助索引页的可用空间，并至少有1/32页的空间。若插入辅助索引记录时检测到插入后记录可用空间会小于1/32页，则会强制进行一个合并操作，即强制读取辅助索引页，将Insert Buffer B+树中该页的记录及待插入的记录插入到辅助索引页中。
3. Master Thread
   - Master Thread 中每秒或每10秒会进行一次Merge Insert Buffer操作。
---

## Insert Buffer 内部实现
&nbsp;&nbsp;Insert Buffer的数据结构： B+树。且全局只有一棵Insert Buffer B+树，负责对所有的表的辅助索引进行Insert Buffer。

&nbsp;&nbsp;Insert Buffer B+树存放在共享表空间中，默认也就是在ibdata1中。因此，试图通过独立表空间ibd文件恢复表中数据时，往往会导致[CHECK TABLE](https://dev.mysql.com/doc/refman/5.7/en/check-table.html)失败（因为表的辅助索引中的数据可能还在Insert Buffer中，也就是在共享表空间中，所以通过ibd文件进行恢复后，还需要进行REPAIR TABLE操作来重建表上所有的辅助索引）
> CHECK TABLE ？ REPAIR TABLE？

&nbsp;&nbsp;Insert Buffer是一棵B+树，因为也由叶子节点和非叶子节点组成。非叶子节点存放的是查询的search key,如下图: 
   - <img src="./pics/2022-08-26_07-55-insert-buffer-search-key.png"/>
   - + search key 共占用9个字节：
   - + - space 表示待插入记录所在表的表空间id,在InnoDB中，每个表有一个唯一的space id,可以通过space id查询得知是哪张表，占4字节。
   - + - marker 占用一个字节，用来兼容老版本的Insert Buffer
   - + - offset 表示页所在的偏移量，占4字节。



---

## 系统信息查看
#### 1. 插入缓存信息查看<sup>**再次强调一下 Insert Buffer 和 Change Buffer是同一个东西，后者是前者的升级版**</sup>
```txt
      ........
      -------------------------------------
      INSERT BUFFER AND ADAPTIVE HASH INDEX
      -------------------------------------
      Ibuf: size 1, free list len 163443, seg size 163445, 207570192 merges
      merged operations:
       insert 298024080, delete mark 20579587, delete 1720942
      discarded operations:
       insert 0, delete mark 0, delete 0
      AHI PARTITION 1: Hash table size 3187567, node heap has 261 buffer(s)
      AHI PARTITION 2: Hash table size 3187567, node heap has 1270 buffer(s)
      AHI PARTITION 3: Hash table size 3187567, node heap has 1118 buffer(s)
      AHI PARTITION 4: Hash table size 3187567, node heap has 293 buffer(s)
      AHI PARTITION 5: Hash table size 3187567, node heap has 286 buffer(s)
      AHI PARTITION 6: Hash table size 3187567, node heap has 503 buffer(s)
      AHI PARTITION 7: Hash table size 3187567, node heap has 134 buffer(s)
      AHI PARTITION 8: Hash table size 3187567, node heap has 237 buffer(s)
      1034.77 hash searches/s, 4929.30 non-hash searches/s
       .......
      ----------------------------
      END OF INNODB MONITOR OUTPUT
      ============================

      ## 解析
      a. seg size 表示当前Insert Buffer 的大小为 163445 x 16(KB) = 2.493972778(GB)
      b. free list len 表示空闲列表的长度
      c. size 代表了已经合并记录页的数量，即正在使用的page
      d. merges 代表合并的次数，也就是实际读取页的次数。
      
      e. merged operations：表示每个change Buffer操作的次数
          > insert：表示Insert Buffer
          > delete mark: 表示Delete Buffer
          > delete: 表示 Purge Buffer

      f. discarded operations：表示当Change Buffer进行merge时，表已经被删除，此时无需将记录合并到辅助索引中了。(2:P50)

      g. 性能提升： change buffer的效果 = merges / (insert+delete mark+delete)（merged operations）结果越小说明change buffer对性能提升越有利
     　　> 207570192÷(298024080+20579587+1720942) = 0.647999517 约2:3 , 则说明插入缓冲将对于非聚集索引页的离散逻辑请求大约降低了1/3.
```

### Change Buffer 最大能使用多大内存?
```txt
   mysql> show variables like 'innodb_change_buffer_max_size'\G
   *************************** 1. row ***************************
   Variable_name: innodb_change_buffer_max_size
           Value: 25
   1 row in set (0.01 sec)

   # innodb_change_buffer_max_size 默认值为25,即25%,表示最多使用1/4的缓冲区内存空间
     > 该参数最大有效值为 50
```

---
## 附录
### 1. [InnoDB 架构](https://dev.mysql.com/doc/refman/8.0/en/innodb-architecture.html)
- <img src="./pics/innodb-architecture.png"/>
- + **AHI（Adaptive Hash Index,自适应哈希索引）**:InnoDB存储引擎会监控表上各索引页的查询，如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，即自适应哈希索引。AHI是通过缓冲池的B+树页构建而来，因此建立的速度很快，且不需要对整张表构建哈希索引。
- + [Change Buffer](https://dev.mysql.com/doc/refman/8.0/en/innodb-change-buffer.html)
- + - Buffer Pool中的一部分，一种特殊的数据结构，主要是对那些不在Buffer Pool中的二级索引数据页进行缓存，减少对磁盘的随机IO。
- + - 当二级索引页被加载到内存时，则将数据进行合并，再将修改后的数据写入到磁盘中
      > 刷入磁盘是由Master Thread执行的.
  

--- 
## 参考资料
1. [14.5.2 Change Buffer](https://dev.mysql.com/doc/refman/5.7/en/innodb-change-buffer.html)
2. MySQL技术内幕 InnoDB存储引擎 第二版》