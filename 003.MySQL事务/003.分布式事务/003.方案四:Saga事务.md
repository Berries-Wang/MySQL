# Saga 事务
Saga事务核心思想是将长事务拆分为多个本地短事务并依次正常提交，如果所有短事务均执行成功，那么分布式事务提交；若出现某个参与者执行本地事务失败，则有Saga事务协调器根据相反顺序调用补偿操作，回滚已提交的参与者，是分布式事务回到最初的状态。Saga基本协议如下:
1. 每个Saga事务由一系列幂等的有序子事务（sub-transaction）Ti组成
2. 每个Ti都有对应的幂等补偿操作 Ci，补偿操作用于撤销Ti造成的结果

与TCC事务补偿机制相比，TCC有一个预留(Try)操作，相当于先保存一个草稿，然后再提交；Saga没有预留动作，直接提交。


## Saga恢复策略
对于业务异常，Saga提供了两种恢复策略:
### 策略1： 向后恢复
当执行事务失败时，补偿所有已完成的事务，这种做法的效果是撤销之前所有成功的子事务，使整个Saga的执行结果撤销.

### 策略2： 向前恢复
对于执行不通过的事务，会尝试重试事务，这里有个假设就是子事务最终都会成功，这种方式适用于必须要成功的场景，事务失败了重试，不需要补偿。

## Saga事务的实现方式
Saga有两种不同的实现方式：
1. 命令协调
2. 事件编排

### 1. 命令协调
中央协调器以命令/回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。

中央协调器必须事先知道执行整个事务所需的流程，如果有任何失败，他还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。

### 2. 事件编排
命令协调基于中央协调器实现，有单点风险。但是事件编排方式没有中央协调器。事件编排的实现方式中，每个服务产生自己的事件并监听其他服务的事件来决定是否采取行动。


## 注意事项
- 由于Saga模型没有Prepare阶段，因此事务不能保证隔离性。当多个Saga事务操作同一个资源时，就会产生更新丢失、脏数据读取等问题，这是需要在业务层控制并发： 在应用层加锁 ， 或 应用层面预先冻结资源。

