# TCC
TCC(Try Confirm Cancel) 是应用层的两阶段提交，对代码的侵入性比较强，核心思想： 针对于每个操作，都要实现对应的确认和补偿操作，也就是业务逻辑的每个分支都要实现try,confirm,cancel三个操作，第一阶段由业务代码编排来调用Try接口进行资源预留，当所有参与者的Try接口都成功了，事务协调者提交事务，并调用参与者的confirm接口真正提交业务操作，否则调用每个参与者的cancel接口回滚事务，并且由于confirm或cancel有可能会重试，因此对应的部分`需要支持幂等`。

## TCC 如何保证最终一致性
- TCC事务机制以Try为中心的，Confirm确认操作和Cancel取消操作都是围绕Try操作而展开，因此，Try阶段中的操作，其保障性是最好的，即使失败，仍然有Cancel操作可以将其结果撤销。
- Try阶段执行成功并开始执行Confirm阶段时，默认Confirm阶段是不会出错的，也就是说，只要Try成功，Confirm一定成功。
- Confirm 与 Cancel如果失败，则有TCC框架进行重试补偿
- 存在极低概率在CC环节彻底失败，则需要定时任务或者人工介入

## TCC 注意事项
### 1. 允许空回滚
空回滚出现的原因是 Try超时或丢包 ， 导致TCC分布式事务二阶段的回滚，触发Cancel操作,此时事务参与者未收到Try，但是却收到了Cancel请求

### 2. 防悬挂控制
悬挂指的是二阶段的Cancel比一阶段的Try先执行，出现该问题的原因: Try由于网络拥堵而超时，导致事务管理器生成回滚，触发Cancel接口，但之后拥堵在网络的Try操作又被资源管理器收到了，但是Cancel比Try先到。则：
> 允许空回滚逻辑，回滚返回成功，事务管理器认为事务已经回滚成功，所以，此时应该拒绝执行空回滚后到来的Try操作，否则会导致数据不一致。

