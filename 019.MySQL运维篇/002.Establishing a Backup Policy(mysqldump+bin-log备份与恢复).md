# Establishing a Backup Policy <sup>建立备份策略:实战 mysqldump+bin-log</sup>
- [Establishing a Backup Policy 建立备份策略:实战 mysqldump+bin-log](#establishing-a-backup-policy-建立备份策略实战-mysqldumpbin-log)
  - [备份一下 (实战 mysqldump+bin-log)](#备份一下-实战-mysqldumpbin-log)
  - [参考资料](#参考资料)

```md
   # 摘要
     1. 备份策略:  全量备份 + 增量备份 , 全量备份耗时，因此需要增量备份提升备份效率
     2. 增量： 二进制日志时增量;
     3. 全量: mysqldump 导出的转储文件就是全量的数据（那一刻的）
     4. 全量 + 增量: 即 mysqldump 添加 --flush-logs 参数之后，在执行时，会生成一个新的二进制日志文件， 包含MySQL Server在此刻后的所有更改，mysqldump转储文件包含这一刻的所有数据(即全量)。即: 此刻的全量数据(mysqldump转储文件)+此刻后的所有更新(mysqldump执行后新生成的二进制日志文件) = 未来的全量数据
```

&nbsp;&nbsp;To be useful, backups must be scheduled regularly. A full backup (a snapshot of the data at a point in time) can be done in MySQL with several tools. For example, MySQL Enterprise Backup can perform a physical backup of an entire instance, with optimizations to minimize overhead and avoid disruption when backing up InnoDB data files; mysqldump provides online logical backup. This discussion uses mysqldump.(要发挥作用，必须定期安排备份。完全备份(数据在某个时间点的快照)可以在MySQL中使用几个工具完成。例如，MySQL企业备份可以执行整个实例的物理备份，通过优化最小化开销并避免备份InnoDB数据文件时的中断;Mysqldump提供在线逻辑备份。本讨论使用mysqldump。)

&nbsp;&nbsp;Assume that we make a full backup of all our InnoDB tables in all databases using the following command on Sunday at 1 p.m., when load is low:(假设我们在周日下午1点，当负载较低时，使用以下命令对所有数据库中的所有InnoDB表进行完全备份:)
```sql
     $> mysqldump --all-databases --master-data --single-transaction > backup_sunday_1_PM.sql
```

&nbsp;&nbsp;The resulting .sql file produced by mysqldump contains a set of SQL INSERT statements that can be used to reload the dumped tables at a later time.(mysqldump生成的. sql文件包含一组SQL INSERT语句，可以用来在以后重新加载转储的表。)

&nbsp;&nbsp;This backup operation acquires a global read lock on all tables at the beginning of the dump (using FLUSH TABLES WITH READ LOCK). As soon as this lock has been acquired, the binary log coordinates are read and the lock is released. If long updating statements are running when the FLUSH statement is issued, the backup operation may stall until those statements finish. After that, the dump becomes lock-free and does not disturb reads and writes on the tables.(这个备份操作在转储开始时获得所有表的全局读锁(使用FLUSH tables WITH read lock)。一旦获得该锁，就读取二进制日志坐标并释放该锁。如果在发出FLUSH语句时正在运行长更新语句，则备份操作可能会暂停，直到这些语句完成。在此之后，转储变为无锁状态，并且不会干扰表上的读写操作。)

&nbsp;&nbsp;It was assumed earlier that the tables to back up are InnoDB tables, so --single-transaction uses a consistent read and guarantees that data seen by mysqldump does not change. (Changes made by other clients to InnoDB tables are not seen by the mysqldump process.) If the backup operation includes nontransactional tables, consistency requires that they do not change during the backup. For example, for the MyISAM tables in the mysql database, there must be no administrative changes to MySQL accounts during the backup.(之前假设要备份的表是InnoDB表，所以--single-transaction使用一致性读取，并保证mysqldump看到的数据不会改变。(其他客户端对InnoDB表的修改不会被mysqldump进程看到。)如果备份操作包括非事务性表，则一致性要求它们在备份期间不会更改。例如，对于mysql数据库中的MyISAM表，在备份期间不得对mysql帐户进行管理更改。)
> 导出的是一个快照

&nbsp;&nbsp;Full backups are necessary, but it is not always convenient to create them. They produce large backup files and take time to generate. They are not optimal in the sense that each successive full backup includes all data, even that part that has not changed since the previous full backup. It is more efficient to make an initial full backup, and then to make incremental backups. The incremental backups are smaller and take less time to produce. The tradeoff is that, at recovery time, you cannot restore your data just by reloading the full backup. You must also process the incremental backups to recover the incremental changes.(完全备份是必要的，但是创建它们并不总是很方便。它们会产生大的备份文件，需要时间来生成。它们不是最优的，因为每次连续的完全备份都包括所有数据，甚至是自上次完全备份以来没有更改的部分。首先进行完全备份，然后进行增量备份，这样效率更高。增量备份更小，生成所需的时间更少。折衷之处在于，在恢复时，您不能仅仅通过重新加载完整备份来恢复数据。您还必须处理增量备份以恢复增量更改。)
> 全量备份是必要的，但全量备份需要很多时间，因此，备份策略需要选择: 全量 + 增量

&nbsp;&nbsp;To make incremental backups, we need to save the incremental changes. In MySQL, these changes are represented in the binary log, so the MySQL server should always be started with the --log-bin option to enable that log. With binary logging enabled, the server writes each data change into a file while it updates data. Looking at the data directory of a MySQL server that has been running for some days, we find these MySQL binary log files:(要进行增量备份，我们需要保存增量更改。在MySQL中，这些更改在二进制日志中表示，因此MySQL服务器应该始终使用--log-bin<sup>详见: my.cnf (launch.json)</sup>选项启动以启用该日志。启用二进制日志记录后，服务器在更新数据时将每个数据更改写入文件。查看已经运行了几天的MySQL服务器的data目录，我们发现这些MySQL二进制日志文件:)
```sql
   -rw-rw---- 1 guilhem  guilhem   1277324 Nov 10 23:59 gbichot2-bin.000001
   -rw-rw---- 1 guilhem  guilhem         4 Nov 10 23:59 gbichot2-bin.000002
   -rw-rw---- 1 guilhem  guilhem        79 Nov 11 11:06 gbichot2-bin.000003
   -rw-rw---- 1 guilhem  guilhem       508 Nov 11 11:08 gbichot2-bin.000004
   -rw-rw---- 1 guilhem  guilhem 220047446 Nov 12 16:47 gbichot2-bin.000005
   -rw-rw---- 1 guilhem  guilhem    998412 Nov 14 10:08 gbichot2-bin.000006
   -rw-rw---- 1 guilhem  guilhem       361 Nov 14 10:07 gbichot2-bin.index
```

&nbsp;&nbsp;Each time it restarts, the MySQL server creates a new binary log file using the next number in the sequence. While the server is running, you can also tell it to close the current binary log file and begin a new one manually by issuing a FLUSH LOGS SQL statement or with a mysqladmin flush-logs command. mysqldump also has an option to flush the logs. The .index file in the data directory contains the list of all MySQL binary logs in the directory.(每次重启时，MySQL服务器使用序列中的下一个数字创建一个新的二进制日志文件。在服务器运行时，还可以通过发出FLUSH LOGS SQL语句或mysqladmin FLUSH - LOGS命令，告诉它关闭当前二进制日志文件，并手动开始一个新的二进制日志文件。Mysqldump还有一个清除日志的选项。data目录中的.index文件包含该目录中所有MySQL二进制日志的列表。)

&nbsp;&nbsp;The MySQL binary logs are important for recovery because they form the set of incremental backups. If you make sure to flush the logs when you make your full backup, the binary log files created afterward contain all the data changes made since the backup. Let's modify the previous mysqldump command a bit so that it flushes the MySQL binary logs at the moment of the full backup, and so that the dump file contains the name of the new current binary log:(MySQL二进制日志对于恢复很重要，因为它们构成了一组增量备份。如果您确保在进行完全备份时刷新日志，那么之后创建的二进制日志文件将包含自备份以来所做的所有数据更改。让我们稍微修改一下之前的mysqldump命令，以便它在完全备份时刷新MySQL二进制日志，这样转储文件中就包含了新的当前二进制日志的名称:)
> 增量备份在二进制日志中，转储文件包含新的二进制日志名称。
```sql
   $> mysqldump --single-transaction --flush-logs --master-data=2  --all-databases > backup_sunday_1_PM.sql
```

&nbsp;&nbsp;After executing this command, the data directory contains a new binary log file, gbichot2-bin.000007, because the --flush-logs option causes the server to flush its logs. The --master-data option causes mysqldump to write binary log information to its output, so the resulting .sql dump file includes these lines:(执行该命令后，data目录中会包含一个新的二进制日志文件gbichot2-bin.000007，因为--flush-logs选项会导致服务器刷新其日志。--master-data选项会使mysqldump将二进制日志信息写入其输出，因此生成的.sql dump文件包括以下几行:)
```sql
   -- Position to start replication or point-in-time recovery from
   -- CHANGE MASTER TO MASTER_LOG_FILE='gbichot2-bin.000007',MASTER_LOG_POS=4;
```

&nbsp;&nbsp;Because the mysqldump command made a full backup, those lines mean two things:(因为mysqldump命令做了一个完整的备份，所以这些行意味着两件事:)
- The dump file contains all changes made before any changes written to the gbichot2-bin.000007 binary log file or higher.(转储文件包含在写入gbichot2-bin之前所做的所有更改.000007二进制日志文件或更高。)
- All data changes logged after the backup are not present in the dump file, but are present in the gbichot2-bin.000007 binary log file or higher.(备份后记录的所有数据更改都不会出现在转储文件中，但会出现在gbichot2-bin中.000007二进制日志文件或更高。)
> 所以，转储文件 + 转储文件中的二进制文件(如gbichot2-bin.000007)才是数据的完整备份

&nbsp;&nbsp;On Monday at 1 p.m., we can create an incremental backup by flushing the logs to begin a new binary log file. For example, executing a mysqladmin flush-logs command creates gbichot2-bin.000008. All changes between the Sunday 1 p.m. full backup and Monday 1 p.m. are written in gbichot2-bin.000007. This incremental backup is important, so it is a good idea to copy it to a safe place. (For example, back it up on tape or DVD, or copy it to another machine.) On Tuesday at 1 p.m., execute another mysqladmin flush-logs command. All changes between Monday 1 p.m. and Tuesday 1 p.m. are written in gbichot2-bin.000008 (which also should be copied somewhere safe).(在星期一下午1点，我们可以通过刷新日志来创建一个增量备份，以开始一个新的二进制日志文件。例如，执行mysqladmin flush-logs命令会创建gbichot2-bin.000008。周日下午1点完全备份到周一下午1点之间的所有更改都写入gbichot2-bin.000007中。这种增量备份很重要，因此最好将其复制到一个安全的地方。(例如，把它备份到磁带或DVD上，或者复制到另一台机器上。)星期二下午1点，执行另一个mysqladmin flush-logs命令。周一下午1点到周二下午1点之间的所有更改都写在gbichot2-bin.000008(也应该复制到安全的地方)。)

&nbsp;&nbsp;The MySQL binary logs take up disk space. To free up space, purge them from time to time. One way to do this is by deleting the binary logs that are no longer needed, such as when we make a full backup:(MySQL二进制日志占用磁盘空间。为了腾出空间，可以时不时地清理它们。一种方法是删除不再需要的二进制日志，例如当我们进行完整备份时:)
```sql
    $> mysqldump --single-transaction --flush-logs --master-data=2 \
         --all-databases --delete-master-logs > backup_sunday_1_PM.sql
```
> Deleting the MySQL binary logs with mysqldump --delete-master-logs can be dangerous if your server is a replication source server, because replicas might not yet fully have processed the contents of the binary log. The description for the PURGE BINARY LOGS statement explains what should be verified before deleting the MySQL binary logs. (如果您的服务器是复制源服务器，使用mysqldump --delete-master-logs删除MySQL二进制日志可能是危险的，因为副本可能尚未完全处理二进制日志的内容。PURGE BINARY LOGS语句的描述解释了在删除MySQL二进制日志之前应该验证什么。)

## 备份一下 (实战 mysqldump+bin-log)
```sql
   # 使用mysqldump 对测试库进行备份
   ## 数据准备
   mysql> show create table case_insensitive_summarize_data\G
   *************************** 1. row ***************************
          Table: case_insensitive_summarize_data
   Create Table: CREATE TABLE `case_insensitive_summarize_data` (
     `id` bigint(20) NOT NULL AUTO_INCREMENT,
     `gmt_create` datetime NOT NULL,
     `gmt_modified` datetime NOT NULL,
     `a` varchar(60) COLLATE utf8mb4_unicode_ci NOT NULL,
     `b` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
     `c` varchar(60) COLLATE utf8mb4_unicode_ci NOT NULL,
     `d` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
     PRIMARY KEY (`id`),
     UNIQUE KEY `uk_b` (`b`) USING BTREE,
     KEY `idx_a` (`a`) USING BTREE,
     KEY `idx_b` (`b`) USING BTREE
   ) ENGINE=InnoDB AUTO_INCREMENT=200005 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
   1 row in set (0.00 sec)
   
   mysql> select count(*) from case_insensitive_summarize_data;
   +----------+
   | count(*) |
   +----------+
   |        8 |
   +----------+
   1 row in set (3.10 sec)

   mysql> 

   ## 1. 全量备份
   ./mysqldump -P 3310  -uroot -p -S /tmp/mysql3310.sock stu_bak  --master-data --single-transaction > backup_sunday_1_PM.sql
   ## 2. 增量备份
   ./mysqldump -P 3310  -uroot -p -S /tmp/mysql3310.sock --single-transaction --flush-logs --master-data=2  stu_bak > backup_sunday_1_PM-001.sql
   ## 3. 添加数据
   mysql> insert into case_insensitive_summarize_data(gmt_create,gmt_modified,a,b,c,d) values(NOW(),NOW(),'a2','b2','c2','d2');
   ## 4. 恢复数据
   ### 4.1 备份时刻的全量数据恢复
   mysql> source /home/wei/WorkSpace/open_source/MySQL/001.SOURCE_CODE/000.mysql-server-5.7/build/001.build-output/client/backup_sunday_1_PM-003.sql
   ### 4.2 备份时刻后的增量数据恢复 (基于位置点的恢复)
   wei@Wang:~/WorkSpace/open_source/MySQL/001.SOURCE_CODE/000.mysql-server-5.7/build/001.build-output/client$ ./mysqlbinlog --no-defaults --start-position='154' /home/wei/WorkSpace/open_source/MySQL/001.SOURCE_CODE/000.mysql-server-5.7/build/002.build-scripts-v2/data/mysql-bin.000004  | ./mysql -P 3310  -uroot -p -S /tmp/mysql3310.sock 
   > 注意事项：
       a. --start-position='154'  --stop-position=232 通过命令: 来分析: wei@Wang:~/WorkSpace/open_source/MySQL/001.SOURCE_CODE/000.mysql-server-5.7/build/001.build-output/client$ ./mysqlbinlog --verbose /home/wei/WorkSpace/open_source/MySQL/001.SOURCE_CODE/000.mysql-server-5.7/build/002.build-scripts-v2/data/mysql-bin.000004
```

## 参考资料
- [Establishing a Backup Policy](https://dev.mysql.com/doc/refman/8.0/en/backup-policy.html)
- [Point-in-Time Recovery Using Binary Log](https://dev.mysql.com/doc/refman/8.0/en/point-in-time-recovery-binlog.html)
- [Point-in-Time Recovery Using Event Positions](https://dev.mysql.com/doc/refman/8.0/en/point-in-time-recovery-positions.html)










