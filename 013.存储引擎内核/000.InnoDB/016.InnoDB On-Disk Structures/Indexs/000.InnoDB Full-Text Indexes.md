# InnoDB Full-Text Indexes
## 摘要

## 正文
Full-text indexes are created on text-based columns (CHAR, VARCHAR, or TEXT columns) to speed up queries and DML operations on data contained within those columns. (全文索引是在基于文本的列(CHAR、VARCHAR或TEXT列)上创建的，以加快对这些列中包含的数据的查询和DML操作。)

A full-text index is defined as part of a CREATE TABLE statement or added to an existing table using ALTER TABLE or CREATE INDEX. (全文索引定义为CREATE TABLE语句的一部分，或者使用ALTER TABLE或CREATE index将全文索引添加到现有表中。)

Full-text search is performed using MATCH() ... AGAINST syntax. (全文搜索使用MATCH()…AGAINST语法。) , 语法参考:[Full-Text Search Functions](#1-full-text-search-functions)

### InnoDB Full-Text Index Design <sup>倒排索引设计</sup>
InnoDB full-text indexes have an inverted index design. Inverted indexes store a list of words, and for each word, a list of documents that the word appears in. To support proximity search, position information for each word is also stored, as a byte offset.(InnoDB全文索引采用了倒排索引设计。倒排索引存储一个单词列表，对于每个单词，存储该单词出现在其中的文档列表。为了支持邻近搜索，每个字的位置信息也以字节偏移量的形式存储。)

### InnoDB Full-Text Index Tables
When an InnoDB full-text index is created, a set of index tables is created, as shown in the following example:（创建InnoDB全文索引时，会创建一组索引表，示例如下:）
```sql
   DB: stu
   Server version: 5.7.34-debug-log Source distribution

   mysql> show create table opening_lines\G
   *************************** 1. row ***************************
          Table: opening_lines
   Create Table: CREATE TABLE `opening_lines` (
     `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
     `opening_line` text,
     `author` varchar(200) DEFAULT NULL,
     `title` varchar(200) DEFAULT NULL,
     PRIMARY KEY (`id`),
     FULLTEXT KEY `idx` (`opening_line`)
   ) ENGINE=InnoDB DEFAULT CHARSET=latin1
   1 row in set (0.00 sec)
   
   mysql> 

   # 查看指定目录文件 , 查看新增文件(表创建前的文件未展示)
   wei@Wang:~/WorkSpace/open_source/MySQL/001.SOURCE_CODE/000.mysql-server-5.7/build/000.build-scripts/data/stu$ ls -la
   -rw-r----- 1 wei wei  98304 Apr  1 23:14 FTS_0000000000000036_000000000000004d_INDEX_1.ibd
   -rw-r----- 1 wei wei  98304 Apr  1 23:14 FTS_0000000000000036_000000000000004d_INDEX_2.ibd
   -rw-r----- 1 wei wei  98304 Apr  1 23:14 FTS_0000000000000036_000000000000004d_INDEX_3.ibd
   -rw-r----- 1 wei wei  98304 Apr  1 23:14 FTS_0000000000000036_000000000000004d_INDEX_4.ibd
   -rw-r----- 1 wei wei  98304 Apr  1 23:14 FTS_0000000000000036_000000000000004d_INDEX_5.ibd
   -rw-r----- 1 wei wei  98304 Apr  1 23:14 FTS_0000000000000036_000000000000004d_INDEX_6.ibd
   -rw-r----- 1 wei wei  98304 Apr  1 23:14 FTS_0000000000000036_BEING_DELETED_CACHE.ibd
   -rw-r----- 1 wei wei  98304 Apr  1 23:14 FTS_0000000000000036_BEING_DELETED.ibd
   -rw-r----- 1 wei wei  98304 Apr  1 23:14 FTS_0000000000000036_CONFIG.ibd
   -rw-r----- 1 wei wei  98304 Apr  1 23:14 FTS_0000000000000036_DELETED_CACHE.ibd
   -rw-r----- 1 wei wei  98304 Apr  1 23:14 FTS_0000000000000036_DELETED.ibd
   -rw-r----- 1 wei wei   8668 Apr  1 23:14 opening_lines.frm
   -rw-r----- 1 wei wei 114688 Apr  1 23:14 opening_lines.ibd

   mysql> use INFORMATION_SCHEMA;
   mysql> select table_id,name,space from INNODB_SYS_TABLES where name LIKE 'stu/%';
   +----------+---------------------------------------------------+-------+
   | table_id | name                                              | space |
   +----------+---------------------------------------------------+-------+
   |       72 | stu/FTS_0000000000000042_000000000000005b_INDEX_1 |   105 |
   |       73 | stu/FTS_0000000000000042_000000000000005b_INDEX_2 |   106 |
   |       74 | stu/FTS_0000000000000042_000000000000005b_INDEX_3 |   107 |
   |       75 | stu/FTS_0000000000000042_000000000000005b_INDEX_4 |   108 |
   |       76 | stu/FTS_0000000000000042_000000000000005b_INDEX_5 |   109 |
   |       77 | stu/FTS_0000000000000042_000000000000005b_INDEX_6 |   110 |
   |       67 | stu/FTS_0000000000000042_BEING_DELETED            |   100 |
   |       68 | stu/FTS_0000000000000042_BEING_DELETED_CACHE      |   101 |
   |       69 | stu/FTS_0000000000000042_CONFIG                   |   102 |
   |       70 | stu/FTS_0000000000000042_DELETED                  |   103 |
   |       71 | stu/FTS_0000000000000042_DELETED_CACHE            |   104 |
   |       66 | stu/opening_lines                                 |    99 |
   +----------+---------------------------------------------------+-------+
   12 rows in set (0.01 sec)
   
   mysql> 
```

The first six index tables comprise the inverted index and are referred to as auxiliary index tables. When incoming documents are tokenized, the individual words (also referred to as “tokens”) are inserted into the index tables along with position information and an associated DOC_ID. The words are fully sorted and partitioned among the six index tables based on the character set sort weight of the word's first character.(前六个索引表组成倒排索引，称为辅助索引表。在对传入文档进行标记时，将单个单词(也称为“标记”)与位置信息和关联的DOC_ID一起插入索引表。根据单词第一个字符的字符集排序权重，将单词完全排序并在六个索引表中进行分区。)

The inverted index is partitioned into six auxiliary index tables to support parallel index creation. By default, two threads tokenize, sort, and insert words and associated data into the index tables. The number of threads that perform this work is configurable using the innodb_ft_sort_pll_degree variable. Consider increasing the number of threads when creating full-text indexes on large tables.(倒排索引被划分为六个辅助索引表，以支持并行索引创建。默认情况下，两个线程对单词和相关数据进行标记、排序和插入索引表。执行这项工作的线程数量可以使用innodb_ft_sort_pll_degree变量进行配置。在大型表上创建全文索引时，请考虑增加线程数。)

Auxiliary index table names are prefixed with fts_ and postfixed with index_#. Each auxiliary index table is associated with the indexed table by a hex value in the auxiliary index table name that matches the table_id of the indexed table. For example, the table_id of the stu/opening_lines table is 66, for which the hex value is 0x42. As shown in the preceding example, the “42” hex value appears in the names of auxiliary index tables that are associated with the test/opening_lines table.(辅助索引表名的前缀是fts_，后缀是index_#。每个辅助索引表通过与被索引表的table_id匹配的辅助索引表名中的十六进制值与被索引表相关联。例如，stu/opening_lines表的table_id为66，其十六进制值为0x42。如前面的示例所示，“42”十六进制值出现在与stu/opening_lines表相关联的辅助索引表的名称中。)
> PS: 本地测试table_id 是 66 ， 换算为十六进制为 0x42

> 表ID出现在辅助表名上

A hex value representing the index_id of the full-text index also appears in auxiliary index table names. For example, in the auxiliary table name stu/FTS_0000000000000042_000000000000005b_INDEX_3, the hex value 05b has a decimal value of 91. The index defined on the opening_lines table (idx) can be identified by querying the Information Schema INNODB_INDEXES table for this value (91).(表示全文索引的index_id的十六进制值也出现在辅助索引表名中。例如，在辅助表名stu/FTS_0000000000000042_000000000000005b_INDEX_3中，十六进制值05b的十进制值为91。opening_lines表(idx)上定义的索引可以通过查询信息模式INNODB_INDEXES表来确定这)
> 索引ID也出现在辅助表名上
```sql
    mysql> use INFORMATION_SCHEMA;
    mysql> SELECT index_id, name, table_id, space from INFORMATION_SCHEMA.INNODB_INDEXES WHERE index_id=457;
```

Index tables are stored in their own tablespace if the primary table is created in a file-per-table tablespace.  Otherwise, index tables are stored in the tablespace where the indexed table resides.(如果主表是在的所属的表空间是 file-per-table，则索引表存储在它们自己的表空间中。否则，索引表存储在被索引表所在的表空间中。)

The other index tables shown in the preceding example are referred to as common index tables and are used for deletion handling and storing the internal state of full-text indexes. Unlike the inverted index tables, which are created for each full-text index, this set of tables is common to all full-text indexes created on a particular table.(前面示例中显示的其他索引表被称为公共索引表，用于删除处理和存储全文索引的内部状态。与为每个全文索引创建的倒排索引表不同，这组表对于在特定表上创建的所有全文索引都是通用的。)
```txt
    哪些是共用的，哪些是独有的?

    公共索引表 是什么?
```

Common index tables are retained even if full-text indexes are dropped. When a full-text index is dropped, the FTS_DOC_ID column that was created for the index is retained, as removing the FTS_DOC_ID column would require rebuilding the previously indexed table. Common index tables are required to manage the FTS_DOC_ID column.(即使删除全文索引，也会保留公共索引表。当全文索引被删除时，为索引创建的FTS_DOC_ID列将被保留，因为删除FTS_DOC_ID列将需要重建先前索引的表。管理FTS_DOC_ID列需要公共索引表。)
- fts_\*_deleted and fts_\*_deleted_cache
  + Contain the document IDs (DOC_ID) for documents that are deleted but whose data is not yet removed from the full-text index. The fts_\*_deleted_cache is the in-memory version of the fts_\*_deleted table.

- fts_*_being_deleted and fts_*_being_deleted_cache
  + Contain the document IDs (DOC_ID) for documents that are deleted and whose data is currently in the process of being removed from the full-text index. The fts_\*_being_deleted_cache table is the in-memory version of the fts_\*_being_deleted table.

- fts_*_config
  + Stores information about the internal state of the full-text index. Most importantly, it stores the FTS_SYNCED_DOC_ID, which identifies documents that have been parsed and flushed to disk. In case of crash recovery, FTS_SYNCED_DOC_ID values are used to identify documents that have not been flushed to disk so that the documents can be re-parsed and added back to the full-text index cache. To view the data in this table, query the Information Schema INNODB_FT_CONFIG table.（存储有关全文索引的内部状态的信息。最重要的是，它存储FTS_SYNCED_DOC_ID，它标识已解析并刷新到磁盘的文档。在崩溃恢复的情况下，FTS_SYNCED_DOC_ID值用于标识尚未刷新到磁盘的文档，以便可以重新解析文档并将其添加回全文索引缓存。查询信息模式INNODB_FT_CONFIG表可以查看该表中的数据。）

### InnoDB Full-Text Index Cache
When a document is inserted, it is tokenized, and the individual words and associated data are inserted into the full-text index. This process, even for small documents, can result in numerous small insertions into the auxiliary index tables, making concurrent access to these tables a point of contention. To avoid this problem, InnoDB uses a full-text index cache to temporarily cache index table insertions for recently inserted rows. This in-memory cache structure holds insertions until the cache is full and then batch flushes them to disk (to the auxiliary index tables). You can query the Information Schema INNODB_FT_INDEX_CACHE table to view tokenized data for recently inserted rows.(当插入文档时，将对其进行标记，并将单个单词和相关数据插入全文索引中。这个过程，即使对于小文档，也可能导致对辅助索引表进行大量小的插入，从而使对这些表的并发访问成为争用点。为了避免这个问题，InnoDB使用全文索引缓存来临时缓存索引表中最近插入的行。这个内存缓存结构保存插入，直到缓存满，然后将它们批量刷新到磁盘(到辅助索引表)。您可以查询信息模式INNODB_FT_INDEX_CACHE表来查看最近插入的行的标记化数据。)
> 使用内存缓存来避免表文件的争用

The caching and batch flushing behavior avoids frequent updates to auxiliary index tables, which could result in concurrent access issues during busy insert and update times. The batching technique also avoids multiple insertions for the same word, and minimizes duplicate entries. Instead of flushing each word individually, insertions for the same word are merged and flushed to disk as a single entry, improving insertion efficiency while keeping auxiliary index tables as small as possible.（缓存和批处理刷新行为避免了对辅助索引表的频繁更新，这可能在繁忙的插入和更新期间导致并发访问问题。批处理技术还避免了对同一个单词的多次插入，并最大限度地减少了重复条目。不是逐个刷新每个单词，而是将相同单词的插入合并并作为单个条目刷新到磁盘，从而提高了插入效率，同时使辅助索引表尽可能小。）

The innodb_ft_cache_size variable is used to configure the full-text index cache size (on a per-table basis), which affects how often the full-text index cache is flushed. You can also define a global full-text index cache size limit for all tables in a given instance using the innodb_ft_total_cache_size variable.（innodb_ft_cache_size变量用于配置全文索引缓存大小(以每个表为基础)，它影响全文索引缓存刷新的频率。您还可以使用innodb_ft_total_cache_size变量为给定实例中的所有表定义全局全文索引缓存大小限制。）

The full-text index cache stores the same information as auxiliary index tables. However, the full-text index cache only caches tokenized data for recently inserted rows. The data that is already flushed to disk (to the auxiliary index tables) is not brought back into the full-text index cache when queried. The data in auxiliary index tables is queried directly, and results from the auxiliary index tables are merged with results from the full-text index cache before being returned.(全文索引缓存存储与辅助索引表相同的信息。但是，全文索引缓存仅为最近插入的行缓存标记化的数据。查询时，已经刷新到磁盘(辅助索引表)的数据不会被带回到全文索引缓存中。直接查询辅助索引表中的数据，并且在返回之前，将辅助索引表中的结果与全文索引缓存中的结果合并。)
```txt
   数据合并： 返回到客户端前，索引缓存 与 辅助索引表数据进行合并
```

### InnoDB Full-Text Index DOC_ID and FTS_DOC_ID Column
InnoDB uses a unique document identifier referred to as the DOC_ID to map words in the full-text index to document records where the word appears. The mapping requires an FTS_DOC_ID column on the indexed table. If an FTS_DOC_ID column is not defined, InnoDB automatically adds a hidden FTS_DOC_ID column when the full-text index is created. The following example demonstrates this behavior.（InnoDB使用唯一的文档标识符DOC_ID将全文索引中的单词映射到该单词出现的文档记录。映射需要索引表上的FTS_DOC_ID列。如果没有定义FTS_DOC_ID列，InnoDB会在创建全文索引时自动添加一个隐藏的FTS_DOC_ID列。下面的示例演示了这种行为。）
> 如果表不包含 FTS_DOC_ID 字段，那么在创建全文索引时，会自动创建该字段

```sql


    # When you create a full-text index on the table using CREATE FULLTEXT INDEX syntax, a warning is returned which reports that InnoDB is rebuilding the table to add the FTS_DOC_ID column.

```

The same warning is returned when using ALTER TABLE to add a full-text index to a table that does not have an FTS_DOC_ID column. If you create a full-text index at CREATE TABLE time and do not specify an FTS_DOC_ID column, InnoDB adds a hidden FTS_DOC_ID column, without warning.(当使用ALTER TABLE向没有FTS_DOC_ID列的表添加全文索引时，也会返回相同的警告。如果你在create TABLE时间创建一个全文索引，并且没有指定FTS_DOC_ID列，InnoDB会添加一个隐藏的FTS_DOC_ID列，没有警告。)

Defining an FTS_DOC_ID column at CREATE TABLE time is less expensive than creating a full-text index on a table that is already loaded with data. If an FTS_DOC_ID column is defined on a table prior to loading data, the table and its indexes do not have to be rebuilt to add the new column. If you are not concerned with CREATE FULLTEXT INDEX performance, leave out the FTS_DOC_ID column to have InnoDB create it for you. InnoDB creates a hidden FTS_DOC_ID column along with a unique index (FTS_DOC_ID_INDEX) on the FTS_DOC_ID column. If you want to create your own FTS_DOC_ID column, the column must be defined as BIGINT UNSIGNED NOT NULL and named FTS_DOC_ID (all uppercase), as in the following example:（在CREATE TABLE时定义一个FTS_DOC_ID列比在一个已经加载了数据的表上创建一个全文索引要便宜。如果在加载数据之前在表上定义了FTS_DOC_ID列，则不必重新构建表及其索引来添加新列。如果你不关心CREATE FULLTEXT INDEX的性能，可以省略FTS_DOC_ID列，让InnoDB为你创建它。InnoDB创建一个隐藏的FTS_DOC_ID列，并在FTS_DOC_ID列上创建一个唯一的索引(FTS_DOC_ID_INDEX)。如果你想创建自己的FTS_DOC_ID列，该列必须定义为BIGINT UNSIGNED NOT NULL，并命名为FTS_DOC_ID(全大写)，如下所示:）
```sql
  # 优先在创建表时定义FTS_DOC_ID列

     mysql> CREATE TABLE opening_lines (
       FTS_DOC_ID BIGINT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
       opening_line TEXT(500),
       author VARCHAR(200),
       title VARCHAR(200)
       ) ENGINE=InnoDB;
```

If you choose to define the FTS_DOC_ID column yourself, you are responsible for managing the column to avoid empty or duplicate values. FTS_DOC_ID values cannot be reused, which means FTS_DOC_ID values must be ever increasing.(如果选择自己定义FTS_DOC_ID列，则负责管理该列，以避免空值或重复值。FTS_DOC_ID的值不能重复使用，这意味着FTS_DOC_ID的值必须不断增加。)
```txt
    FTS_DOC_ID 自定义该列，那么就意味着要自己手动管理该列
```

Optionally, you can create the required unique FTS_DOC_ID_INDEX (all uppercase) on the FTS_DOC_ID column.（可选地，您可以在FTS_DOC_ID列上创建所需的惟一FTS_DOC_ID_INDEX(全部大写)。）
```sql
      mysql> CREATE UNIQUE INDEX FTS_DOC_ID_INDEX on opening_lines(FTS_DOC_ID);

    
     FTS_DOC_ID_INDEX cannot be defined as a descending index because the InnoDB SQL parser does not use descending indexes.
     > FTS_DOC_ID_INDEX 不能使用降序序列

```

If you do not create the FTS_DOC_ID_INDEX, InnoDB creates it automatically.(如果你没有创建FTS_DOC_ID_INDEX, InnoDB会自动创建它。)

The permitted gap between the largest used FTS_DOC_ID value and new FTS_DOC_ID value is 65535.(已使用的最大FTS_DOC_ID值与新的最大FTS_DOC_ID值之间的差距是65535。)

To avoid rebuilding the table, the FTS_DOC_ID column is retained when dropping a full-text index.(为了避免重新构建表，在删除全文索引时保留FTS_DOC_ID列。)

### InnoDB Full-Text Index Deletion Handling
Deleting a record that has a full-text index column could result in numerous small deletions in the auxiliary index tables, making concurrent access to these tables a point of contention. To avoid this problem, the DOC_ID of a deleted document is logged in a special FTS\_\*\_DELETED table whenever a record is deleted from an indexed table, and the indexed record remains in the full-text index. Before returning query results, information in the FTS\_\*\_DELETED table is used to filter out deleted DOC_IDs. The benefit of this design is that deletions are fast and inexpensive. The drawback is that the size of the index is not immediately reduced after deleting records. To remove full-text index entries for deleted records, run OPTIMIZE TABLE on the indexed table with innodb_optimize_fulltext_only=ON to rebuild the full-text index. 参考:[Optimizing InnoDB Full-Text Indexes](#2-optimizing-innodb-full-text-indexes)(删除具有全文索引列的记录可能会导致辅助索引表中出现大量小的删除，从而使对这些表的并发访问成为争用点。为了避免这个问题，每当从索引表中删除一条记录时，将已删除文档的DOC_ID记录在一个特殊的FTS_*_DELETED表中，并且被索引的记录保留在全文索引中。在返回查询结果之前，使用FTS_*_DELETED表中的信息过滤已删除的doc_id。这种设计的好处是，删除是快速和廉价的。缺点是在删除记录后索引的大小不会立即减小。要删除已删除记录的全文索引项，可以在已索引的表上运行OPTIMIZE TABLE命令(innodb_optimize_fulltext_only= on)重建全文索引。)
```txt
    删除记录时，也不是直接删除表中的记录，而是将DOC_ID缓存起来,减少表的争用。
    > 还是会自动删除的
```

### InnoDB Full-Text Index Transaction Handling
InnoDB full-text indexes have special transaction handling characteristics due its caching and batch processing behavior. Specifically, updates and insertions on a full-text index are processed at transaction commit time, which means that a full-text search can only see committed data. The following example demonstrates this behavior. The full-text search only returns a result after the inserted lines are committed.(InnoDB全文索引由于其缓存和批处理行为而具有特殊的事务处理特性。具体来说，全文索引上的更新和插入是在事务提交时处理的，这意味着全文搜索只能看到提交的数据。下面的示例演示了这种行为。全文搜索仅在提交插入的行之后返回结果。)
```sql
    # 示例，全文搜索只能看到提交后的数据（即使在插入的事务中查询也是一样）
     mysql> CREATE TABLE opening_lines (
            id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
            opening_line TEXT(500),
            author VARCHAR(200),
            title VARCHAR(200),
            FULLTEXT idx (opening_line)
            ) ENGINE=InnoDB;
     
     mysql> BEGIN;
     
     mysql> INSERT INTO opening_lines(opening_line,author,title) VALUES
            ('Call me Ishmael.','Herman Melville','Moby-Dick'),
            ('A screaming comes across the sky.','Thomas Pynchon','Gravity\'s Rainbow'),
            ('I am an invisible man.','Ralph Ellison','Invisible Man'),
            ('Where now? Who now? When now?','Samuel Beckett','The Unnamable'),
            ('It was love at first sight.','Joseph Heller','Catch-22'),
            ('All this happened, more or less.','Kurt Vonnegut','Slaughterhouse-Five'),
            ('Mrs. Dalloway said she would buy the flowers herself.','Virginia Woolf','Mrs. Dalloway'),
            ('It was a pleasure to burn.','Ray Bradbury','Fahrenheit 451');
     
     mysql> SELECT COUNT(*) FROM opening_lines WHERE MATCH(opening_line) AGAINST('Ishmael');
     +----------+
     | COUNT(*) |
     +----------+
     |        0 |
     +----------+
     
     mysql> COMMIT;
     
     mysql> SELECT COUNT(*) FROM opening_lines WHERE MATCH(opening_line) AGAINST('Ishmael');
     +----------+
     | COUNT(*) |
     +----------+
     |        1 |
     +----------+
```

### Monitoring InnoDB Full-Text Indexes
You can monitor and examine the special text-processing aspects of InnoDB full-text indexes by querying the following [INFORMATION_SCHEMA tables](https://dev.mysql.com/doc/refman/8.0/en/information-schema.html) <sup>具体表字段信息，请查阅官方文档</sup>:
- INNODB_FT_CONFIG
- INNODB_FT_INDEX_TABLE
- INNODB_FT_INDEX_CACHE
- INNODB_FT_DEFAULT_STOPWORD
- INNODB_FT_DELETED
- INNODB_FT_BEING_DELETED

You can also view basic information for full-text indexes and tables by querying INNODB_INDEXES and INNODB_TABLES. （还可以通过查询INNODB_INDEXES和INNODB_TABLES查询全文索引和全文表的基本信息。）

---

### 附录
#### 1. Full-Text Search Functions
```txt
   语法: MATCH (col1,col2,...) AGAINST (expr [search_modifier])

   search_modifier:
     {
          IN NATURAL LANGUAGE MODE
        | IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION
        | IN BOOLEAN MODE
        | WITH QUERY EXPANSION
     }
```

MySQL has support for full-text indexing and searching:(MySQL支持全文索引和搜索:)
+ A full-text index in MySQL is an index of type FULLTEXT.(MySQL中的全文索引是FULLTEXT类型的索引。)
+ Full-text indexes can be used only with InnoDB or MyISAM tables, and can be created only for CHAR, VARCHAR, or TEXT columns.(全文索引只能用于InnoDB或MyISAM表，并且只能用于CHAR, VARCHAR或TEXT列。)
+ MySQL provides a built-in full-text ngram parser that supports Chinese, Japanese, and Korean (CJK), and an installable MeCab full-text parser plugin for Japanese. Parsing differences are outlined in Section 14.9.8, “ngram Full-Text Parser”, and Section 14.9.9, “MeCab Full-Text Parser Plugin”.(全文解析器)
+ A FULLTEXT index definition can be given in the CREATE TABLE statement when a table is created, or added later using ALTER TABLE or CREATE INDEX.(全文索引创建方式)
+ For large data sets, it is much faster to load your data into a table that has no FULLTEXT index and then create the index after that, than to load data into a table that has an existing FULLTEXT index.(对于大型数据集，将数据加载到没有FULLTEXT索引的表中，然后再创建索引，要比将数据加载到已有FULLTEXT索引的表中快得多。)

Full-text searching is performed using MATCH() AGAINST() syntax. MATCH() takes a comma-separated list that names the columns to be searched. AGAINST takes a string to search for, and an optional modifier that indicates what type of search to perform. The search string must be a string value that is constant during query evaluation. This rules out, for example, a table column because that can differ for each row.（全文搜索使用MATCH() AGAINST()语法执行。MATCH()接受一个逗号分隔的列表，该列表指定要搜索的列。AGAINST接受一个要搜索的字符串和一个可选的修饰符，该修饰符指示要执行的搜索类型。搜索字符串必须是在查询求值期间保持不变的字符串值。例如，这排除了表列，因为每一行都可能不同。）

Previously, MySQL permitted the use of a rollup column with MATCH(), but queries employing this construct performed poorly and with unreliable results. (This is due to the fact that MATCH() is not implemented as a function of its arguments, but rather as a function of the row ID of the current row in the underlying scan of the base table.) As of MySQL 8.0.28, MySQL no longer allows such queries; more specifically, any query matching all of the criteria listed here is rejected with ER_FULLTEXT_WITH_ROLLUP:（以前，MySQL允许在MATCH()中使用汇总列，但是使用这种结构的查询性能很差，而且结果不可靠。(这是因为MATCH()不是作为其参数的函数实现的，而是作为基表底层扫描中当前行的行ID的函数实现的。)从MySQL 8.0.28开始，MySQL不再允许这样的查询;更具体地说，任何匹配这里列出的所有条件的查询都将被ER_FULLTEXT_WITH_ROLLUP拒绝: ）
+ MATCH() appears in the SELECT list, GROUP BY clause, HAVING clause, or ORDER BY clause of a query block.（MATCH()出现在查询块的SELECT列表、GROUP BY子句、HAVING子句或ORDER BY子句中。）
+ The query block contains a GROUP BY ... WITH ROLLUP clause.
+ The argument of the call to the MATCH() function is one of the grouping columns.
```sql
    # MATCH() in SELECT list...
    SELECT MATCH (a) AGAINST ('abc') FROM t GROUP BY a WITH ROLLUP;
    SELECT 1 FROM t GROUP BY a, MATCH (a) AGAINST ('abc') WITH ROLLUP;
    
    # ...in HAVING clause...
    SELECT 1 FROM t GROUP BY a WITH ROLLUP HAVING MATCH (a) AGAINST ('abc');
    
    # ...and in ORDER BY clause
    SELECT 1 FROM t GROUP BY a WITH ROLLUP ORDER BY MATCH (a) AGAINST ('abc');
```

The use of MATCH() with a rollup column in the WHERE clause is permitted.

There are three types of full-text searches:
+ A natural language search interprets the search string as a phrase in natural human language (a phrase in free text). There are no special operators, with the exception of double quote (") characters. The stopword list applies. For more information about stopword lists, see Section[“Full-Text Stopwords”](./000.InnoDB%20Full-Text%20Indexes/000.Full-Text%20Stopwords.md). (自然语言搜索将搜索字符串解释为自然人类语言中的短语(自由文本中的短语)。除了双引号(")字符外，没有特殊操作符。停止词列表适用)
  
+ Full-text searches are natural language searches if the IN NATURAL LANGUAGE MODE modifier is given or if no modifier is given. For more information, see Section [“Natural Language Full-Text Searches”](./000.InnoDB%20Full-Text%20Indexes/001.Natural%20Language%20Full-Text%20Searches.md)(如果给出了IN natural language MODE修饰符，或者没有给出修饰符，全文搜索就是自然语言搜索)
  
+ A boolean search interprets the search string using the rules of a special query language. The string contains the words to search for. It can also contain operators that specify requirements such that a word must be present or absent in matching rows, or that it should be weighted higher or lower than usual. Certain common words (stopwords) are omitted from the search index and do not match if present in the search string. The IN BOOLEAN MODE modifier specifies a boolean search. For more information, see [Boolean Full-Text Searches](./000.InnoDB%20Full-Text%20Indexes/003.Boolean%20Full-Text%20Searches.md).(布尔搜索使用特殊查询语言的规则解释搜索字符串。字符串包含要搜索的单词。它还可以包含指定要求的操作符，例如某个单词必须在匹配行中出现或不存在，或者该单词的权重应该高于或低于通常值。某些常用词(停止词)从搜索索引中省略，如果出现在搜索字符串中则不匹配。IN BOOLEAN MODE修饰符指定布尔搜索。)(查询扩展搜索是对自然语言搜索的修改。搜索字符串用于执行自然语言搜索。然后将搜索返回的最相关行的单词添加到搜索字符串中，并再次进行搜索。该查询返回第二次搜索的行。带有查询扩展或带有查询扩展修饰符的IN自然语言模式指定查询扩展搜索)
  
+ A query expansion search is a modification of a natural language search. The search string is used to perform a natural language search. Then words from the most relevant rows returned by the search are added to the search string and the search is done again. The query returns the rows from the second search. The IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION or WITH QUERY EXPANSION modifier specifies a query expansion search. For more information, see [Full-Text Searches with Query Expansion](./000.InnoDB%20Full-Text%20Indexes/004.Full-Text%20Searches%20with%20Query%20Expansion.md).


#### 2. Optimizing InnoDB Full-Text Indexes
Running OPTIMIZE TABLE on a table with a full-text index rebuilds the full-text index, removing deleted Document IDs and consolidating multiple entries for the same word, where possible.(在具有全文索引的表上运行OPTIMIZE TABLE会重建全文索引，在可能的情况下删除已删除的Document id并合并同一单词的多个条目。)

To optimize a full-text index, enable innodb_optimize_fulltext_only and run OPTIMIZE TABLE.(要优化全文索引，请启用innodb_optimize_fulltext_only并运行optimize TABLE。)
```sql
    mysql> set GLOBAL innodb_optimize_fulltext_only=ON;
    Query OK, 0 rows affected (0.01 sec)
    
    mysql> OPTIMIZE TABLE opening_lines;
    +--------------------+----------+----------+----------+
    | Table              | Op       | Msg_type | Msg_text |
    +--------------------+----------+----------+----------+
    | test.opening_lines | optimize | status   | OK       |
    +--------------------+----------+----------+----------+
    1 row in set (0.01 sec)
```
To avoid lengthy rebuild times for full-text indexes on large tables, you can use the innodb_ft_num_word_optimize option to perform the optimization in stages. The innodb_ft_num_word_optimize option defines the number of words that are optimized each time OPTIMIZE TABLE is run. The default setting is 2000, which means that 2000 words are optimized each time OPTIMIZE TABLE is run. Subsequent OPTIMIZE TABLE operations continue from where the preceding OPTIMIZE TABLE operation ended.(为了避免大型表上的全文索引重建时间过长，可以使用innodb_ft_num_word_optimize选项分阶段执行优化。innodb_ft_num_word_optimize选项定义每次OPTIMIZE TABLE运行时优化的字数。默认设置为2000，这意味着每次运行OPTIMIZE TABLE时优化2000个单词。后续的OPTIMIZE TABLE操作从前面的OPTIMIZE TABLE操作结束的地方继续进行。)

---

## 注意事项
1. 自然语言搜索，MATCH 里面的字段需要和全文索引字段保持一致，否则需要重新创建索引: [013.存储引擎内核/000.InnoDB/016.InnoDB On-Disk Structures/Indexs/000.InnoDB Full-Text Indexes/001.Natural Language Full-Text Searches.md](./000.InnoDB%20Full-Text%20Indexes/001.Natural%20Language%20Full-Text%20Searches.md) 搜索 '自然语言搜索，索引使用规则之一'
---
## 参考资料
1. [14.9 Full-Text Search Functions](https://dev.mysql.com/doc/refman/8.0/en/fulltext-search.html)
2. [17.6.2.4 InnoDB Full-Text Indexes](https://dev.mysql.com/doc/refman/8.0/en/innodb-fulltext-index.html)
3. 什么是倒排索引： 倒排索引源于实际应用中需要根据属性的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)