# Boolean Full-Text Searches
```txt
   1. 布尔查找的操作符
   2. 相关性计算公式
```

MySQL can perform boolean full-text searches using the IN BOOLEAN MODE modifier. With this modifier, certain characters have special meaning at the beginning or end of words in the search string. In the following query, the + and - operators indicate that a word must be present or absent, respectively, for a match to occur. Thus, the query retrieves all the rows that contain the word “MySQL” but that do not contain the word “YourSQL”:（MySQL可以使用IN boolean MODE修饰符执行布尔型全文搜索。使用此修饰符，某些字符在搜索字符串中单词的开头或结尾具有特殊含义。在下面的查询中，“+”和“-”操作符分别表示一个单词必须存在或不存在，才能发生匹配。因此，该查询检索所有包含单词“MySQL”但不包含单词“YourSQL”的行:）
```sql
   mysql> SELECT * FROM articles WHERE MATCH (title,body)
       -> AGAINST ('+MySQL -YourSQL' IN BOOLEAN MODE);
   +----+-----------------------+-------------------------------------+
   | id | title                 | body                                |
   +----+-----------------------+-------------------------------------+
   |  1 | MySQL Tutorial        | DBMS stands for DataBase ...        |
   |  2 | How To Use MySQL Well | After you went through a ...        |
   |  3 | Optimizing MySQL      | In this tutorial, we show ...       |
   |  4 | 1001 MySQL Tricks     | 1. Never run mysqld as root. 2. ... |
   |  6 | MySQL Security        | When configured properly, MySQL ... |
   +----+-----------------------+-------------------------------------+

   In implementing this feature, MySQL uses what is sometimes referred to as implied Boolean logic, in which
   + stands for AND
   - stands for NOT
   [no operator] implies OR
```

Boolean full-text searches have these characteristics:(布尔全文搜索有以下特点:)
+ They do not automatically sort rows in order of decreasing relevance.(它们不会自动按相关性递减的顺序对行进行排序。)
+ InnoDB tables require a FULLTEXT index on all columns of the MATCH() expression to perform boolean queries. Boolean queries against a MyISAM search index can work even without a FULLTEXT index, although a search executed in this fashion would be quite slow.(InnoDB表需要在MATCH()表达式的所有列上有一个FULLTEXT索引来执行布尔查询。即使没有FULLTEXT索引，对MyISAM搜索索引的布尔查询也可以工作，尽管以这种方式执行搜索会非常慢。)
+ The minimum and maximum word length full-text parameters apply to FULLTEXT indexes created using the built-in FULLTEXT parser and MeCab parser plugin. innodb_ft_min_token_size and innodb_ft_max_token_size are used for InnoDB search indexes. ft_min_word_len and ft_max_word_len are used for MyISAM search indexes.(最小和最大字长全文参数适用于使用内置FULLTEXT解析器和MeCab解析器插件创建的FULLTEXT索引。innodb_ft_min_token_size和innodb_ft_max_token_size用于InnoDB搜索索引。ft_min_word_len和ft_max_word_len用于MyISAM搜索索引。)
+ Minimum and maximum word length full-text parameters do not apply to FULLTEXT indexes created using the ngram parser. ngram token size is defined by the ngram_token_size option.(最小和最大字长全文参数不适用于使用ngram解析器创建的FULLTEXT索引。Ngram令牌大小由ngram_token_size选项定义。)
+ The stopword list applies, controlled by innodb_ft_enable_stopword, innodb_ft_server_stopword_table, and innodb_ft_user_stopword_table for InnoDB search indexes, and ft_stopword_file for MyISAM ones.(InnoDB的索引由innodb_ft_enable_stopword、innodb_ft_server_stopword_table和innodb_ft_user_stopword_table控制，MyISAM的索引由ft_stopword_file控制。)
+ InnoDB full-text search does not support the use of multiple operators on a single search word, as in this example: '++apple'. Use of multiple operators on a single search word returns a syntax error to standard out. MyISAM full-text search successfully processes the same search, ignoring all operators except for the operator immediately adjacent to the search word.(InnoDB全文搜索不支持在单个搜索词上使用多个操作符，例如:'++apple'。在单个搜索词上使用多个操作符将返回语法错误到标准输出。MyISAM全文搜索成功地处理相同的搜索，忽略除紧靠搜索词的操作符之外的所有操作符。)
+ InnoDB full-text search only supports leading plus or minus signs. For example, InnoDB supports '+apple' but does not support 'apple+'. Specifying a trailing plus or minus sign causes InnoDB to report a syntax error.(InnoDB全文搜索只支持前导加号或减号。例如，InnoDB支持“+apple”，但不支持“apple+”。指定后面的加号或减号会导致InnoDB报告语法错误。)
+ InnoDB full-text search does not support the use of a leading plus sign with wildcard ('+*'), a plus and minus sign combination ('+-'), or leading a plus and minus sign combination ('+-apple'). These invalid queries return a syntax error.(InnoDB全文搜索不支持使用带通配符的前导加号('+*')、正负号组合('+-')或正负号组合('+-apple')。这些无效查询返回语法错误。)
+ InnoDB full-text search does not support the use of the @ symbol in boolean full-text searches. The @ symbol is reserved for use by the @distance proximity search operator.(InnoDB全文搜索不支持在布尔全文搜索中使用@符号。@符号保留给@距离接近搜索操作符使用。)
+ They do not use the 50% threshold that applies to MyISAM search indexes.(它们不使用适用于MyISAM搜索索引的50%阈值。)


The boolean full-text search capability supports the following operators:(布尔全文搜索功能支持以下操作符:)
|操作符|描述|
|---|---|
|+|A leading or trailing plus sign indicates that this word must be present in each row that is returned.  InnoDB only supports leading plus signs.(前面或后面的加号表示该单词必须出现在返回的每行中。InnoDB只支持前导加号。)|
|-|A leading or trailing minus sign indicates that this word must not be present in any of the rows that are returned. InnoDB only supports leading minus signs.（前面或后面的减号表示该单词不能出现在返回的任何行中。InnoDB只支持前导负号。）|
|(no operator)|By default (when neither + nor - is specified), the word is optional, but the rows that contain it are rated higher. This mimics the behavior of MATCH() AGAINST() without the IN BOOLEAN MODE modifier.（默认情况下(当既没有指定+也没有指定-时)，单词是可选的，但是包含它的行被评为更高级别。这模仿了没有IN BOOLEAN MODE修饰符的MATCH() AGAINST()的行为。即 自然语言模式）|
|@distance|This operator works on InnoDB tables only. It tests whether two or more words all start within a specified distance from each other, measured in words. Specify the search words within a double-quoted string immediately before the @distance operator, for example, MATCH(col1) AGAINST('"word1 word2 word3" @8' IN BOOLEAN MODE)（这个操作符只对InnoDB表有效。它测试两个或多个单词是否都在彼此之间的指定距离内开始，以单词为单位。在@distance操作符前的双引号字符串中指定搜索词，例如，MATCH(col1) AGAINST('"word1 word2 word3" @8' IN BOOLEAN MODE)）|
|> <|These two operators are used to change a word's contribution to the relevance value that is assigned to a row.  The >  operator increases the contribution and the <  operator decreases it.  See the example following this list.（这两个操作符用于更改单词对分配给一行的相关性值的贡献。> 操作符增加贡献和<操作符减少。请参阅此列表后面的示例。）|
|()|Parentheses group words into subexpressions. Parenthesized groups can be nested.(括号将单词分组为子表达式。可以嵌套带括号的组。)|
|~|A leading tilde acts as a negation operator, causing the word's contribution to the row's relevance to be negative. This is useful for marking “noise” words. A row containing such a word is rated lower than others, but is not excluded altogether, as it would be with the - operator.(前导波浪作为否定运算符，使单词对行相关性的贡献为负。这对于标记“杂音”单词很有用。包含这样一个词的行被评为比其他行低，但不会完全排除，就像使用-操作符一样。): |
|*|The asterisk serves as the truncation (or wildcard) operator. Unlike the other operators, it is appended to the word to be affected. Words match if they begin with the word preceding the * operator.(星号用作截断(或通配符)操作符。与其他操作符不同的是，它被附加在要受影响的单词后面。以\*操作符前面的单词开头的单词匹配。)  If a word is specified with the truncation operator, it is not stripped from a boolean query, even if it is too short or a stopword. Whether a word is too short is determined from the innodb_ft_min_token_size setting for InnoDB tables, or ft_min_word_len for MyISAM tables. These options are not applicable to FULLTEXT indexes that use the ngram parser. (如果使用截断操作符指定了一个单词，则不会从布尔查询中删除该单词，即使它太短或是一个停止词。单词是否太短取决于InnoDB表的innodb_ft_min_token_size设置，或者MyISAM表的ft_min_word_len设置。这些选项不适用于使用ngram解析器的FULLTEXT索引。)The wildcarded word is considered as a prefix that must be present at the start of one or more words. If the minimum word length is 4, a search for '+word +the*' could return fewer rows than a search for '+word +the', because the second query ignores the too-short search term the.(通配符被视为必须出现在一个或多个单词开头的前缀。如果最小单词长度为4，那么搜索“+word +the*”可能会比搜索“+word +the”返回更少的行，因为第二个查询忽略了过短的搜索词the。)|
|"|A phrase that is enclosed within double quote (") characters matches only rows that contain the phrase literally, as it was typed. The full-text engine splits the phrase into words and performs a search in the FULLTEXT index for the words. Nonword characters need not be matched exactly: Phrase searching requires only that matches contain exactly the same words as the phrase and in the same order. For example, "test phrase" matches "test, phrase".(包含在双引号(")字符中的短语只匹配按字面意思输入的包含短语的行。全文引擎将短语分割成单词，并在FULLTEXT索引中为单词执行搜索。非单词字符不需要精确匹配:短语搜索只要求匹配包含与短语完全相同的单词，并且顺序相同。例如，“test phrase”匹配“test, phrase”。)。 If the phrase contains no words that are in the index, the result is empty. The words might not be in the index because of a combination of factors: if they do not exist in the text, are stopwords, or are shorter than the minimum length of indexed words.(如果短语在索引中不包含单词，则结果为空。由于多种因素的组合，单词可能不在索引中:如果它们不存在于文本中，是停顿词，或者比索引单词的最小长度短。)|


## Relevancy Rankings for InnoDB Boolean Mode Search （InnoDB布尔模式搜索的相关性排名）
InnoDB full-text search is modeled on the Sphinx full-text search engine, and the algorithms used are based on BM25 and TF-IDF ranking algorithms. For these reasons, relevancy rankings for InnoDB boolean full-text search may differ from MyISAM relevancy rankings.（InnoDB全文搜索以Sphinx全文搜索引擎为模型，使用的算法基于BM25和TF-IDF排序算法。由于这些原因，InnoDB布尔全文搜索的相关性排名可能与MyISAM的相关性排名不同。）

InnoDB uses a variation of the “term frequency-inverse document frequency” (TF-IDF) weighting system to rank a document's relevance for a given full-text search query. The TF-IDF weighting is based on how frequently a word appears in a document, offset by how frequently the word appears in all documents in the collection. In other words, the more frequently a word appears in a document, and the less frequently the word appears in the document collection, the higher the document is ranked.（InnoDB使用一种“术语频率-逆文档频率”(TF-IDF)加权系统，对给定全文搜索查询的文档相关性进行排序。TF-IDF权重基于一个单词在文档中出现的频率，并由该单词在集合中所有文档中出现的频率抵消。换句话说，一个单词在文档中出现的频率越高，而该单词在文档集合中出现的频率越低，该文档的排名就越高。）

## How Relevancy Ranking is Calculated （如何计算相关度排名）
The term frequency (TF) value is the number of times that a word appears in a document.  The inverse document frequency (IDF) value of a word is calculated using the following formula, where total_records is the number of records in the collection, and matching_records is the number of records that the search term appears in.（术语频率(TF)值是一个单词在文档中出现的次数。单词的逆文档频率(IDF)值使用以下公式计算，其中total_records是集合中的记录数，matching_records是搜索词出现在其中的记录数。）
```txt
    ${IDF} = log10( ${total_records} / ${matching_records} )
```

When a document contains a word multiple times, the IDF value is multiplied by the TF value:(当一个文档多次包含一个单词时，IDF值乘以TF值:)
```txt
   ${TF} * ${IDF}
```

Using the TF and IDF values, the relevancy ranking for a document is calculated using this formula:(使用TF和IDF值，使用以下公式计算文档的相关性排名:)
```txt
    ${rank} = ${TF} * ${IDF} * ${IDF}
```
## Relevancy Ranking for a Single Word Search (单个单词搜索的相关度排名)
This example demonstrates the relevancy ranking calculation for a single-word search.（这个例子演示了单个单词搜索的相关度排名计算。）

```sql
    # Server version: 5.7.34-debug-log Source distribution
    mysql> show create table articles \G
    *************************** 1. row ***************************
           Table: articles
    Create Table: CREATE TABLE `articles` (
      `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
      `title` varchar(200) DEFAULT NULL,
      `body` text,
      PRIMARY KEY (`id`),
      FULLTEXT KEY `title` (`title`,`body`)
    ) ENGINE=InnoDB DEFAULT CHARSET=latin1
    1 row in set (0.01 sec)

    mysql> INSERT INTO articles (title,body) VALUES  ('MySQL Tutorial','This database tutorial ...'),  ("How To Use MySQL",'After you went through a ...'),  ('Optimizing Your Database','In this database tutorial ...'),  ('MySQL vs. YourSQL','When comparing databases ...'),  ('MySQL Security','When configured properly, MySQL ...'),  ('Database, Database, Database','database database database'),  ('1001 MySQL Tricks','1. Never run mysqld as root. 2. ...'),  ('MySQL Full-Text Indexes', 'MySQL fulltext indexes use a ..');
    Query OK, 8 rows affected (0.02 sec)
    Records: 8  Duplicates: 0  Warnings: 0

    mysql>  SELECT id, title, body,  MATCH (title,body) AGAINST ('database' IN BOOLEAN MODE) AS score FROM articles ORDER BY score DESC;
    +----+------------------------------+-------------------------------------+---------------------+
    | id | title                        | body                                | score               |
    +----+------------------------------+-------------------------------------+---------------------+
    |  6 | Database, Database, Database | database database database          |  1.0886961221694946 |
    |  3 | Optimizing Your Database     | In this database tutorial ...       | 0.36289870738983154 |
    |  1 | MySQL Tutorial               | This database tutorial ...          | 0.18144935369491577 |
    |  2 | How To Use MySQL             | After you went through a ...        |                   0 |
    |  4 | MySQL vs. YourSQL            | When comparing databases ...        |                   0 |
    |  5 | MySQL Security               | When configured properly, MySQL ... |                   0 |
    |  7 | 1001 MySQL Tricks            | 1. Never run mysqld as root. 2. ... |                   0 |
    |  8 | MySQL Full-Text Indexes      | MySQL fulltext indexes use a ..     |                   0 |
    +----+------------------------------+-------------------------------------+---------------------+
    8 rows in set (0.00 sec)
```

There are 8 records in total, with 3 that match the “database” search term. The first record (id 6) contains the search term 6 times and has a relevancy ranking of 1.0886961221694946. This ranking value is calculated using a TF value of 6 (the “database” search term appears 6 times in record id 6) and an IDF value of 0.42596873216370745, which is calculated as follows (where 8 is the total number of records and 3 is the number of records that the search term appears in):(总共有8条记录，其中3条与“database”搜索词匹配。第一条记录(id 6)包含6次搜索词，相关度排名为1.0886961221694946。这个排序值是使用TF值6(“database”搜索词在id为6的记录中出现6次)和IDF值0.42596873216370745来计算的，其计算方法如下(其中8是记录总数，3是搜索词出现的记录数):)
```txt
     ${IDF} = LOG10( 8 / 3 ) = 0.42596873216370745

     因: ${rank} = ${TF} * ${IDF} * ${IDF}
     所以： 
     mysql>  SELECT 6*LOG10(8/3)*LOG10(8/3);
     +-------------------------+
     | 6*LOG10(8/3)*LOG10(8/3) |
     +-------------------------+
     |       1.088696164686938 |
     +-------------------------+
     1 row in set (0.00 sec)
```

## Relevancy Ranking for a Multiple Word Search
This example demonstrates the relevancy ranking calculation for a multiple-word full-text search based on the articles table and data used in the previous example.（这个示例演示了基于前一个示例中使用的文章表和数据的多词全文搜索的相关性排序计算。）

[**多个单次的相关性是单个相关性之和**]If you search on more than one word, the relevancy ranking value is a sum of the relevancy ranking value for each word, as shown in this formula:（如果搜索多个单词，则相关度排名值是每个单词相关度排名值的总和，如公式所示:）
```txt
    ${rank} = ${TF} * ${IDF} * ${IDF} + ${TF} * ${IDF} * ${IDF}

    mysql> SELECT id, title, body, MATCH (title,body)  AGAINST ('mysql tutorial' IN BOOLEAN MODE) AS score FROM articles ORDER BY score DESC;
    +----+------------------------------+-------------------------------------+----------------------+
    | id | title                        | body                                | score                |
    +----+------------------------------+-------------------------------------+----------------------+
    |  1 | MySQL Tutorial               | This database tutorial ...          |   0.7405621409416199 |
    |  3 | Optimizing Your Database     | In this database tutorial ...       |   0.3624762296676636 |
    |  5 | MySQL Security               | When configured properly, MySQL ... | 0.031219376251101494 |
    |  8 | MySQL Full-Text Indexes      | MySQL fulltext indexes use a ..     | 0.031219376251101494 |
    |  2 | How To Use MySQL             | After you went through a ...        | 0.015609688125550747 |
    |  4 | MySQL vs. YourSQL            | When comparing databases ...        | 0.015609688125550747 |
    |  7 | 1001 MySQL Tricks            | 1. Never run mysqld as root. 2. ... | 0.015609688125550747 |
    |  6 | Database, Database, Database | database database database          |                    0 |
    +----+------------------------------+-------------------------------------+----------------------+
    8 rows in set (0.00 sec)

    mysql> SELECT (1*log10(8/6)*log10(8/6)) + (2*log10(8/2)*log10(8/2));
    +-------------------------------------------------------+
    | (1*log10(8/6)*log10(8/6)) + (2*log10(8/2)*log10(8/2)) |
    +-------------------------------------------------------+
    |                                    0.7405621541938003 |
    +-------------------------------------------------------+
    1 row in set (0.00 sec)
```

## 参考资料
1. [Boolean Full-Text Searches](https://dev.mysql.com/doc/refman/8.0/en/fulltext-boolean.html)





