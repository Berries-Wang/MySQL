# File-Per-Table Tablespaces
```txt
  # File-Per-Table 表空间
  1. 每个表，行数据和索引数据均存储在一个${table_name}.ibd文件中
  2. 定时优化表，可以提高性能
  3. 该表空间模式可以更好的恢复 迁移...

```

A file-per-table tablespace contains data and indexes for a single InnoDB table, and is stored on the file system in a single data file.(File-Per-Table 表空间包含单个InnoDB表的数据和索引，并存储在文件系统中的单个数据文件中。)

# File-Per-Table Tablespace Configuration
InnoDB creates tables in file-per-table tablespaces by default. This behavior is controlled by the innodb_file_per_table variable. Disabling innodb_file_per_table causes InnoDB to create tables in the system tablespace.(InnoDB默认在file-per-table表空间中创建表。此行为由innodb_file_per_table变量控制。关闭innodb_file_per_table会导致InnoDB在系统表空间中创建表。)

An innodb_file_per_table setting can be specified in an option file or configured at runtime using a SET GLOBAL statement. Changing the setting at runtime requires privileges sufficient to set global system variables.(innodb_file_per_table设置可以在选项文件中指定，也可以在运行时使用SET GLOBAL语句进行配置。在运行时更改设置需要足够的权限来设置全局系统变量。)

```txt
   [mysqld]
   innodb_file_per_table=ON
    OR 
   mysql> SET GLOBAL innodb_file_per_table=ON;
```

## File-Per-Table Tablespace Data Files
A file-per-table tablespace is created in an .ibd data file in a schema directory under the MySQL data directory. The .ibd file is named for the table (table_name.ibd). For example, the data file for table test.t1 is created in the test directory under the MySQL data directory:(File-Per-Table 表空间创建一个.idb数据文件在数据库数据目录下的名字为数据库名的文件夹下，.ibd文件的名字是${table_name}.ibd)
```txt
  
  mysql> show create table articles \G
  *************************** 1. row ***************************
         Table: articles
  Create Table: CREATE TABLE `articles` (
    `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
    `title` varchar(200) DEFAULT NULL,
    `body` text,
    PRIMARY KEY (`id`),
    FULLTEXT KEY `title` (`title`,`body`)
  ) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=latin1
  1 row in set (0.00 sec)
   
   ...MySQL/001.SOURCE_CODE/000.mysql-server-5.7/build/000.build-scripts/data/stu$ ll
   -rw-r----- 1 wei wei   8618 Apr  4 10:47 articles.frm
   -rw-r----- 1 wei wei 114688 Apr  4 11:14 articles.ibd
```

You can use the DATA DIRECTORY clause of the CREATE TABLE statement to implicitly create a file-per-table tablespace data file outside of the data directory.(你也可以指定DATA DIRECTORY子句来指定file-per-table 表空间的数据文件),参考[“Creating Tables Externally”.](../Tables/001.Creating%20Tables%20Externally.md)

## File-Per-Table Tablespace Advantages
File-per-table tablespaces have the following advantages over shared tablespaces such as the system tablespace or general tablespaces.(与 system tablespace 和 general tablespaces 相比，file-per-table表空间有如下好处)
- [**磁盘空间会返还给操作系统**]Disk space is returned to the operating system after truncating or dropping a table created in a file-per-table tablespace. Truncating or dropping a table stored in a shared tablespace creates free space within the shared tablespace data file, which can only be used for InnoDB data. In other words, a shared tablespace data file does not shrink in size after a table is truncated or dropped.(在截断或删除在每表文件表空间中创建的表后，将磁盘空间返回给操作系统。截断或删除存储在共享表空间中的表会在共享表空间数据文件中创建空闲空间，这些空间只能用于InnoDB数据。换句话说，在表被截断或删除后，共享表空间数据文件的大小不会缩小。)
- [**DDL语句不会释放表空间（非file-per-table表空间）**]A table-copying ALTER TABLE operation on a table that resides in a shared tablespace can increase the amount of disk space occupied by the tablespace. Such operations may require as much additional space as the data in the table plus indexes. This space is not released back to the operating system as it is for file-per-table tablespaces.（对驻留在共享表空间中的表执行表复制ALTER table操作会增加该表空间占用的磁盘空间量。这样的操作可能需要与表中的数据加上索引一样多的额外空间。此空间不会像每个表的文件表空间那样释放回操作系统。）
- TRUNCATE TABLE performance is better when executed on tables that reside in file-per-table tablespaces.（TRUNCATE TABLE在位于每表文件的表空间中的表上执行时性能更好。）
- File-per-table tablespace data files can be created on separate storage devices for I/O optimization, space management, or backup purposes.(为了I/O优化、空间管理或备份目的，可以在单独的存储设备上创建每个表空间文件的数据文件。) 参考[“Creating Tables Externally”.](../Tables/001.Creating%20Tables%20Externally.md)
- You can import a table that resides in file-per-table tablespace from another MySQL instance.(您可以从另一个MySQL实例导入驻留在file-per-table表空间中的表。)参考:[“Importing InnoDB Tables”](./../Tables/000.Importing%20InnoDB%20Tables.md)
- Tables created in file-per-table tablespaces support features associated with DYNAMIC and COMPRESSED row formats, which are not supported by the system tablespace.(在file-per-table表空间中创建的表支持与DYNAMIC和COMPRESSED行格式相关的特性，这些特性是系统表空间不支持的。)
- Tables stored in individual tablespace data files can save time and improve chances for a successful recovery when data corruption occurs, when backups or binary logs are unavailable, or when the MySQL server instance cannot be restarted.(存储在单个表空间数据文件中的表可以节省时间，并在发生数据损坏、备份或二进制日志不可用或MySQL服务器实例无法重新启动时提高成功恢复的机会。)
- Tables created in file-per-table tablespaces can be backed up or restored quickly using MySQL Enterprise Backup, without interrupting the use of other InnoDB tables. This is beneficial for tables on varying backup schedules or that require backup less frequently.(在file-per-table表空间中创建的表可以使用MySQL企业备份快速备份或恢复，而不会中断其他InnoDB表的使用。这对于具有不同备份计划的表或需要较少备份的表是有益的。) 参考:[Making a Partial Backup ]()
- File-per-table tablespaces permit monitoring table size on the file system by monitoring the size of the tablespace data file.(File-per-table表空间允许通过监视表空间数据文件的大小来监视文件系统上的表大小。)
- Common Linux file systems do not permit concurrent writes to a single file such as a shared tablespace data file when innodb_flush_method is set to O_DIRECT. As a result, there are possible performance improvements when using file-per-table tablespaces in conjunction with this setting.(当innodb_flush_method设置为O_DIRECT时，普通Linux文件系统不允许并发写单个文件，例如共享表空间数据文件。因此，当将每个表文件的表空间与此设置结合使用时，可能会有性能改进。)
- Tables in a shared tablespace are limited in size by the 64TB tablespace size limit. By comparison, each file-per-table tablespace has a 64TB size limit, which provides plenty of room for individual tables to grow in size.(共享表空间中的表受64TB表空间大小限制。相比之下，每个表文件表空间的大小限制为64TB，这为单个表的大小增长提供了足够的空间。)

## File-Per-Table Tablespace Disadvantages
+ [**表空间的浪费**]With file-per-table tablespaces, each table may have unused space that can only be utilized by rows of the same table, which can lead to wasted space if not properly managed.(对于file-per-table表空间，每个表可能都有未使用的空间，这些空间只能由同一表的行使用，如果管理不当，可能会导致空间浪费。)
+ fsync operations are performed on multiple file-per-table data files instead of a single shared tablespace data file. Because fsync operations are per file, write operations for multiple tables cannot be combined, which can result in a higher total number of fsync operations.(Fsync操作在多个file-per-table表空间的数据文件上执行，而不是在单个共享表空间数据文件上执行。因为fsync操作是针对每个文件的，所以不能合并多个表的写操作，这可能导致fsync操作的总数更高。)
+ mysqld must keep an open file handle for each file-per-table tablespace, which may impact performance if you have numerous tables in file-per-table tablespaces.（Mysqld必须为每个file-per-table空间保持一个打开的文件句柄，如果在file-per-table表空间中有许多表，这可能会影响性能。）
+ More file descriptors are required when each table has its own data file.（当每个表都有自己的数据文件时，需要更多的文件描述符。）
+ There is potential for more fragmentation, which can impede DROP TABLE and table scan performance. However, if fragmentation is managed, file-per-table tablespaces can improve performance for these operations.（有可能产生更多的碎片，这会影响DROP TABLE和表扫描的性能。但是，如果管理碎片，则每个表文件的表空间可以提高这些操作的性能。）
+ The buffer pool is scanned when dropping a table that resides in a file-per-table tablespace, which can take several seconds for large buffer pools. The scan is performed with a broad internal lock, which may delay other operations.（当删除驻留在file-per-table表空间中的表时，将扫描缓冲池，对于大型缓冲池，这可能需要几秒钟的时间。扫描是用一个宽的内部锁执行的，这可能会延迟其他操作。）
+ The innodb_autoextend_increment variable, which defines the increment size for extending the size of an auto-extending shared tablespace file when it becomes full, does not apply to file-per-table tablespace files, which are auto-extending regardless of the innodb_autoextend_increment setting. Initial file-per-table tablespace extensions are by small amounts, after which extensions occur in increments of 4MB.innodb_autoextend_increment变量定义了自动扩展共享表空间文件满时扩展它的增量大小，但它不适用于file-per-table表空间文件，因为无论innodb_autoextend_increment设置如何，表空间文件都是自动扩展的。初始的每个表文件表空间扩展很小，之后扩展以4MB为增量。

---
## 参考资料
1. [File-Per-Table Tablespaces](https://dev.mysql.com/doc/refman/8.0/en/innodb-file-per-table-tablespaces.html)

















