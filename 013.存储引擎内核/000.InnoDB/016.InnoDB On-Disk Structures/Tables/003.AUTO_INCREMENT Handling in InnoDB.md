# AUTO_INCREMENT Handling in InnoDB
## 摘要
1. 影响备份（主从复制）

## 资料
&nbsp;&nbsp;InnoDB provides a configurable locking mechanism that can significantly improve scalability and performance of SQL statements that add rows to tables with AUTO_INCREMENT columns. To use the AUTO_INCREMENT mechanism with an InnoDB table, an AUTO_INCREMENT column must be defined as the first or only column of some index such that it is possible to perform the equivalent of an indexed SELECT MAX(ai_col) lookup on the table to obtain the maximum column value. The index is not required to be a PRIMARY KEY or UNIQUE, but to avoid duplicate values in the AUTO_INCREMENT column, those index types are recommended.(InnoDB提供了一种可配置的锁机制，可以显著提高SQL语句在AUTO_INCREMENT列的表中添加行的可伸缩性和性能。要在InnoDB表中使用AUTO_INCREMENT机制，必须将AUTO_INCREMENT列定义为某个索引的第一列或唯一列，以便可以在表上执行相当于索引SELECT MAX(ai_col)查找以获得最大列值。索引不需要是PRIMARY KEY或UNIQUE，但为了避免AUTO_INCREMENT列中的重复值，建议使用这些索引类型。)
```txt
     > Server version: 5.7.34-debug-log Source distribution
     
     mysql> create table auto_inc( id bigint primary key ,  id_a bigint auto_increment);
     ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key
     
     mysql> create table auto_inc( id bigint primary key ,  id_a bigint auto_increment, index aa(id_a) );
     Query OK, 0 rows affected (0.04 sec)
     
     mysql> insert into auto_inc(id,id_a) values(1,1);
     Query OK, 1 row affected (0.02 sec)
     
     mysql> insert into auto_inc(id,id_a) values(2,1);
     Query OK, 1 row affected (0.01 sec)
     
     mysql> insert into auto_inc(id,id_a) values(2,1);
     ERROR 1062 (23000): Duplicate entry '2' for key 'PRIMARY'
     mysql> insert into auto_inc(id) values(3);
     Query OK, 1 row affected (0.02 sec)
     
     mysql> select * from auto_inc;
     +----+------+
     | id | id_a |
     +----+------+
     |  1 |    1 |
     |  2 |    1 |
     |  3 |    2 |
     +----+------+
     3 rows in set (0.00 sec)
     
     mysql>

      # 值不允许重复吗? 经过测试，是可以的
```

### InnoDB AUTO_INCREMENT Lock Modes
&nbsp;&nbsp;This section describes the AUTO_INCREMENT lock modes used to generate auto-increment values, and how each lock mode affects replication. The auto-increment lock mode is configured at startup using the innodb_autoinc_lock_mode variable.(本节描述用于生成自动递增值的AUTO_INCREMENT锁模式，以及每种锁模式如何影响复制。自增锁模式在启动时使用innodb_autoinc_lock_mode变量进行配置。)

#### The following terms<sup>术语；措辞；</sup> are used in describing innodb_autoinc_lock_mode settings:

1.  “INSERT-like” statements
    - All statements that generate new rows in a table, including INSERT, INSERT ... SELECT, REPLACE, REPLACE ... SELECT, and LOAD DATA. Includes “simple-inserts”, “bulk-inserts”, and “mixed-mode” inserts.

2. “Simple inserts”
    - Statements for which the number of rows to be inserted can be determined in advance<sup>预先的</sup> (when the statement is initially processed). This includes single-row and multiple-row INSERT and REPLACE statements that do not have a nested(嵌套的) subquery, but not INSERT ... ON DUPLICATE KEY UPDATE.

3. “Bulk inserts”
    - Statements for which the number of rows to be inserted (and the number of required auto-increment values) is not known in advance. This includes INSERT ... SELECT, REPLACE ... SELECT, and LOAD DATA statements, but not plain INSERT. InnoDB assigns new values for the AUTO_INCREMENT column one at a time as each row is processed.

4. “Mixed-mode inserts”
    - These are “simple insert” statements that specify the auto-increment value for some (but not all) of the new rows. An example follows, where c1 is an AUTO_INCREMENT column of table t1:
      ```sql
            INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
      ```

    - Another type of “mixed-mode insert” is INSERT ...  ON DUPLICATE KEY UPDATE, which in the worst case is in effect an INSERT followed by a UPDATE, where the allocated value for the AUTO_INCREMENT column may or may not be used during the update phase.（另外一种"mixed-mode insert"是 INSERT ...  ON DUPLICATE KEY UPDATE,在最坏的情况下，实际上是先插入，然后再更新，其中为AUTO_INCREMENT列分配的值可能在更新阶段使用，也可能不使用）

&nbsp;&nbsp;There are three possible settings for the innodb_autoinc_lock_mode variable. The settings are 0, 1, or 2, for “traditional”, “consecutive”, or “interleaved” lock mode, respectively. As of MySQL 8.0, interleaved lock mode (innodb_autoinc_lock_mode=2) is the default setting. Prior to MySQL 8.0, consecutive lock mode is the default (innodb_autoinc_lock_mode=1).(innodb_autoinc_lock_mode变量有三种可能的设置。“传统”、“连续”或“交错”锁模式的设置分别为0、1或2。在MySQL 8.0中，交错锁模式(innodb_autoinc_lock_mode=2)是默认设置。在MySQL 8.0之前，默认是连续锁模式(innodb_autoinc_lock_mode=1)。)
```txt
  三种锁模式的体现是怎么样的?
    “traditional”:
    “consecutive”:
    “interleaved”: 
```

&nbsp;&nbsp;The default setting of interleaved lock mode in MySQL 8.0 reflects the change from statement-based replication to row based replication as the default replication type. Statement-based replication requires the consecutive auto-increment lock mode to ensure that auto-increment values are assigned in a predictable and repeatable order for a given sequence of SQL statements, whereas row-based replication is not sensitive to the execution order of SQL statements.(MySQL8.0默认的 interleaved lock mode 配置反映出了赋值类型由statement-based replication修改为了row based replication，基于语句的复制需要连续的自动递增锁模式，以确保自动递增的值以可预测和可重复的顺序为给定的SQL语句序列分配，而基于行的复制对SQL语句的执行顺序不敏感。)
+ innodb_autoinc_lock_mode = 0 (“traditional” lock mode)
  - The traditional lock mode provides the same behavior that existed before the innodb_autoinc_lock_mode variable was introduced. The traditional lock mode option is provided for backward compatibility, performance testing, and working around issues with “mixed-mode inserts”, due to possible differences in semantics.（传统的锁模式提供了与引入innodb_autoinc_lock_mode变量之前相同的行为。提供传统的锁模式选项是为了向后兼容、性能测试和解决“混合模式插入”的问题，因为可能存在语义上的差异。）
  - In this lock mode, all “INSERT-like” statements obtain a special table-level AUTO-INC lock for inserts into tables with AUTO_INCREMENT columns.  This lock is normally held to the end of the statement (not to the end of the transaction) to ensure that auto-increment values are assigned in a predictable and repeatable order for a given sequence of INSERT statements, and to ensure that auto-increment values assigned by any given statement are consecutive.（在这种锁模式下，所有“INSERT-like”语句都获得一个特殊的表级AUTO-INC锁，用于向具有AUTO_INCREMENT列的表中插入数据。该锁通常保持到语句的末尾(而不是事务的末尾)，以确保对给定的INSERT语句序列按可预测和可重复的顺序分配自动递增值，并确保任何给定语句分配的自动递增值是连续的。）
  - In the case of statement-based replication, this means that when an SQL statement is replicated on a replica server, the same values are used for the auto-increment column as on the source server.  The result of execution of multiple INSERT statements is deterministic, and the replica reproduces the same data as on the source.  If auto-increment values generated by multiple INSERT statements were interleaved, the result of two concurrent INSERT statements would be nondeterministic, and could not reliably be propagated to a replica server using statement-based replication.（对于基于语句的复制，这意味着在复制服务器上复制SQL语句时，自动递增列的值与源服务器上的值相同。执行多个INSERT语句的结果是确定的，副本复制的数据与源数据相同。如果多个INSERT语句生成的自动递增值是交错的，则两个并发INSERT语句的结果将是不确定的，并且不能使用基于语句的复制可靠地传播到副本服务器。）
  - To make this clear, consider an example that uses this table:
    ```sql
       CREATE TABLE t1 (
         c1 INT(11) NOT NULL AUTO_INCREMENT,
         c2 VARCHAR(10) DEFAULT NULL,
         PRIMARY KEY (c1)
       ) ENGINE=InnoDB;
    ```
    - Suppose that there are two transactions running, each inserting rows into a table with an AUTO_INCREMENT column. One transaction is using an INSERT ... SELECT statement that inserts 1000 rows, and another is using a simple INSERT statement that inserts one row:（假设有两个事务正在运行，每个事务都将行插入到带有AUTO_INCREMENT列的表中。一个事务正在使用INSERT…SELECT语句插入1000行，另一个使用简单的INSERT语句插入一行:）
      ```sql
         Tx1: INSERT INTO t1 (c2) SELECT 1000 rows from another table ...
         Tx2: INSERT INTO t1 (c2) VALUES ('xxx');
      ```
    - InnoDB cannot tell in advance how many rows are retrieved from the SELECT in the INSERT statement in Tx1, and it assigns the auto-increment values one at a time as the statement proceeds.  With a table-level lock, held to the end of the statement, only one INSERT statement referring to table t1 can execute at a time, and the generation of auto-increment numbers by different statements is not interleaved.  The auto-increment values generated by the Tx1 INSERT ...  SELECT statement are consecutive, and the (single) auto-increment value used by the INSERT statement in Tx2 is either smaller or larger than all those used for Tx1, depending on which statement executes first.(InnoDB无法预先告诉Tx1中的INSERT语句从SELECT中检索了多少行，并且它会在语句执行过程中每次分配一个自动递增值。使用表级锁(一直保持到语句末尾)，一次只能执行一条引用表t1的INSERT语句，并且不同语句生成的自动递增编号不会交叉。由Tx1插入生成的自动递增值…SELECT语句是连续的，并且Tx2中INSERT语句使用的(单个)自动递增值比Tx1中使用的所有自动递增值都小或大，这取决于首先执行哪条语句。)
    - As long as the SQL statements execute in the same order when replayed from the binary log (when using statement-based replication, or in recovery scenarios), the results are the same as they were when Tx1 and Tx2 first ran.  Thus, table-level locks held until the end of a statement make INSERT statements using auto-increment safe for use with statement-based replication.  However, those table-level locks limit concurrency and scalability when multiple transactions are executing insert statements at the same time.（只要SQL语句在二进制日志中以相同的顺序执行(在使用基于语句的复制时，或在恢复场景中)，结果就与Tx1和Tx2第一次运行时相同。因此，表级别的锁一直保持到语句结束，使得使用自动递增的INSERT语句可以安全地与基于语句的复制一起使用。然而，当多个事务同时执行insert语句时，这些表级锁限制了并发性和可伸缩性。）
      > 所以，多表关联不能通过这种自增的列。
    - In the preceding example, if there were no table-level lock, the value of the auto-increment column used for the INSERT in Tx2 depends on precisely when the statement executes.  If the INSERT of Tx2 executes while the INSERT of Tx1 is running (rather than before it starts or after it completes), the specific auto-increment values assigned by the two INSERT statements are nondeterministic, and may vary from run to run.()
    - In the preceding example, if there were no table-level lock, the value of the auto-increment column used for the INSERT in Tx2 depends on precisely when the statement executes.  If the INSERT of Tx2 executes while the INSERT of Tx1 is running (rather than before it starts or after it completes), the specific auto-increment values assigned by the two INSERT statements are nondeterministic, and may vary from run to run.（在前面的示例中，如果没有表级锁，那么Tx2中用于插入的自动递增列的值完全取决于语句执行的时间。如果Tx2的插入是在Tx1的插入运行时执行的(而不是在它开始之前或完成之后)，那么两个INSERT语句分配的特定的自动递增值是不确定的，并且可能在不同的运行中有所不同。）
    - Under the consecutive lock mode, InnoDB can avoid using table-level AUTO-INC locks for “simple insert” statements where the number of rows is known in advance, and still preserve<sup>保护，维护</sup> deterministic execution and safety for statement-based replication.(在连续锁模式下，InnoDB可以避免使用表级的AUTO-INC锁来处理预先知道行数的简单insert语句，并保持执行的确定性和基于语句的复制的安全性。)
    - If you are not using the binary log to replay SQL statements as part of recovery or replication, the interleaved lock mode can be used to eliminate all use of table-level AUTO-INC locks for even greater concurrency and performance, at the cost of permitting gaps in auto-increment numbers assigned by a statement and potentially having the numbers assigned by concurrently executing statements interleaved.(如果你不使用二进制日志来重放SQL语句作为恢复或复制的一部分，那么交错锁模式可以用来消除所有表级的AUTO-INC锁，以获得更大的并发性和性能，但代价是允许语句分配的自动递增编号之间有间隙，并且可能通过交错并发执行语句分配编号。)

+ innodb_autoinc_lock_mode = 1 (“consecutive” lock mode)
  

&nbsp;&nbsp;

## 参考资料
1. [17.6.1.6 AUTO_INCREMENT Handling in InnoDB](https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html)