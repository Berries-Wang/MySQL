# AUTO_INCREMENT Handling in InnoDB
## 摘要
1. 影响备份（主从复制）

## 资料
&nbsp;&nbsp;InnoDB provides a configurable locking mechanism that can significantly improve scalability and performance of SQL statements that add rows to tables with AUTO_INCREMENT columns. To use the AUTO_INCREMENT mechanism with an InnoDB table, an AUTO_INCREMENT column must be defined as the first or only column of some index such that it is possible to perform the equivalent of an indexed SELECT MAX(ai_col) lookup on the table to obtain the maximum column value. The index is not required to be a PRIMARY KEY or UNIQUE, but to avoid duplicate values in the AUTO_INCREMENT column, those index types are recommended.(InnoDB提供了一种可配置的锁机制，可以显著提高SQL语句在AUTO_INCREMENT列的表中添加行的可伸缩性和性能。要在InnoDB表中使用AUTO_INCREMENT机制，必须将AUTO_INCREMENT列定义为某个索引的第一列或唯一列，以便可以在表上执行相当于索引SELECT MAX(ai_col)查找以获得最大列值。索引不需要是PRIMARY KEY或UNIQUE，但为了避免AUTO_INCREMENT列中的重复值，建议使用这些索引类型。)
```txt
     > Server version: 5.7.34-debug-log Source distribution
     
     mysql> create table auto_inc( id bigint primary key ,  id_a bigint auto_increment);
     ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key
     
     mysql> create table auto_inc( id bigint primary key ,  id_a bigint auto_increment, index aa(id_a) );
     Query OK, 0 rows affected (0.04 sec)
     
     mysql> insert into auto_inc(id,id_a) values(1,1);
     Query OK, 1 row affected (0.02 sec)
     
     mysql> insert into auto_inc(id,id_a) values(2,1);
     Query OK, 1 row affected (0.01 sec)
     
     mysql> insert into auto_inc(id,id_a) values(2,1);
     ERROR 1062 (23000): Duplicate entry '2' for key 'PRIMARY'
     mysql> insert into auto_inc(id) values(3);
     Query OK, 1 row affected (0.02 sec)
     
     mysql> select * from auto_inc;
     +----+------+
     | id | id_a |
     +----+------+
     |  1 |    1 |
     |  2 |    1 |
     |  3 |    2 |
     +----+------+
     3 rows in set (0.00 sec)
     
     mysql>

      # 值不允许重复吗? 经过测试，是可以的
```

### InnoDB AUTO_INCREMENT Lock Modes
&nbsp;&nbsp;This section describes the AUTO_INCREMENT lock modes used to generate auto-increment values, and how each lock mode affects replication. The auto-increment lock mode is configured at startup using the innodb_autoinc_lock_mode variable.(本节描述用于生成自动递增值的AUTO_INCREMENT锁模式，以及每种锁模式如何影响复制。自增锁模式在启动时使用innodb_autoinc_lock_mode变量进行配置。)

#### The following terms<sup>术语；措辞；</sup> are used in describing innodb_autoinc_lock_mode settings:

1.  “INSERT-like” statements
    - All statements that generate new rows in a table, including INSERT, INSERT ... SELECT, REPLACE, REPLACE ... SELECT, and LOAD DATA. Includes “simple-inserts”, “bulk-inserts”, and “mixed-mode” inserts.

2. “Simple inserts”
    - Statements for which the number of rows to be inserted can be determined in advance<sup>预先的</sup> (when the statement is initially processed). This includes single-row and multiple-row INSERT and REPLACE statements that do not have a nested(嵌套的) subquery, but not INSERT ... ON DUPLICATE KEY UPDATE.

3. “Bulk inserts”
    - Statements for which the number of rows to be inserted (and the number of required auto-increment values) is not known in advance. This includes INSERT ... SELECT, REPLACE ... SELECT, and LOAD DATA statements, but not plain INSERT. InnoDB assigns new values for the AUTO_INCREMENT column one at a time as each row is processed.

4. “Mixed-mode inserts”
    - These are “simple insert” statements that specify the auto-increment value for some (but not all) of the new rows. An example follows, where c1 is an AUTO_INCREMENT column of table t1:
      ```sql
            INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
      ```

    - Another type of “mixed-mode insert” is INSERT ...  ON DUPLICATE KEY UPDATE, which in the worst case is in effect an INSERT followed by a UPDATE, where the allocated value for the AUTO_INCREMENT column may or may not be used during the update phase.（另外一种"mixed-mode insert"是 INSERT ...  ON DUPLICATE KEY UPDATE,在最坏的情况下，实际上是先插入，然后再更新，其中为AUTO_INCREMENT列分配的值可能在更新阶段使用，也可能不使用）

&nbsp;&nbsp;There are three possible settings for the innodb_autoinc_lock_mode variable. The settings are 0, 1, or 2, for “traditional”, “consecutive”, or “interleaved” lock mode, respectively. As of MySQL 8.0, interleaved lock mode (innodb_autoinc_lock_mode=2) is the default setting. Prior to MySQL 8.0, consecutive lock mode is the default (innodb_autoinc_lock_mode=1).(innodb_autoinc_lock_mode变量有三种可能的设置。“传统”、“连续”或“交错”锁模式的设置分别为0、1或2。在MySQL 8.0中，交错锁模式(innodb_autoinc_lock_mode=2)是默认设置。在MySQL 8.0之前，默认是连续锁模式(innodb_autoinc_lock_mode=1)。)
```txt
  三种锁模式的体现是怎么样的?
    “traditional”:
    “consecutive”:
    “interleaved”: 
```

&nbsp;&nbsp;The default setting of interleaved lock mode in MySQL 8.0 reflects the change from statement-based replication to row based replication as the default replication type. Statement-based replication requires the consecutive auto-increment lock mode to ensure that auto-increment values are assigned in a predictable and repeatable order for a given sequence of SQL statements, whereas row-based replication is not sensitive to the execution order of SQL statements.(MySQL8.0默认的 interleaved lock mode 配置反映出了赋值类型由statement-based replication修改为了row based replication，基于语句的复制需要连续的自动递增锁模式，以确保自动递增的值以可预测和可重复的顺序为给定的SQL语句序列分配，而基于行的复制对SQL语句的执行顺序不敏感。)
+ innodb_autoinc_lock_mode = 0 (“traditional” lock mode)
  - The traditional lock mode provides the same behavior that existed before the innodb_autoinc_lock_mode variable was introduced. The traditional lock mode option is provided for backward compatibility, performance testing, and working around issues with “mixed-mode inserts”, due to possible differences in semantics.（传统的锁模式提供了与引入innodb_autoinc_lock_mode变量之前相同的行为。提供传统的锁模式选项是为了向后兼容、性能测试和解决“混合模式插入”的问题，因为可能存在语义上的差异。）
  - In this lock mode, all “INSERT-like” statements obtain a special table-level AUTO-INC lock for inserts into tables with AUTO_INCREMENT columns.  This lock is normally held to the end of the statement (not to the end of the transaction) to ensure that auto-increment values are assigned in a predictable and repeatable order for a given sequence of INSERT statements, and to ensure that auto-increment values assigned by any given statement are consecutive.（在这种锁模式下，所有“INSERT-like”语句都获得一个特殊的表级AUTO-INC锁，用于向具有AUTO_INCREMENT列的表中插入数据。该锁通常保持到语句的末尾(而不是事务的末尾)，以确保对给定的INSERT语句序列按可预测和可重复的顺序分配自动递增值，并确保任何给定语句分配的自动递增值是连续的。）
  - In the case of statement-based replication, this means that when an SQL statement is replicated on a replica server, the same values are used for the auto-increment column as on the source server.  The result of execution of multiple INSERT statements is deterministic, and the replica reproduces the same data as on the source.  If auto-increment values generated by multiple INSERT statements were interleaved, the result of two concurrent INSERT statements would be nondeterministic, and could not reliably be propagated to a replica server using statement-based replication.（对于基于语句的复制，这意味着在复制服务器上复制SQL语句时，自动递增列的值与源服务器上的值相同。执行多个INSERT语句的结果是确定的，副本复制的数据与源数据相同。如果多个INSERT语句生成的自动递增值是交错的，则两个并发INSERT语句的结果将是不确定的，并且不能使用基于语句的复制可靠地传播到副本服务器。）
  - To make this clear, consider an example that uses this table:
    ```sql
       CREATE TABLE t1 (
         c1 INT(11) NOT NULL AUTO_INCREMENT,
         c2 VARCHAR(10) DEFAULT NULL,
         PRIMARY KEY (c1)
       ) ENGINE=InnoDB;
    ```
    - Suppose that there are two transactions running, each inserting rows into a table with an AUTO_INCREMENT column. One transaction is using an INSERT ... SELECT statement that inserts 1000 rows, and another is using a simple INSERT statement that inserts one row:（假设有两个事务正在运行，每个事务都将行插入到带有AUTO_INCREMENT列的表中。一个事务正在使用INSERT…SELECT语句插入1000行，另一个使用简单的INSERT语句插入一行:）
      ```sql
         Tx1: INSERT INTO t1 (c2) SELECT 1000 rows from another table ...
         Tx2: INSERT INTO t1 (c2) VALUES ('xxx');
      ```
    - InnoDB cannot tell in advance how many rows are retrieved from the SELECT in the INSERT statement in Tx1, and it assigns the auto-increment values one at a time as the statement proceeds.  With a table-level lock, held to the end of the statement, only one INSERT statement referring to table t1 can execute at a time, and the generation of auto-increment numbers by different statements is not interleaved.  The auto-increment values generated by the Tx1 INSERT ...  SELECT statement are consecutive, and the (single) auto-increment value used by the INSERT statement in Tx2 is either smaller or larger than all those used for Tx1, depending on which statement executes first.(InnoDB无法预先告诉Tx1中的INSERT语句从SELECT中检索了多少行，并且它会在语句执行过程中每次分配一个自动递增值。使用表级锁(一直保持到语句末尾)，一次只能执行一条引用表t1的INSERT语句，并且不同语句生成的自动递增编号不会交叉。由Tx1插入生成的自动递增值…SELECT语句是连续的，并且Tx2中INSERT语句使用的(单个)自动递增值比Tx1中使用的所有自动递增值都小或大，这取决于首先执行哪条语句。)
    - As long as the SQL statements execute in the same order when replayed from the binary log (when using statement-based replication, or in recovery scenarios), the results are the same as they were when Tx1 and Tx2 first ran.  Thus, table-level locks held until the end of a statement make INSERT statements using auto-increment safe for use with statement-based replication.  However, those table-level locks limit concurrency and scalability when multiple transactions are executing insert statements at the same time.（只要SQL语句在二进制日志中以相同的顺序执行(在使用基于语句的复制时，或在恢复场景中)，结果就与Tx1和Tx2第一次运行时相同。因此，表级别的锁一直保持到语句结束，使得使用自动递增的INSERT语句可以安全地与基于语句的复制一起使用。然而，当多个事务同时执行insert语句时，这些表级锁限制了并发性和可伸缩性。）
      > 所以，多表关联不能通过这种自增的列。
    - In the preceding example, if there were no table-level lock, the value of the auto-increment column used for the INSERT in Tx2 depends on precisely when the statement executes.  If the INSERT of Tx2 executes while the INSERT of Tx1 is running (rather than before it starts or after it completes), the specific auto-increment values assigned by the two INSERT statements are nondeterministic, and may vary from run to run.()
    - In the preceding example, if there were no table-level lock, the value of the auto-increment column used for the INSERT in Tx2 depends on precisely when the statement executes.  If the INSERT of Tx2 executes while the INSERT of Tx1 is running (rather than before it starts or after it completes), the specific auto-increment values assigned by the two INSERT statements are nondeterministic, and may vary from run to run.（在前面的示例中，如果没有表级锁，那么Tx2中用于插入的自动递增列的值完全取决于语句执行的时间。如果Tx2的插入是在Tx1的插入运行时执行的(而不是在它开始之前或完成之后)，那么两个INSERT语句分配的特定的自动递增值是不确定的，并且可能在不同的运行中有所不同。）
    - Under the consecutive lock mode, InnoDB can avoid using table-level AUTO-INC locks for “simple insert” statements where the number of rows is known in advance, and still preserve<sup>保护，维护</sup> deterministic execution and safety for statement-based replication.(在连续锁模式下，InnoDB可以避免使用表级的AUTO-INC锁来处理预先知道行数的简单insert语句，并保持执行的确定性和基于语句的复制的安全性。)
    - If you are not using the binary log to replay SQL statements as part of recovery or replication, the interleaved lock mode can be used to eliminate all use of table-level AUTO-INC locks for even greater concurrency and performance, at the cost of permitting gaps in auto-increment numbers assigned by a statement and potentially having the numbers assigned by concurrently executing statements interleaved.(如果你不使用二进制日志来重放SQL语句作为恢复或复制的一部分，那么交错锁模式可以用来消除所有表级的AUTO-INC锁，以获得更大的并发性和性能，但代价是允许语句分配的自动递增编号之间有间隙，并且可能通过交错并发执行语句分配编号。)

+ innodb_autoinc_lock_mode = 1 (“consecutive” lock mode)
   - In this mode, “bulk inserts” use the special AUTO-INC table-level lock and hold it until the end of the statement. This applies to all INSERT ... SELECT, REPLACE ... SELECT, and LOAD DATA statements. Only one statement holding the AUTO-INC lock can execute at a time. If the source table of the bulk insert operation is different from the target table, the AUTO-INC lock on the target table is taken after a shared lock is taken on the first row selected from the source table. If the source and target of the bulk insert operation are the same table, the AUTO-INC lock is taken after shared locks are taken on all selected rows.(在这种模式下，“bulk inserts” 使用特殊的AUTO-INC表级锁并保持它直到语句结束。这适用于所有INSERT ... SELECT，REPLACE ... SELECT和LOAD DATA语句。一次只能执行一条持有AUTO-INC锁的语句。如果大容量插入操作的源表与目标表不同，则在对源表中选择的第一行执行共享锁之后，对目标表执行AUTO-INC锁。如果大容量插入操作的源表和目标表是同一个表，则在对所有选定的行使用共享锁之后使用AUTO-INC锁。)

   - “Simple inserts” (for which the number of rows to be inserted is known in advance) avoid table-level AUTO-INC locks by obtaining the required number of auto-increment values under the control of a mutex (a light-weight lock) that is only held for the duration of the allocation process, not until the statement completes<sup>not until 涉及语法，即：语句完成是非延续性的，即是一瞬间的，所以需要加上not,表示延续：即没有完成，</sup>. No table-level AUTO-INC lock is used unless an AUTO-INC lock is held by another transaction. If another transaction holds an AUTO-INC lock, a “simple insert” waits for the AUTO-INC lock, as if it were a “bulk insert”.(“简单插入”(要插入的行数是事先已知的)通过在互斥锁(轻量级锁)的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁，互斥锁只在分配过程期间持有，直到语句完成。除非AUTO-INC锁被另一个事务持有，否则不会使用表级AUTO-INC锁。如果另一个事务持有AUTO-INC锁，则“简单插入”等待AUTO-INC锁，就像它是“批量插入”一样。)

   - This lock mode ensures that, in the presence of INSERT statements where the number of rows is not known in advance (and where auto-increment numbers are assigned as the statement progresses), all auto-increment values assigned by any “INSERT-like” statement are consecutive, and operations are safe for statement-based replication.(这种锁模式确保，在存在事先不知道行数的INSERT语句时(并且在语句进行时分配自动增量数)，任何“INSERT-like”语句分配的所有自动增量值都是连续的，并且操作对于基于语句的复制是安全的。)

   - Simply put, this lock mode significantly improves scalability while being safe for use with statement-based replication. Further, as with “traditional” lock mode, auto-increment numbers assigned by any given statement are consecutive. There is no change in semantics compared to “traditional” mode for any statement that uses auto-increment, with one important exception.(简单地说，这种锁模式大大提高了可伸缩性，同时对于基于语句的复制来说是安全的。此外，与“传统”锁模式一样，任何给定语句分配的自动递增数是连续的。对于任何使用自动递增的语句，与“传统”模式相比，在语义上没有变化，但有一个重要的例外。)

   - The exception is for “mixed-mode inserts”, where the user provides explicit values for an AUTO_INCREMENT column for some, but not all, rows in a multiple-row “simple insert”. For such inserts, InnoDB allocates more auto-increment values than the number of rows to be inserted. However, all values automatically assigned are consecutively generated (and thus higher than) the auto-increment value generated by the most recently executed previous statement. “Excess” numbers are lost.(例外是“混合模式插入”，其中用户为多行“简单插入”中的一些(但不是全部)行提供AUTO_INCREMENT列的显式值。对于这样的插入，InnoDB分配的自动增量值比要插入的行数要多。但是，所有自动分配的值都是连续生成的(因此高于)最近执行的前一个语句生成的自动增量值。“多余”的数字丢失了。)

+ innodb_autoinc_lock_mode = 2 (“interleaved<sup>（尤指将片状物）插入；交替（两个或两个以上数码信号）；交叉存取</sup>” lock mode)
   - In this lock mode, no “INSERT-like” statements use the table-level AUTO-INC lock, and multiple statements can execute at the same time. This is the fastest and most scalable lock mode, but it is not safe when using statement-based replication or recovery scenarios when SQL statements are replayed from the binary log.(在这种锁模式下，没有“INSERT-like”语句使用表级AUTO-INC锁，并且多个语句可以同时执行。这是最快和最具可伸缩性的锁模式，但是当使用基于语句的复制或从二进制日志中重播SQL语句的恢复场景时，它并不安全。)
   - In this lock mode, auto-increment values are guaranteed to be unique and monotonically increasing across all concurrently executing “INSERT-like” statements. However, because multiple statements can be generating numbers at the same time (that is, allocation of numbers is interleaved across statements), the values generated for the rows inserted by any given statement may not be consecutive.(在这种锁定模式下，自动增量值保证在所有并发执行的“INSERT-like”语句中是唯一且单调递增的。但是，由于多个语句可以同时生成数字(也就是说，数字的分配在多个语句之间交错进行)，因此为任何给定语句插入的行生成的值可能不是连续的。)
   - If the only statements executing are “simple inserts” where the number of rows to be inserted is known ahead of time, there are no gaps in the numbers generated for a single statement, except for “mixed-mode inserts”. However, when “bulk inserts” are executed, there may be gaps in the auto-increment values assigned by any given statement.(如果只执行“simple inserts”语句，其中要插入的行数是事先已知的，则为单个语句生成的行数没有间隔，除了“混合模式插入”。然而，当执行“批量插入”时，任何给定语句分配的自动增量值可能存在间隙。)

### InnoDB AUTO_INCREMENT Lock Mode Usage Implications<sup>n.暗指，暗示；蕴含，含义；（可能带来的）影响</sup>
+ Using auto-increment with replication
    - If you are using statement-based replication, set innodb_autoinc_lock_mode to 0 or 1 and use the same value on the source and its replicas. Auto-increment values are not ensured to be the same on the replicas as on the source if you use innodb_autoinc_lock_mode = 2 (“interleaved”) or configurations where the source and replicas do not use the same lock mode.(如果使用基于语句的复制，请将innodb_autoinc_lock_mode设置为0或1，并在源及其副本上使用相同的值。如果使用innodb_autoinc_lock_mode = 2 (" interleaved ")或者源和副本不使用相同锁模式的配置，则不能确保副本上的自动增量值与源上的相同。)
    - If you are using row-based or mixed-format replication, all of the auto-increment lock modes are safe, since row-based replication is not sensitive to the order of execution of the SQL statements (and the mixed format uses row-based replication for any statements that are unsafe for statement-based replication).(如果您使用的是基于行或混合格式的复制，那么所有的自动增量锁模式都是安全的，因为基于行的复制对SQL语句的执行顺序不敏感(混合格式使用基于行的复制来处理对于基于语句的复制来说不安全的任何语句)。)

+ “Lost” auto-increment values and sequence gaps (“丢失”自动增量值和序列间隙)
    - In all lock modes (0, 1, and 2), if a transaction that generated auto-increment values rolls back, those auto-increment values are “lost”. Once a value is generated for an auto-increment column, it cannot be rolled back, whether or not the “INSERT-like” statement is completed, and whether or not the containing transaction is rolled back. Such lost values are not reused. Thus, there may be gaps in the values stored in an AUTO_INCREMENT column of a table.(在所有的锁模式(0、1和2)中，如果一个事务产生了自动增量值回滚，那么这些自动增量值就会“丢失”。一旦为自动递增列生成了值，无论“INSERT-like”语句是否完成，也无论包含的事务是否回滚，都不能回滚该值。这些丢失的值不会被重用。因此，存储在表的AUTO_INCREMENT列中的值可能存在空白。)

+ Specifying NULL or 0 for the AUTO_INCREMENT column
  - In all lock modes (0, 1, and 2), if a user specifies NULL or 0 for the AUTO_INCREMENT column in an INSERT, InnoDB treats the row as if the value was not specified and generates a new value for it.(在所有锁模式下(0、1、2)，如果用户在INSERT操作中为AUTO_INCREMENT列指定了NULL或0,InnoDB会将该行视为没有指定该值，并为其生成一个新值。)

+ Assigning a negative value to the AUTO_INCREMENT column
  - In all lock modes (0, 1, and 2), the behavior of the auto-increment mechanism is undefined if you assign a negative value to the AUTO_INCREMENT column.(在所有锁模式(0、1和2)中，如果给AUTO_INCREMENT列赋一个负值，则自动递增机制的行为是未定义的。)

+ If the AUTO_INCREMENT value becomes larger than the maximum integer for the specified integer type
  - In all lock modes (0, 1, and 2), the behavior of the auto-increment mechanism is undefined if the value becomes larger than the maximum integer that can be stored in the specified integer type.(在所有锁模式(0、1和2)中，如果值大于可以存储在指定整数类型中的最大整数，则自动递增机制的行为是未定义的。)

+ Gaps in auto-increment values for “bulk inserts”
  - With innodb_autoinc_lock_mode set to 0 (“traditional”) or 1 (“consecutive”), the auto-increment values generated by any given statement are consecutive, without gaps, because the table-level AUTO-INC lock is held until the end of the statement, and only one such statement can execute at a time.(当innodb_autoinc_lock_mode设置为0(“传统”)或1(“连续”)时，任何给定语句生成的自动增量值都是连续的，没有间隔，因为表级AUTO-INC锁一直保持到语句结束，并且一次只能执行一个这样的语句。)

  - With innodb_autoinc_lock_mode set to 2 (“interleaved”), there may be gaps in the auto-increment values generated by “bulk inserts,” but only if there are concurrently executing “INSERT-like” statements.(当innodb_autoinc_lock_mode设置为2(“interleaved”)时，“批量插入”生成的自动增量值可能会有间隙，但只有在并发执行“INSERT-like”语句时才会有间隙。)

  - For lock modes 1 or 2, gaps may occur between successive statements because for bulk inserts the exact number of auto-increment values required by each statement may not be known and overestimation is possible.(对于锁模式1或2，连续语句之间可能会出现间隙，因为对于批量插入，可能不知道每个语句所需的自动增量值的确切数量，并且可能会高估。)

+ Auto-increment values assigned by “mixed-mode inserts”
  - Consider a “mixed-mode insert,” where a “simple insert” specifies the auto-increment value for some (but not all) resulting rows. Such a statement behaves differently in lock modes 0, 1, and 2. For example, assume c1 is an AUTO_INCREMENT column of table t1, and that the most recent automatically generated sequence number is 100.(考虑“混合模式插入”，其中“简单插入”为一些(但不是全部)结果行指定自动增量值。这样的语句在锁模式0、1和2中的行为不同。例如，假设c1是表t1的AUTO_INCREMENT列，并且最近自动生成的序列号是100。)
     + With innodb_autoinc_lock_mode set to 0 (“traditional”), the four new rows are
       ```sql
             # Server version: 8.0.30-debug Source distribution
             # 当 With innodb_autoinc_lock_mode set to 0 (“traditional”), the four new rows are:  (删除原t1)
       
             mysql> create table t1(  c1 INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY ,  c2 CHAR(1)   ) ENGINE = INNODB,AUTO_INCREMENT=101;
             Query OK, 0 rows affected (0.09 sec)
       
             mysql> show variables like '%innodb_autoinc_lock_mode%'; # 修改修改my.cnf配置文件
             +--------------------------+-------+
             | Variable_name            | Value |
             +--------------------------+-------+
             | innodb_autoinc_lock_mode | 0     |
             +--------------------------+-------+
             1 row in set (0.04 sec)
             
             # Now, consider the following “mixed-mode insert” statement: (混合模式插入)
             mysql> INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
             Query OK, 4 rows affected (0.01 sec)
             Records: 4  Duplicates: 0  Warnings: 0
       
            mysql> select * from t1;
            +-----+------+
            | c1  | c2   |
            +-----+------+
            |   1 | a    |
            |   5 | c    |
            | 101 | b    |
            | 102 | d    |
            +-----+------+
            4 rows in set (0.00 sec)
       ```
       - The next available auto-increment value is 103 because the auto-increment values are allocated one at a time, not all at once at the beginning of statement execution. This result is true whether or not there are concurrently executing “INSERT-like” statements (of any type).(下一个可用的自动增量值是103，因为每次分配一个自动增量值，而不是在语句执行开始时一次分配所有的自动增量值。无论是否并发执行“INSERT-like”语句(任何类型)，这个结果都为真。)
         
     + With innodb_autoinc_lock_mode set to 1 (“consecutive”), the four new rows are also
       ```sql
           # Server version: 8.0.30-debug Source distribution
           当 With innodb_autoinc_lock_mode set to 1 (“consecutive”), the four new rows are also: (删除原t1)
           mysql> show variables like '%innodb_autoinc_lock_mode%';
           +--------------------------+-------+
           | Variable_name            | Value |
           +--------------------------+-------+
           | innodb_autoinc_lock_mode | 1     |
           +--------------------------+-------+
           1 row in set (0.03 sec)
           mysql> create table t1(  c1 INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY ,  c2 CHAR(1)   ) ENGINE = INNODB,AUTO_INCREMENT=101;
           Query OK, 0 rows affected (0.11 sec)
           
           mysql> INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
           Query OK, 4 rows affected (0.04 sec)
           Records: 4  Duplicates: 0  Warnings: 0
           
           mysql> select * from t1;
           +-----+------+
           | c1  | c2   |
           +-----+------+
           |   1 | a    |
           |   5 | c    |
           | 101 | b    |
           | 102 | d    |
           +-----+------+
           4 rows in set (0.01 sec)
           mysql> show create table t1;
           +-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
           | Table | Create Table                                                                                                                                                                                             |
           +-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
           | t1    | CREATE TABLE `t1` (
             `c1` int unsigned NOT NULL AUTO_INCREMENT,
             `c2` char(1) DEFAULT NULL,
             PRIMARY KEY (`c1`)
           ) ENGINE=InnoDB AUTO_INCREMENT=105 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |
           +-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
           1 row in set (0.01 sec)
           
           mysql> 
        ```
         - However, in this case, the next available auto-increment value is 105, not 103 because four auto-increment values are allocated at the time the statement is processed, but only two are used. This result is true whether or not there are concurrently executing “INSERT-like” statements (of any type).(然而，在本例中，下一个可用的自动增量值是105，而不是103，因为在处理语句时分配了四个自动增量值，但只使用了两个。无论是否并发执行“INSERT-like”语句(任何类型)，这个结果都为真。)

     + With innodb_autoinc_lock_mode set to 2 (“interleaved”), the four new rows are:
        ```sql
           # Server version: 8.0.30-debug Source distribution

           # With innodb_autoinc_lock_mode set to 2 (“interleaved”), the four new rows are: (删除原t1)
           mysql> show variables like '%innodb_autoinc_lock_mode%';
           +--------------------------+-------+
           | Variable_name            | Value |
           +--------------------------+-------+
           | innodb_autoinc_lock_mode | 2     |
           +--------------------------+-------+
           1 row in set (0.04 sec)
           
           mysql> create table t1(  c1 INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY ,  c2 CHAR(1)   ) ENGINE = INNODB,AUTO_INCREMENT=101;
           Query OK, 0 rows affected (0.09 sec)
           
           mysql> INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
           Query OK, 4 rows affected (0.04 sec)
           Records: 4  Duplicates: 0  Warnings: 0
           
           mysql> select * from t1;
           +-----+------+
           | c1  | c2   |
           +-----+------+
           |   1 | a    |
           |   5 | c    |
           | 101 | b    |
           | 102 | d    |
           +-----+------+
           4 rows in set (0.00 sec)
           
           mysql> show create table t1;
           +-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
           | Table | Create Table                                                                                                                                                                                             |
           +-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
           | t1    | CREATE TABLE `t1` (
             `c1` int unsigned NOT NULL AUTO_INCREMENT,
             `c2` char(1) DEFAULT NULL,
             PRIMARY KEY (`c1`)
           ) ENGINE=InnoDB AUTO_INCREMENT=105 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |
           +-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
           1 row in set (0.00 sec)
           
           mysql> 
        ```
       - The values of x and y are unique and larger than any previously generated rows. However, the specific values of x and y depend on the number of auto-increment values generated by concurrently executing statements.（x和y的值是唯一的，且大于之前生成的任何行。但是，x和y的具体值取决于并发执行语句生成的自动增量值的数量。）
    + Finally, consider the following statement, issued when the most-recently generated sequence number is 100:
      ```sql
         mysql> drop table t1;
         Query OK, 0 rows affected (0.07 sec)
         
         mysql> show variables like '%innodb_autoinc_lock_mode%';
         +--------------------------+-------+
         | Variable_name            | Value |
         +--------------------------+-------+
         | innodb_autoinc_lock_mode | 2     |
         +--------------------------+-------+
         1 row in set (0.03 sec)
         
         mysql> create table t1(  c1 INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY ,  c2 CHAR(1)   ) ENGINE = INNODB,AUTO_INCREMENT=101;
         Query OK, 0 rows affected (0.09 sec)
         
         mysql> INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (101,'c'), (NULL,'d');
         ERROR 1062 (23000): Duplicate entry '101' for key 't1.PRIMARY'
         mysql> 
      ```
        - With any innodb_autoinc_lock_mode setting, this statement generates a duplicate-key error 23000 (Can't write; duplicate key in table) because 101 is allocated for the row (NULL, 'b') and insertion of the row (101, 'c') fails.

+ Modifying AUTO_INCREMENT column values in the middle of a sequence of INSERT statements
  - In MySQL 5.7 and earlier, modifying an AUTO_INCREMENT column value in the middle of a sequence of INSERT statements could lead to “Duplicate entry” errors. For example, if you performed an UPDATE operation that changed an AUTO_INCREMENT column value to a value larger than the current maximum auto-increment value, subsequent INSERT operations that did not specify an unused auto-increment value could encounter “Duplicate entry” errors. In MySQL 8.0 and later, if you modify an AUTO_INCREMENT column value to a value larger than the current maximum auto-increment value, the new value is persisted, and subsequent INSERT operations allocate auto-increment values starting from the new, larger value. This behavior is demonstrated in the following example.(在MySQL 5.7及更早的版本中，在INSERT语句序列的中间修改AUTO_INCREMENT列值可能会导致“Duplicate entry”错误。例如，如果执行UPDATE操作，将AUTO_INCREMENT列值更改为大于当前最大自动增量值的值，则后续没有指定未使用的自动增量值的INSERT操作可能会遇到“重复条目”错误。在MySQL 8.0及更高版本中，如果您将AUTO_INCREMENT列值修改为大于当前最大自动增量值的值，则新值将被持久化，并且随后的INSERT操作从新的更大的值开始分配自动增量值。下面的示例演示了这种行为。) 即：在MySQL5.7修改自增列的值为大于当前最大自动增量值会导致错误，测试一下:
  
    + MySQL5.7 测试 - 报错
        ```sql
             测试MySQL5.7:
                Server version: 5.7.34-debug-log Source distribution
                
                mysql> drop table t1;
                Query OK, 0 rows affected (0.03 sec)
                mysql> CREATE TABLE t1 ( c1 INT NOT NULL AUTO_INCREMENT, PRIMARY KEY (c1) ) ENGINE = InnoDB;
                Query OK, 0 rows affected (0.04 sec)
                
                mysql> INSERT INTO t1 VALUES(0), (0), (3);
                Query OK, 3 rows affected (0.02 sec)
                Records: 3  Duplicates: 0  Warnings: 0
                
                mysql> select * from t1;
                +----+
                | c1 |
                +----+
                |  1 |
                |  2 |
                |  3 |
                +----+
                3 rows in set (0.00 sec)
                
                mysql> show create table t1;
                +-------+------------------------------------------------------------------------------------------------------------------------------------------+
                | Table | Create Table                                                                                                                             |
                +-------+------------------------------------------------------------------------------------------------------------------------------------------+
                | t1    | CREATE TABLE `t1` (
                  `c1` int(11) NOT NULL AUTO_INCREMENT,
                  PRIMARY KEY (`c1`)
                ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=latin1 |
                +-------+------------------------------------------------------------------------------------------------------------------------------------------+
                1 row in set (0.00 sec)
                
                mysql> UPDATE t1 SET c1 = 4 WHERE c1 = 1;
                Query OK, 1 row affected (0.00 sec)
                Rows matched: 1  Changed: 1  Warnings: 0
                
                mysql> INSERT INTO t1 VALUES(0);
                ERROR 1062 (23000): Duplicate entry '4' for key 'PRIMARY'
      ```

    + MySQL8.0 测试 - 支持操作
      ```sql
         # Server version: 8.0.30-debug Source distribution
         mysql> drop table t1;
         ERROR 1051 (42S02): Unknown table 'stu.t1'
         mysql> CREATE TABLE t1 ( c1 INT NOT NULL AUTO_INCREMENT, PRIMARY KEY (c1) ) ENGINE = InnoDB;
         Query OK, 0 rows affected (0.07 sec)
         
         mysql> INSERT INTO t1 VALUES(0), (0), (3);
         Query OK, 3 rows affected (0.02 sec)
         Records: 3  Duplicates: 0  Warnings: 0
         
         mysql> select * from t1;
         +----+
         | c1 |
         +----+
         |  1 |
         |  2 |
         |  3 |
         +----+
         3 rows in set (0.00 sec)
         
         mysql> show create table t1;
         +-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+
         | Table | Create Table                                                                                                                                                     |
         +-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+
         | t1    | CREATE TABLE `t1` (
           `c1` int NOT NULL AUTO_INCREMENT,
           PRIMARY KEY (`c1`)
         ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |
         +-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+
         1 row in set (0.00 sec)
         
         mysql> UPDATE t1 SET c1 = 4 WHERE c1 = 1;
         Query OK, 1 row affected (0.02 sec)
         Rows matched: 1  Changed: 1  Warnings: 0
         
         mysql> INSERT INTO t1 VALUES(0);
         Query OK, 1 row affected (0.03 sec)
         
         mysql> select * from t1;
         +----+
         | c1 |
         +----+
         |  2 |
         |  3 |
         |  4 |
         |  5 |
         +----+
         4 rows in set (0.01 sec)
         
         mysql> show create table t1;
         +-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+
         | Table | Create Table                                                                                                                                                     |
         +-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+
         | t1    | CREATE TABLE `t1` (
           `c1` int NOT NULL AUTO_INCREMENT,
           PRIMARY KEY (`c1`)
         ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |
         +-------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+
         1 row in set (0.00 sec)
         
         mysql> 
      ```



&nbsp;&nbsp;

## 参考资料
1. [17.6.1.6 AUTO_INCREMENT Handling in InnoDB](https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html)