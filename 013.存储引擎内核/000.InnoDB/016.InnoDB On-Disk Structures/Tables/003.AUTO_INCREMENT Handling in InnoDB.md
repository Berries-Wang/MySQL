# AUTO_INCREMENT Handling in InnoDB
## 摘要
1. 影响备份（主从复制）

## 资料
&nbsp;&nbsp;InnoDB provides a configurable locking mechanism that can significantly improve scalability and performance of SQL statements that add rows to tables with AUTO_INCREMENT columns. To use the AUTO_INCREMENT mechanism with an InnoDB table, an AUTO_INCREMENT column must be defined as the first or only column of some index such that it is possible to perform the equivalent of an indexed SELECT MAX(ai_col) lookup on the table to obtain the maximum column value. The index is not required to be a PRIMARY KEY or UNIQUE, but to avoid duplicate values in the AUTO_INCREMENT column, those index types are recommended.(InnoDB提供了一种可配置的锁机制，可以显著提高SQL语句在AUTO_INCREMENT列的表中添加行的可伸缩性和性能。要在InnoDB表中使用AUTO_INCREMENT机制，必须将AUTO_INCREMENT列定义为某个索引的第一列或唯一列，以便可以在表上执行相当于索引SELECT MAX(ai_col)查找以获得最大列值。索引不需要是PRIMARY KEY或UNIQUE，但为了避免AUTO_INCREMENT列中的重复值，建议使用这些索引类型。)
```txt
     > Server version: 5.7.34-debug-log Source distribution
     
     mysql> create table auto_inc( id bigint primary key ,  id_a bigint auto_increment);
     ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key
     
     mysql> create table auto_inc( id bigint primary key ,  id_a bigint auto_increment, index aa(id_a) );
     Query OK, 0 rows affected (0.04 sec)
     
     mysql> insert into auto_inc(id,id_a) values(1,1);
     Query OK, 1 row affected (0.02 sec)
     
     mysql> insert into auto_inc(id,id_a) values(2,1);
     Query OK, 1 row affected (0.01 sec)
     
     mysql> insert into auto_inc(id,id_a) values(2,1);
     ERROR 1062 (23000): Duplicate entry '2' for key 'PRIMARY'
     mysql> insert into auto_inc(id) values(3);
     Query OK, 1 row affected (0.02 sec)
     
     mysql> select * from auto_inc;
     +----+------+
     | id | id_a |
     +----+------+
     |  1 |    1 |
     |  2 |    1 |
     |  3 |    2 |
     +----+------+
     3 rows in set (0.00 sec)
     
     mysql>

      # 值不允许重复吗? 经过测试，是可以的
```

### InnoDB AUTO_INCREMENT Lock Modes
&nbsp;&nbsp;This section describes the AUTO_INCREMENT lock modes used to generate auto-increment values, and how each lock mode affects replication. The auto-increment lock mode is configured at startup using the innodb_autoinc_lock_mode variable.(本节描述用于生成自动递增值的AUTO_INCREMENT锁模式，以及每种锁模式如何影响复制。自增锁模式在启动时使用innodb_autoinc_lock_mode变量进行配置。)

#### The following terms<sup>术语；措辞；</sup> are used in describing innodb_autoinc_lock_mode settings:

1.  “INSERT-like” statements
    - All statements that generate new rows in a table, including INSERT, INSERT ... SELECT, REPLACE, REPLACE ... SELECT, and LOAD DATA. Includes “simple-inserts”, “bulk-inserts”, and “mixed-mode” inserts.

2. “Simple inserts”
    - Statements for which the number of rows to be inserted can be determined in advance<sup>预先的</sup> (when the statement is initially processed). This includes single-row and multiple-row INSERT and REPLACE statements that do not have a nested(嵌套的) subquery, but not INSERT ... ON DUPLICATE KEY UPDATE.

3. “Bulk inserts”
    - Statements for which the number of rows to be inserted (and the number of required auto-increment values) is not known in advance. This includes INSERT ... SELECT, REPLACE ... SELECT, and LOAD DATA statements, but not plain INSERT. InnoDB assigns new values for the AUTO_INCREMENT column one at a time as each row is processed.

4. “Mixed-mode inserts”
    - These are “simple insert” statements that specify the auto-increment value for some (but not all) of the new rows. An example follows, where c1 is an AUTO_INCREMENT column of table t1:
      ```sql
            INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
      ```

    - Another type of “mixed-mode insert” is INSERT ...  ON DUPLICATE KEY UPDATE, which in the worst case is in effect an INSERT followed by a UPDATE, where the allocated value for the AUTO_INCREMENT column may or may not be used during the update phase.（另外一种"mixed-mode insert"是 INSERT ...  ON DUPLICATE KEY UPDATE,在最坏的情况下，实际上是先插入，然后再更新，其中为AUTO_INCREMENT列分配的值可能在更新阶段使用，也可能不使用）

&nbsp;&nbsp;There are three possible settings for the innodb_autoinc_lock_mode variable. The settings are 0, 1, or 2, for “traditional”, “consecutive”, or “interleaved” lock mode, respectively. As of MySQL 8.0, interleaved lock mode (innodb_autoinc_lock_mode=2) is the default setting. Prior to MySQL 8.0, consecutive lock mode is the default (innodb_autoinc_lock_mode=1).(innodb_autoinc_lock_mode变量有三种可能的设置。“传统”、“连续”或“交错”锁模式的设置分别为0、1或2。在MySQL 8.0中，交错锁模式(innodb_autoinc_lock_mode=2)是默认设置。在MySQL 8.0之前，默认是连续锁模式(innodb_autoinc_lock_mode=1)。)
```txt
  三种锁模式的体现是怎么样的?
    “traditional”:
    “consecutive”:
    “interleaved”: 
```

&nbsp;&nbsp;The default setting of interleaved lock mode in MySQL 8.0 reflects the change from statement-based replication to row based replication as the default replication type. Statement-based replication requires the consecutive auto-increment lock mode to ensure that auto-increment values are assigned in a predictable and repeatable order for a given sequence of SQL statements, whereas row-based replication is not sensitive to the execution order of SQL statements.(MySQL8.0默认的 interleaved lock mode 配置反映出了赋值类型由statement-based replication修改为了row based replication，基于语句的复制需要连续的自动递增锁模式，以确保自动递增的值以可预测和可重复的顺序为给定的SQL语句序列分配，而基于行的复制对SQL语句的执行顺序不敏感。)
+ innodb_autoinc_lock_mode = 0 (“traditional” lock mode)
  - The traditional lock mode provides the same behavior that existed before the innodb_autoinc_lock_mode variable was introduced. The traditional lock mode option is provided for backward compatibility, performance testing, and working around issues with “mixed-mode inserts”, due to possible differences in semantics.（传统的锁模式提供了与引入innodb_autoinc_lock_mode变量之前相同的行为。提供传统的锁模式选项是为了向后兼容、性能测试和解决“混合模式插入”的问题，因为可能存在语义上的差异。）
  - In this lock mode, all “INSERT-like” statements obtain a special table-level AUTO-INC lock for inserts into tables with AUTO_INCREMENT columns.  This lock is normally held to the end of the statement (not to the end of the transaction) to ensure that auto-increment values are assigned in a predictable and repeatable order for a given sequence of INSERT statements, and to ensure that auto-increment values assigned by any given statement are consecutive.（在这种锁模式下，所有“INSERT-like”语句都获得一个特殊的表级AUTO-INC锁，用于向具有AUTO_INCREMENT列的表中插入数据。该锁通常保持到语句的末尾(而不是事务的末尾)，以确保对给定的INSERT语句序列按可预测和可重复的顺序分配自动递增值，并确保任何给定语句分配的自动递增值是连续的。）
  - In the case of statement-based replication, this means that when an SQL statement is replicated on a replica server, the same values are used for the auto-increment column as on the source server.  The result of execution of multiple INSERT statements is deterministic, and the replica reproduces the same data as on the source.  If auto-increment values generated by multiple INSERT statements were interleaved, the result of two concurrent INSERT statements would be nondeterministic, and could not reliably be propagated to a replica server using statement-based replication.（对于基于语句的复制，这意味着在复制服务器上复制SQL语句时，自动递增列的值与源服务器上的值相同。执行多个INSERT语句的结果是确定的，副本复制的数据与源数据相同。如果多个INSERT语句生成的自动递增值是交错的，则两个并发INSERT语句的结果将是不确定的，并且不能使用基于语句的复制可靠地传播到副本服务器。）
  - To make this clear, consider an example that uses this table:
    ```sql
       CREATE TABLE t1 (
         c1 INT(11) NOT NULL AUTO_INCREMENT,
         c2 VARCHAR(10) DEFAULT NULL,
         PRIMARY KEY (c1)
       ) ENGINE=InnoDB;
    ```
    - Suppose that there are two transactions running, each inserting rows into a table with an AUTO_INCREMENT column. One transaction is using an INSERT ... SELECT statement that inserts 1000 rows, and another is using a simple INSERT statement that inserts one row:（假设有两个事务正在运行，每个事务都将行插入到带有AUTO_INCREMENT列的表中。一个事务正在使用INSERT…SELECT语句插入1000行，另一个使用简单的INSERT语句插入一行:）
      ```sql
         Tx1: INSERT INTO t1 (c2) SELECT 1000 rows from another table ...
         Tx2: INSERT INTO t1 (c2) VALUES ('xxx');
      ```
    - InnoDB cannot tell in advance how many rows are retrieved from the SELECT in the INSERT statement in Tx1, and it assigns the auto-increment values one at a time as the statement proceeds.  With a table-level lock, held to the end of the statement, only one INSERT statement referring to table t1 can execute at a time, and the generation of auto-increment numbers by different statements is not interleaved.  The auto-increment values generated by the Tx1 INSERT ...  SELECT statement are consecutive, and the (single) auto-increment value used by the INSERT statement in Tx2 is either smaller or larger than all those used for Tx1, depending on which statement executes first.(InnoDB无法预先告诉Tx1中的INSERT语句从SELECT中检索了多少行，并且它会在语句执行过程中每次分配一个自动递增值。使用表级锁(一直保持到语句末尾)，一次只能执行一条引用表t1的INSERT语句，并且不同语句生成的自动递增编号不会交叉。由Tx1插入生成的自动递增值…SELECT语句是连续的，并且Tx2中INSERT语句使用的(单个)自动递增值比Tx1中使用的所有自动递增值都小或大，这取决于首先执行哪条语句。)
    - As long as the SQL statements execute in the same order when replayed from the binary log (when using statement-based replication, or in recovery scenarios), the results are the same as they were when Tx1 and Tx2 first ran.  Thus, table-level locks held until the end of a statement make INSERT statements using auto-increment safe for use with statement-based replication.  However, those table-level locks limit concurrency and scalability when multiple transactions are executing insert statements at the same time.（只要SQL语句在二进制日志中以相同的顺序执行(在使用基于语句的复制时，或在恢复场景中)，结果就与Tx1和Tx2第一次运行时相同。因此，表级别的锁一直保持到语句结束，使得使用自动递增的INSERT语句可以安全地与基于语句的复制一起使用。然而，当多个事务同时执行insert语句时，这些表级锁限制了并发性和可伸缩性。）
      > 所以，多表关联不能通过这种自增的列。
    - In the preceding example, if there were no table-level lock, the value of the auto-increment column used for the INSERT in Tx2 depends on precisely when the statement executes.  If the INSERT of Tx2 executes while the INSERT of Tx1 is running (rather than before it starts or after it completes), the specific auto-increment values assigned by the two INSERT statements are nondeterministic, and may vary from run to run.()
    - In the preceding example, if there were no table-level lock, the value of the auto-increment column used for the INSERT in Tx2 depends on precisely when the statement executes.  If the INSERT of Tx2 executes while the INSERT of Tx1 is running (rather than before it starts or after it completes), the specific auto-increment values assigned by the two INSERT statements are nondeterministic, and may vary from run to run.（在前面的示例中，如果没有表级锁，那么Tx2中用于插入的自动递增列的值完全取决于语句执行的时间。如果Tx2的插入是在Tx1的插入运行时执行的(而不是在它开始之前或完成之后)，那么两个INSERT语句分配的特定的自动递增值是不确定的，并且可能在不同的运行中有所不同。）
    - Under the consecutive lock mode, InnoDB can avoid using table-level AUTO-INC locks for “simple insert” statements where the number of rows is known in advance, and still preserve<sup>保护，维护</sup> deterministic execution and safety for statement-based replication.(在连续锁模式下，InnoDB可以避免使用表级的AUTO-INC锁来处理预先知道行数的简单insert语句，并保持执行的确定性和基于语句的复制的安全性。)
    - If you are not using the binary log to replay SQL statements as part of recovery or replication, the interleaved lock mode can be used to eliminate all use of table-level AUTO-INC locks for even greater concurrency and performance, at the cost of permitting gaps in auto-increment numbers assigned by a statement and potentially having the numbers assigned by concurrently executing statements interleaved.(如果你不使用二进制日志来重放SQL语句作为恢复或复制的一部分，那么交错锁模式可以用来消除所有表级的AUTO-INC锁，以获得更大的并发性和性能，但代价是允许语句分配的自动递增编号之间有间隙，并且可能通过交错并发执行语句分配编号。)

+ innodb_autoinc_lock_mode = 1 (“consecutive” lock mode)
   - In this mode, “bulk inserts” use the special AUTO-INC table-level lock and hold it until the end of the statement. This applies to all INSERT ... SELECT, REPLACE ... SELECT, and LOAD DATA statements. Only one statement holding the AUTO-INC lock can execute at a time. If the source table of the bulk insert operation is different from the target table, the AUTO-INC lock on the target table is taken after a shared lock is taken on the first row selected from the source table. If the source and target of the bulk insert operation are the same table, the AUTO-INC lock is taken after shared locks are taken on all selected rows.(在这种模式下，“bulk inserts” 使用特殊的AUTO-INC表级锁并保持它直到语句结束。这适用于所有INSERT ... SELECT，REPLACE ... SELECT和LOAD DATA语句。一次只能执行一条持有AUTO-INC锁的语句。如果大容量插入操作的源表与目标表不同，则在对源表中选择的第一行执行共享锁之后，对目标表执行AUTO-INC锁。如果大容量插入操作的源表和目标表是同一个表，则在对所有选定的行使用共享锁之后使用AUTO-INC锁。)

   - “Simple inserts” (for which the number of rows to be inserted is known in advance) avoid table-level AUTO-INC locks by obtaining the required number of auto-increment values under the control of a mutex (a light-weight lock) that is only held for the duration of the allocation process, not until the statement completes<sup>not until 涉及语法，即：语句完成是非延续性的，即是一瞬间的，所以需要加上not,表示延续：即没有完成，</sup>. No table-level AUTO-INC lock is used unless an AUTO-INC lock is held by another transaction. If another transaction holds an AUTO-INC lock, a “simple insert” waits for the AUTO-INC lock, as if it were a “bulk insert”.(“简单插入”(要插入的行数是事先已知的)通过在互斥锁(轻量级锁)的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁，互斥锁只在分配过程期间持有，直到语句完成。除非AUTO-INC锁被另一个事务持有，否则不会使用表级AUTO-INC锁。如果另一个事务持有AUTO-INC锁，则“简单插入”等待AUTO-INC锁，就像它是“批量插入”一样。)

   - This lock mode ensures that, in the presence of INSERT statements where the number of rows is not known in advance (and where auto-increment numbers are assigned as the statement progresses), all auto-increment values assigned by any “INSERT-like” statement are consecutive, and operations are safe for statement-based replication.(这种锁模式确保，在存在事先不知道行数的INSERT语句时(并且在语句进行时分配自动增量数)，任何“INSERT-like”语句分配的所有自动增量值都是连续的，并且操作对于基于语句的复制是安全的。)

   - Simply put, this lock mode significantly improves scalability while being safe for use with statement-based replication. Further, as with “traditional” lock mode, auto-increment numbers assigned by any given statement are consecutive. There is no change in semantics compared to “traditional” mode for any statement that uses auto-increment, with one important exception.(简单地说，这种锁模式大大提高了可伸缩性，同时对于基于语句的复制来说是安全的。此外，与“传统”锁模式一样，任何给定语句分配的自动递增数是连续的。对于任何使用自动递增的语句，与“传统”模式相比，在语义上没有变化，但有一个重要的例外。)

   - The exception is for “mixed-mode inserts”, where the user provides explicit values for an AUTO_INCREMENT column for some, but not all, rows in a multiple-row “simple insert”. For such inserts, InnoDB allocates more auto-increment values than the number of rows to be inserted. However, all values automatically assigned are consecutively generated (and thus higher than) the auto-increment value generated by the most recently executed previous statement. “Excess” numbers are lost.(例外是“混合模式插入”，其中用户为多行“简单插入”中的一些(但不是全部)行提供AUTO_INCREMENT列的显式值。对于这样的插入，InnoDB分配的自动增量值比要插入的行数要多。但是，所有自动分配的值都是连续生成的(因此高于)最近执行的前一个语句生成的自动增量值。“多余”的数字丢失了。)



&nbsp;&nbsp;

## 参考资料
1. [17.6.1.6 AUTO_INCREMENT Handling in InnoDB](https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html)