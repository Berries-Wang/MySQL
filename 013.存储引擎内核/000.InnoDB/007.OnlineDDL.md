- [Online DDL](#online-ddl)
  - [值解析](#值解析)
  - [14.13 InnoDB and Online DDL](#1413-innodb-and-online-ddl)
    - [14.13.1 Online DDL Operations](#14131-online-ddl-operations)
    - [14.13.2 Online DDL Performance and Concurrency](#14132-online-ddl-performance-and-concurrency)
      - [The LOCK clause(从句，分句；)](#the-lock-clause从句分句)
        - [LOCK=NONE](#locknone)
        - [LOCK=SHARED](#lockshared)
        - [LOCK=DEFAULT](#lockdefault)
        - [LOCK=EXCLUSIVE](#lockexclusive)
      - [Online DDL and Metadata Locks](#online-ddl-and-metadata-locks)
        - [Phase 1: Initialization](#phase-1-initialization)
        - [Phase 2: Execution](#phase-2-execution)
        - [Phase 3: Commit Table Definition](#phase-3-commit-table-definition)
      - [Online DDL Performance](#online-ddl-performance)
    - [14.13.3 Online DDL Space Requirements（空间需求）](#14133-online-ddl-space-requirements空间需求)
      - [1. Temporary log files:](#1-temporary-log-files)
      - [2. Temporary sort files:](#2-temporary-sort-files)
      - [3. Intermediate(中间) table files:](#3-intermediate中间-table-files)
  - [参考资料](#参考资料)

# Online DDL
&nbsp;&nbsp;MySQL5.6允许辅助索引创建的同时，还允许其他 INSERT,UPDATE,DELETE这类DML操作，这极大提高了MySQL在生产环境的可用性。

&nbsp;&nbsp;不仅仅是辅助索引，如下几类DDL操作都可以通过在线的方式进行操作:
1. 辅助索引的创建和删除
2. 改变自增长值
3. 添加或者删除外检约束
4. 列的重命名
5. ....更多操作，而非仅此而已(参考官方文档)


## 值解析
```txt
    ALTER TABLE tbl_name MODIFY COLUMN column_name data_type NULL, ALGORITHM=INPLACE, LOCK=NONE;

    # ALGORITHM 可选：
    ## | COPY |表示按照MySQL5.1版本之前的工作模式，即创建临时表的方式|
    ## | INPLACE |表示索引创建或删除不需要创建临时表|
    ## | DEFAULT |表示根据参数old_alter_table来判断是通过INPLACE 还是 COPY 的算法，该参数默认值为OFF,即采用INPLACE算法|

    # LOCK 可选
    ## |NONE| 不加任何锁 |
    ## |SHARE|对目标表加上S锁|
    ## |EXCLUSIVE|对目标表添加X锁|
    ## |DEFAULT|会通过判断事务的最大并发性来判断执行DDL的模式,选择的顺序: NONE - > SHARE -> EXCLUSIVE,判断当前操作是否可以使用该模式。若可以，则是用该模式；反之，判断下一个|


    # Oneline DDL 工作方式
    ## InnoDB存储引擎实现Online DDL的原理是在执行创建或删除操作的同时，将INSERT,UPDATE,DELETE这类DML操作日志写入到一个缓存中。待完成索引的创建后再将重做引用到表上，以此达到数据的一致性。
    ## 该缓存大小由innodb_online_alter_log_max_size 控制，默认值为128MB。如果日志超过这个阈值，则会报错。

    # 需要考虑的问题
    ## 1. 磁盘空间的考虑: 当onlineDDL使用创建临时表的方式处理时
       ALTER TABLE tbl_name CHANGE c1 c1 BIGINT, ALGORITHM=COPY; (修改字段类型ALGORITHM只能是COPY)
    这条OnlineDDL,已创建临时表的方式修改列类型，那么在执行这条SQL时需要保证数据库有足够的磁盘空间。
```

---

## [14.13 InnoDB and Online DDL](https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl.html)
&nbsp;&nbsp;Online DDL操作
### [14.13.1 Online DDL Operations](https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-operations.html)
&nbsp;&nbsp;该文档说明了Online DDL支持的操作类型,以及具体算法.

### [14.13.2 Online DDL Performance and Concurrency](https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-performance.html)
&nbsp;&nbsp;Online DDL improves(改善) several aspects of MySQL operation:
> Online DDL 改善了MySQL操作的几个方面:

+ Applications that access the table are more responsive(adj.反应迅速的，积极反应的；反应热烈的，热情的；回应的，回答的；) because queries and DML operations on the table can proceed(v.开始行动，开展；) while the DDL operation is in progress. Reduced locking and waiting for MySQL server resources leads to greater scalability(n.可扩展性；可伸缩性；可量测性), even for operations that are not involved(adj.复杂的;v.牵涉，包含) in the DDL operation.
> 在DDL操作执行的时候，允许查询和DML操作执行，减少锁表和等待以获取更好地性能。即使是DDL操作中没有涉及的操作

+ In-place operations avoid the disk I/O and CPU cycles associated with the table-copy method, which minimizes(把……减至最低数量) overall(总的;全面的;) load on the database. Minimizing load helps maintain(v.保持，维持；维修，保养；断言) good performance and high throughput(n.（某一时期内的）生产量，接待人数，吞吐量) during the DDL operation.
> 与表复制方法相比，In-place 操作节省了I/O和CPU周期，将数据库总的负载减到最小。降低负载有助于保持数据库的高性能和高吞吐率。

+ In-place operations read less data into the buffer pool than the table-copy operations, which reduces purging of frequently accessed data from memory. Purging of frequently accessed data can cause a temporary performance dip(下降;下沉;降低;) after a DDL operation.
> 相比于表复制的方式，In-place 操作读取少量的数据到buffer pool，它减少了从内存中清除频繁访问的数据。在DDL操作后清理频繁访问的数据会临时降低性能。

####  The LOCK clause(从句，分句；)
&nbsp;&nbsp;By default, MySQL uses as little locking as possible during a DDL operation. The LOCK clause can be specified to enforce(v.实施;执行;强迫;) more restrictive(adj.限制的;约束的;) locking, if required. If the LOCK clause specifies a less restrictive level of locking than is permitted(v.允许;批准) for a particular(adj.特定的;格外的;n.一点;一个细节;详情;详细资料) DDL operation, the statement fails with an error. LOCK clauses are described below, in order of least to most restrictive:
> 默认情况下，在DDL执行期间，尽可能使用少的锁。如果需要，可以指定LOCK子句来强制更严格的锁定。如果LOCK子句指定的锁级别低于特定DDL操作锁允许的锁级别，则语句将失败并出错。下面描述了LOCK子句，从最少到最严格的顺序

>> 一些DDL操作，只能使用其中一个级别.

##### LOCK=NONE
&nbsp;&nbsp;Permits concurrent queries and DML.
> 允许并发的查询和DML

&nbsp;&nbsp;For example, use this clause for tables involving(v.涉及;包括;) customer signups(n.注册（signup 的复数）) or purchases, to avoid making the tables unavailable during lengthy(漫长的;长时间的;) DDL operations.
> 例如，对于涉及客户注册或购买的表使用此子句，以避免在漫长的的DDL操作期间使表不可用。

##### LOCK=SHARED
&nbsp;&nbsp;Permits concurrent queries but blocks DML.
> 允许并发查询但阻塞DML操作

&nbsp;&nbsp;For example, use this clause on data warehouse tables, where you can delay data load operations until the DDL operation is finished, but queries cannot be delayed for long periods(n.周期).
> 例如，在数据仓库表上使用这个子句，可以延迟数据加载操作，直到DDL操作完成，但是查询不能长时间延迟

##### LOCK=DEFAULT
&nbsp;&nbsp;Permits as much concurrency(并发性;同时发生;) as possible (concurrent queries, DML, or both). Omitting(省略) the LOCK clause is the same as specifying LOCK=DEFAULT.
> 允许尽可能多的并发(并发查询或DML或全部)。省略LOCK子句和指定LOCK=DEFAULT一样.

&nbsp;&nbsp;Use this clause when you know that the default locking level of the DDL statement does not cause availability(n.可用性，可得性) problems for the table.
> 当你知晓DDL语句默认的锁级别不会造成该表可用性问题的时候使用该子句。

##### LOCK=EXCLUSIVE
&nbsp;&nbsp;Blocks concurrent queries and DML.
> 阻塞并发查询和DML

&nbsp;&nbsp;Use this clause if the primary concern is finishing the DDL operation in the shortest amount of time possible, and concurrent query and DML access is not necessary. You might also use this clause if the server is supposed to be idle, to avoid unexpected table accesses.
> 如果主要关注的是在尽可能短的时间内完成DDL操作，而并发查询和DML访问不是必需的，则使用此子句。如果服务器应该是空闲的，也可以使用这个子句，以避免意外的表访问。

---
#### Online DDL and Metadata Locks
&nbsp;&nbsp;Online DDL operations can be viewed as having three phases:
> DDL操作可以被看作为有三个阶段:

##### Phase 1: Initialization
&nbsp;&nbsp;In the initialization phase, the server determines how much concurrency is permitted during the operation, taking into account storage engine capabilities, operations specified in the statement, and user-specified ALGORITHM and LOCK options. During this phase, a shared upgradeable metadata lock is taken to protect the current table definition.
> 在初始化阶段，服务器将考虑存储引擎能力、语句中指定的操作以及用户指定的ALGORITHM和LOCK选项，确定操作期间允许多少并发。在此阶段，使用一个共享的可升级元数据锁来保护当前表定义。

##### Phase 2: Execution
&nbsp;&nbsp;In this phase, the statement is prepared and executed. Whether the metadata lock is upgraded to exclusive depends on the factors assessed in the initialization phase. If an exclusive metadata lock is required, it is only taken briefly during statement preparation.
> 在此阶段，准备并执行语句。元数据锁是否升级为排他锁取决于初始化阶段评估的因素。如果需要一个排他元数据锁，它只会在语句准备期间短暂使用。

##### Phase 3: Commit Table Definition
&nbsp;&nbsp;In the commit table definition phase, the metadata lock is upgraded to exclusive to evict the old table definition and commit the new one. Once granted, the duration of the exclusive metadata lock is brief.
> 在提交表定义阶段，元数据锁升级为排他锁，以退出旧的表定义并提交新表定义。一旦授予，独占元数据锁的持续时间很短。

&nbsp;&nbsp;Due to the exclusive metadata lock requirements outlined above, an online DDL operation may have to wait for concurrent transactions that hold metadata locks on the table to commit or rollback. Transactions started before or during the DDL operation can hold metadata locks on the table being altered. In the case of a long running or inactive transaction, an online DDL operation can time out waiting for an exclusive metadata lock. Additionally, a pending exclusive metadata lock requested by an online DDL operation blocks subsequent transactions on the table.
> 由于上面概述的排他元数据锁需求，Online DDL操作可能必须等待持有表上元数据锁的并发事务提交或回滚。在DDL操作之前或期间开始的事务可以持有被更改表上的元数据锁。对于长时间运行或不活动的事务，Online DDL操作在等待独占元数据锁时可能会超时。此外，Online DDL操作请求的挂起的排他性元数据锁会阻塞表上的后续事务。

&nbsp;&nbsp;The following example demonstrates an online DDL operation waiting for an exclusive metadata lock, and how a pending metadata lock blocks subsequent transactions on the table.
> 下面的示例演示了一个等待独占元数据锁的在线DDL操作，以及挂起的元数据锁如何阻塞表上的后续事务。(使用自编译MySQL测试)

```txt
   Session 1:
     mysql> CREATE TABLE t1 (c1 INT) ENGINE=InnoDB;
     mysql> START TRANSACTION;
     mysql> SELECT * FROM t1;
   
   The session 1 SELECT statement takes a shared metadata lock on table t1.

   Session 2:(被阻塞)
     mysql> ALTER TABLE t1 ADD COLUMN x INT, ALGORITHM=INPLACE, LOCK=NONE;
   
   The online DDL operation in session 2, which requires an exclusive metadata lock on table t1 to commit table definition changes, must wait for the session 1 transaction to commit or roll back.
   > 会话2中的在线DDL操作需要表t1上的独占元数据锁来提交表定义更改，它必须等待会话1事务提交或回滚。
   >> 经过测试，Session 2会一直被阻塞.

   Session 3: (被阻塞)
     mysql> SELECT * FROM t1;

   The SELECT statement issued in session 3 is blocked waiting for the exclusive metadata lock requested by the ALTER TABLE operation in session 2 to be granted.
   > 会话3中发出的SELECT语句阻塞，等待会话2中ALTER TABLE操作请求的独占元数据锁被授予。

   You can use SHOW FULL PROCESSLIST to determine if transactions are waiting for a metadata lock.  
   > 您可以使用SHOW FULL PROCESSLIST来确定事务是否在等待元数据锁。
   mysql> SHOW FULL PROCESSLIST \G
   *************************** 1. row ***************************
        Id: 3
      User: root
      Host: localhost
        db: stu
   Command: Sleep
      Time: 267
     State: 
      Info: NULL
   *************************** 2. row ***************************
        Id: 4
      User: root
      Host: localhost
        db: stu
   Command: Query
      Time: 241
     State: Waiting for table metadata lock
      Info: ALTER TABLE t1 ADD COLUMN x INT, ALGORITHM=INPLACE, LOCK=NONE
   *************************** 3. row ***************************
        Id: 5
      User: root
      Host: localhost
        db: stu
   Command: Query
      Time: 61
     State: Waiting for table metadata lock
      Info: SELECT * FROM t1
   *************************** 4. row ***************************
        Id: 6
      User: root
      Host: localhost
        db: NULL
   Command: Query
      Time: 0
     State: starting
      Info: SHOW FULL PROCESSLIST
   4 rows in set (0.00 sec)
   
   mysql> 
  
   Metadata lock information is also exposed through the Performance Schema metadata_locks table, which provides information about metadata lock dependencies between sessions, the metadata lock a session is waiting for, and the session that currently holds the metadata lock. For more information, see Section 25.12.12.1, “The metadata_locks Table”.
   > 元数据锁信息还通过Performance Schema metadata_locks表公开，该表提供了关于会话之间的元数据锁依赖关系、会话正在等待的元数据锁以及当前持有元数据锁的会话的信息。有关更多信息，请参见第25.12.12.1节，“metadata_locks表”。
```

---

#### Online DDL Performance
&nbsp;&nbsp;The performance of a DDL operation is largely determined by whether the operation is performed(v.执行，表演（perform 的过去式和过去分词）) in place and whether it rebuilds the table.
> DDL操作的性能在很大程度上取决于该操作是否在适当的位置执行以及它是否重新构建表。

&nbsp;&nbsp;To assess(v.评价，评定；估价，估计) the relative performance of a DDL operation, you can compare results using ALGORITHM=INPLACE with results using ALGORITHM=COPY. Alternatively(adv.要不，或者), you can compare results with old_alter_table disabled and enabled.
> 要评估DDL操作的相对性能，可以比较使用ALGORITHM=INPLACE和ALGORITHM=COPY的结果。或者，您可以比较old_alter_table禁用和启用的结果。

&nbsp;&nbsp;For DDL operations that modify table data, you can determine whether a DDL operation performs changes in place or performs a table copy by looking at the “rows affected” value displayed after the command finishes. For example:
> 对于修改表数据的DDL操作，可以通过查看命令完成后显示的“受影响的行”值来确定DDL操作是就地执行更改还是执行表复制。例如:

+ Changing the default value of a column (fast, does not affect the table data):
  - Query OK, 0 rows affected (0.07 sec)
+ Adding an index (takes time, but 0 rows affected shows that the table is not copied):
  - Query OK, 0 rows affected (21.42 sec)
+ Changing the data type of a column (takes substantial(adj.大量的;) time and requires rebuilding all the rows of the table):
  - Query OK, 1671168 rows affected (1 min 35.54 sec)


&nbsp;&nbsp;Before running a DDL operation on a large table, check whether the operation is fast or slow as follows:
> 在大表上执行DDL操作前，按照如下步骤判断一下操作是快是慢:

1. Clone the table structure.
2. Populate the cloned table with a small amount of data.
3. Run the DDL operation on the cloned table.
4. Check whether the “rows affected” value is zero or not. A nonzero value means the operation copies table data, which might require special planning. For example, you might do the DDL operation during a period of scheduled downtime, or on each replica server one at a time.

&nbsp;&nbsp;Because there is some processing work involved with recording the changes made by concurrent DML operations, then applying those changes at the end, an online DDL operation could take longer overall than the table-copy mechanism that blocks table access from other sessions. The reduction in raw performance is balanced against better responsiveness for applications that use the table. When evaluating the techniques for changing table structure, consider end-user perception of performance, based on factors such as load times for web pages.
> 由于需要记录并发DML操作所做的更改，然后在最后应用这些更改，因此在线DDL操作所花费的时间可能比表复制机制(它会阻止其他会话对表的访问)要长。原始性能的降低与使用该表的应用程序更好的响应性是平衡的。在评估更改表结构的技术时，要根据网页的加载时间等因素考虑终端用户对性能的感知。

---

### [14.13.3 Online DDL Space Requirements（空间需求）](https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-space-requirements.html)
&nbsp;&nbsp;Online DDL operations have the following space requirements:
> Online DDL有如下的空间需求:

#### 1. Temporary log files:
&nbsp;&nbsp;A temporary log file records concurrent DML when an online DDL operation creates an index or alters a table. The temporary log file is extended as required by the value of innodb_sort_buffer_size up to a maximum specified by innodb_online_alter_log_max_size. If the operation takes a long time and concurrent DML modifies the table so much that the size of the temporary log file exceeds the value of innodb_online_alter_log_max_size, the online DDL operation fails with a DB_ONLINE_LOG_TOO_BIG error and uncommitted concurrent DML operations are rolled back. A large innodb_online_alter_log_max_size setting permits more DML during an online DDL operation, but it also extends the period of time at the end of the DDL operation when the table is locked to apply logged DML.
> 当在线DDL操作创建索引或修改表时，临时日志文件记录并发的DML。临时日志根据innodb_sort_buffer_size的值扩展到innodb_online_alter_log_max_size的最大值。如果操作耗时较长，并发DML修改表的时间太长，导致临时日志文件的大小超过innodb_online_alter_log_max_size，则在线DDL操作会失败，会出现DB_ONLINE_LOG_TOO_BIG错误，并回滚未提交的并发DML操作。一个大的innodb_online_alter_log_max_size设置允许在在线DDL操作期间使用更多的DML，但是它也延长了DDL操作结束时表被锁定以应用日志DML的时间。

&nbsp;&nbsp;The innodb_sort_buffer_size variable also defines the size of the temporary log file read buffer and write buffer.
> innodb_sort_buffer_size变量还定义了临时日志文件读缓冲区和写缓冲区的大小。

#### 2. Temporary sort files:
&nbsp;&nbsp;Online DDL operations that rebuild the table write temporary sort files to the MySQL temporary directory ($TMPDIR on Unix, %TEMP% on Windows, or the directory specified by --tmpdir) during index creation<sup>思维不要局限，聚簇索引不就是表创建吗</sup>. Temporary sort files are not created in the directory that contains the original table. Each temporary sort file is large enough to hold one column of data, and each sort file is removed when its data is merged into the final table or index. Operations involving temporary sort files may require temporary space equal to the amount of data in the table plus indexes. An error is reported if online DDL operation uses all of the available disk space on the file system where the data directory resides.
> 重建表的在线DDL操作在创建索引时将临时排序文件写入MySQL临时目录(Unix上为$TMPDIR, Windows上为%TEMP%，或由——TMPDIR指定的目录)。在包含原始表的目录中不会创建临时排序文件。每个临时排序文件都大到足以容纳一列数据，并且在将其数据合并到最终表或索引时删除每个排序文件。涉及临时排序文件的操作可能需要相当于表中数据量加上索引的临时空间。如果在线DDL操作使用了数据目录所在文件系统上的所有可用磁盘空间，则会报错。

&nbsp;&nbsp;If the MySQL temporary directory is not large enough to hold the sort files, set tmpdir to a different directory. Alternatively, define a separate temporary directory for online DDL operations using innodb_tmpdir. This option was introduced in MySQL 5.7.11 to help avoid temporary directory overflows that could occur as a result of large temporary sort files.
> 如果MySQL临时目录不够大，不能容纳排序文件，则将tmpdir设置为另一个目录。或者，使用innodb_tmpdir为在线DDL操作定义一个单独的临时目录。这个选项是在MySQL 5.7.11中引入的，以帮助避免由于大型临时排序文件而发生临时目录溢出。



#### 3. Intermediate(中间) table files:
&nbsp;&nbsp;Some online DDL operations that rebuild the table create a temporary intermediate table file in the same directory as the original table. An intermediate table file may require space equal to the size of the original table. Intermediate table file names begin with #sql-ib prefix and only appear briefly during the online DDL operation.
> 一些重新构建表的在线DDL操作会在与原始表相同的目录中创建临时中间表文件。中间表文件可能需要与原始表大小相等的空间。中间表文件名以#sql-ib前缀开始，只在在线DDL操作期间短暂出现。

&nbsp;&nbsp;The innodb_tmpdir option is not applicable to intermediate table files.
> innodb_tmpdir选项不适用于中间表文件。

---

## 参考资料
1. [14.13.1 Online DDL Operations](https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-operations.html) 
2. MySQL-5.7-Reference-Manual-14.13.1-Online-DDL-Operations.pdf (即官方文档)