# Online DDL
&nbsp;&nbsp;MySQL5.6允许辅助索引创建的同时，还允许其他 INSERT,UPDATE,DELETE这类DML操作，这极大提高了MySQL在生产环境的可用性。

&nbsp;&nbsp;不仅仅是辅助索引，如下几类DDL操作都可以通过在线的方式进行操作:
1. 辅助索引的创建和删除
2. 改变自增长值
3. 添加或者删除外检约束
4. 列的重命名
5. ....更多操作，而非仅此而已(参考官方文档)


## 值解析
```txt
    ALTER TABLE tbl_name MODIFY COLUMN column_name data_type NULL, ALGORITHM=INPLACE, LOCK=NONE;

    # ALGORITHM 可选：
    ## | COPY |表示按照MySQL5.1版本之前的工作模式，即创建临时表的方式|
    ## | INPLACE |表示索引创建或删除不需要创建临时表|
    ## | DEFAULT |表示根据参数old_alter_table来判断是通过INPLACE 还是 COPY 的算法，该参数默认值为OFF,即采用INPLACE算法|

    # LOCK 可选
    ## |NONE| 不加任何锁 |
    ## |SHARE|对目标表加上S锁|
    ## |EXCLUSIVE|对目标表添加X锁|
    ## |DEFAULT|会通过判断事务的最大并发性来判断执行DDL的模式,选择的顺序: NONE - > SHARE -> EXCLUSIVE,判断当前操作是否可以使用该模式。若可以，则是用该模式；反之，判断下一个|


    # Oneline DDL 工作方式
    ## InnoDB存储引擎实现Online DDL的原理是在执行创建或删除操作的同时，将INSERT,UPDATE,DELETE这类DML操作日志写入到一个缓存中。待完成索引的创建后再将重做引用到表上，以此达到数据的一致性。
    ## 该缓存大小由innodb_online_alter_log_max_size 控制，默认值为128MB。如果日志超过这个阈值，则会报错。

    # 需要考虑的问题
    ## 1. 磁盘空间的考虑: 当onlineDDL使用创建临时表的方式处理时
       ALTER TABLE tbl_name CHANGE c1 c1 BIGINT, ALGORITHM=COPY; (修改字段类型ALGORITHM只能是COPY)
    这条OnlineDDL,已创建临时表的方式修改列类型，那么在执行这条SQL时需要保证数据库有足够的磁盘空间。
```

---

## [14.13 InnoDB and Online DDL](https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl.html)
&nbsp;&nbsp;Online DDL操作
### [14.13.1 Online DDL Operations](https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-operations.html)
&nbsp;&nbsp;该文档说明了Online DDL支持的操作类型,以及具体算法.

### [14.13.2 Online DDL Performance and Concurrency](https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-performance.html)
&nbsp;&nbsp;Online DDL improves(改善) several aspects of MySQL operation:
> Online DDL 改善了MySQL操作的几个方面:

+ Applications that access the table are more responsive(adj.反应迅速的，积极反应的；反应热烈的，热情的；回应的，回答的；) because queries and DML operations on the table can proceed(v.开始行动，开展；) while the DDL operation is in progress. Reduced locking and waiting for MySQL server resources leads to greater scalability(n.可扩展性；可伸缩性；可量测性), even for operations that are not involved(adj.复杂的;v.牵涉，包含) in the DDL operation.
> 在DDL操作执行的时候，允许查询和DML操作执行，减少锁表和等待以获取更好地性能。即使是DDL操作中没有涉及的操作

+ In-place operations avoid the disk I/O and CPU cycles associated with the table-copy method, which minimizes(把……减至最低数量) overall(总的;全面的;) load on the database. Minimizing load helps maintain(v.保持，维持；维修，保养；断言) good performance and high throughput(n.（某一时期内的）生产量，接待人数，吞吐量) during the DDL operation.
> 与表复制方法相比，In-place 操作节省了I/O和CPU周期，将数据库总的负载减到最小。降低负载有助于保持数据库的高性能和高吞吐率。

+ In-place operations read less data into the buffer pool than the table-copy operations, which reduces purging of frequently accessed data from memory. Purging of frequently accessed data can cause a temporary performance dip(下降;下沉;降低;) after a DDL operation.
> 相比于表复制的方式，In-place 操作读取少量的数据到buffer pool，它减少了从内存中清除频繁访问的数据。在DDL操作后清理频繁访问的数据会临时降低性能。

####  The LOCK clause(从句，分句；)
&nbsp;&nbsp;By default, MySQL uses as little locking as possible during a DDL operation. The LOCK clause can be specified to enforce(v.实施;执行;强迫;) more restrictive(adj.限制的;约束的;) locking, if required. If the LOCK clause specifies a less restrictive level of locking than is permitted(v.允许;批准) for a particular(adj.特定的;格外的;n.一点;一个细节;详情;详细资料) DDL operation, the statement fails with an error. LOCK clauses are described below, in order of least to most restrictive:
> 默认情况下，在DDL执行期间，尽可能使用少的锁。如果需要，可以指定LOCK子句来强制更严格的锁定。如果LOCK子句指定的锁级别低于特定DDL操作锁允许的锁级别，则语句将失败并出错。下面描述了LOCK子句，从最少到最严格的顺序

>> 一些DDL操作，只能使用其中一个级别.

##### LOCK=NONE
&nbsp;&nbsp;Permits concurrent queries and DML.
> 允许并发的查询和DML

&nbsp;&nbsp;For example, use this clause for tables involving(v.涉及;包括;) customer signups(n.注册（signup 的复数）) or purchases, to avoid making the tables unavailable during lengthy(漫长的;长时间的;) DDL operations.
> 例如，对于涉及客户注册或购买的表使用此子句，以避免在漫长的的DDL操作期间使表不可用。

##### LOCK=SHARED
&nbsp;&nbsp;Permits concurrent queries but blocks DML.
> 允许并发查询但阻塞DML操作

&nbsp;&nbsp;For example, use this clause on data warehouse tables, where you can delay data load operations until the DDL operation is finished, but queries cannot be delayed for long periods(n.周期).
> 例如，在数据仓库表上使用这个子句，可以延迟数据加载操作，直到DDL操作完成，但是查询不能长时间延迟

##### LOCK=DEFAULT
&nbsp;&nbsp;Permits as much concurrency(并发性;同时发生;) as possible (concurrent queries, DML, or both). Omitting(省略) the LOCK clause is the same as specifying LOCK=DEFAULT.
> 允许尽可能多的并发(并发查询或DML或全部)。省略LOCK子句和指定LOCK=DEFAULT一样.

&nbsp;&nbsp;Use this clause when you know that the default locking level of the DDL statement does not cause availability(n.可用性，可得性) problems for the table.
> 当你知晓DDL语句默认的锁级别不会造成该表可用性问题的时候使用该子句。

##### LOCK=EXCLUSIVE
&nbsp;&nbsp;Blocks concurrent queries and DML.
> 阻塞并发查询和DML

&nbsp;&nbsp;Use this clause if the primary concern is finishing the DDL operation in the shortest amount of time possible, and concurrent query and DML access is not necessary. You might also use this clause if the server is supposed to be idle, to avoid unexpected table accesses.
> 如果主要关注的是在尽可能短的时间内完成DDL操作，而并发查询和DML访问不是必需的，则使用此子句。如果服务器应该是空闲的，也可以使用这个子句，以避免意外的表访问。

---
#### Online DDL and Metadata Locks
&nbsp;&nbsp;Online DDL operations can be viewed as having three phases:
> DDL操作可以被看作为有三个阶段:

##### Phase 1: Initialization
&nbsp;&nbsp;In the initialization phase, the server determines how much concurrency is permitted during the operation, taking into account storage engine capabilities, operations specified in the statement, and user-specified ALGORITHM and LOCK options. During this phase, a shared upgradeable metadata lock is taken to protect the current table definition.
> 在初始化阶段，服务器将考虑存储引擎能力、语句中指定的操作以及用户指定的ALGORITHM和LOCK选项，确定操作期间允许多少并发。在此阶段，使用一个共享的可升级元数据锁来保护当前表定义。

##### Phase 2: Execution
&nbsp;&nbsp;In this phase, the statement is prepared and executed. Whether the metadata lock is upgraded to exclusive depends on the factors assessed in the initialization phase. If an exclusive metadata lock is required, it is only taken briefly during statement preparation.
> 在此阶段，准备并执行语句。元数据锁是否升级为排他锁取决于初始化阶段评估的因素。如果需要一个排他元数据锁，它只会在语句准备期间短暂使用。

##### Phase 3: Commit Table Definition
&nbsp;&nbsp;In the commit table definition phase, the metadata lock is upgraded to exclusive to evict the old table definition and commit the new one. Once granted, the duration of the exclusive metadata lock is brief.
> 在提交表定义阶段，元数据锁升级为排他锁，以退出旧的表定义并提交新表定义。一旦授予，独占元数据锁的持续时间很短。

&nbsp;&nbsp;Due to the exclusive metadata lock requirements outlined above, an online DDL operation may have to wait for concurrent transactions that hold metadata locks on the table to commit or rollback. Transactions started before or during the DDL operation can hold metadata locks on the table being altered. In the case of a long running or inactive transaction, an online DDL operation can time out waiting for an exclusive metadata lock. Additionally, a pending exclusive metadata lock requested by an online DDL operation blocks subsequent transactions on the table.
> 由于上面概述的排他元数据锁需求，Online DDL操作可能必须等待持有表上元数据锁的并发事务提交或回滚。在DDL操作之前或期间开始的事务可以持有被更改表上的元数据锁。对于长时间运行或不活动的事务，Online DDL操作在等待独占元数据锁时可能会超时。此外，Online DDL操作请求的挂起的排他性元数据锁会阻塞表上的后续事务。

&nbsp;&nbsp;The following example demonstrates an online DDL operation waiting for an exclusive metadata lock, and how a pending metadata lock blocks subsequent transactions on the table.
> 下面的示例演示了一个等待独占元数据锁的Online DDL操作，以及挂起的元数据锁如何阻塞表上的后续事务。(使用自编译MySQL测试)

###### Session1 (测试环境: DataBase: stu , table_name: t1;)
```txt
   Session 1:
     mysql> CREATE TABLE t1 (c1 INT) ENGINE=InnoDB;
     mysql> START TRANSACTION;
     mysql> SELECT * FROM t1;
   
   The session 1 SELECT statement takes a shared metadata lock on table t1.
   > 元数据锁和表锁的关系是什么?
   > 使用MySQL8(001.SOURCE_CODE/001.mysql-server-8.0.30-GA)SQL： “select * from performance_schema.data_locks;”(另外一个session上执行) , 结果: Empty set (0.00 sec). 所以表锁不是元数据锁.
   
   # 此时元数据锁情况
   mysql> select * from performance_schema.metadata_locks; (可以发现,t1表上加上了SHARED_READ锁;)
   +-------------------+--------------------+----------------+-----------------------+-----------------------+---------------------+---------------+-------------+-------------------+-----------------+----------------+
   | OBJECT_TYPE       | OBJECT_SCHEMA      | OBJECT_NAME    | COLUMN_NAME           | OBJECT_INSTANCE_BEGIN | LOCK_TYPE           | LOCK_DURATION | LOCK_STATUS | SOURCE            | OWNER_THREAD_ID | OWNER_EVENT_ID |
   +-------------------+--------------------+----------------+-----------------------+-----------------------+---------------------+---------------+-------------+-------------------+-----------------+----------------+
   | TABLE             | stu                | t1             | NULL                  |       140735073773024 | SHARED_READ         | TRANSACTION   | GRANTED     | sql_parse.cc:6012 |              49 |             16 |
   | TABLE             | performance_schema | metadata_locks | NULL                  |       140735005416944 | SHARED_READ         | TRANSACTION   | GRANTED     | sql_parse.cc:6012 |              50 |              4 |
   | SCHEMA            | performance_schema | NULL           | NULL                  |       140735005412688 | INTENTION_EXCLUSIVE | TRANSACTION   | GRANTED     | dd_schema.cc:107  |              50 |              4 |
   | COLUMN STATISTICS | performance_schema | metadata_locks | column_name           |       140735005953072 | SHARED_READ         | STATEMENT     | GRANTED     | sql_base.cc:596   |              50 |              4 |
   | COLUMN STATISTICS | performance_schema | metadata_locks | lock_duration         |       140735006012752 | SHARED_READ         | STATEMENT     | GRANTED     | sql_base.cc:596   |              50 |              4 |
   | COLUMN STATISTICS | performance_schema | metadata_locks | lock_status           |       140735005469792 | SHARED_READ         | STATEMENT     | GRANTED     | sql_base.cc:596   |              50 |              4 |
   | COLUMN STATISTICS | performance_schema | metadata_locks | lock_type             |       140735005417488 | SHARED_READ         | STATEMENT     | GRANTED     | sql_base.cc:596   |              50 |              4 |
   | COLUMN STATISTICS | performance_schema | metadata_locks | object_instance_begin |       140735005394496 | SHARED_READ         | STATEMENT     | GRANTED     | sql_base.cc:596   |              50 |              4 |
   | COLUMN STATISTICS | performance_schema | metadata_locks | object_name           |       140735005417120 | SHARED_READ         | STATEMENT     | GRANTED     | sql_base.cc:596   |              50 |              4 |
   | COLUMN STATISTICS | performance_schema | metadata_locks | object_schema         |       140735005400992 | SHARED_READ         | STATEMENT     | GRANTED     | sql_base.cc:596   |              50 |              4 |
   | COLUMN STATISTICS | performance_schema | metadata_locks | object_type           |       140735005470464 | SHARED_READ         | STATEMENT     | GRANTED     | sql_base.cc:596   |              50 |              4 |
   | COLUMN STATISTICS | performance_schema | metadata_locks | owner_event_id        |       140735005410736 | SHARED_READ         | STATEMENT     | GRANTED     | sql_base.cc:596   |              50 |              4 |
   | COLUMN STATISTICS | performance_schema | metadata_locks | owner_thread_id       |       140735005400832 | SHARED_READ         | STATEMENT     | GRANTED     | sql_base.cc:596   |              50 |              4 |
   | COLUMN STATISTICS | performance_schema | metadata_locks | source                |       140735006029744 | SHARED_READ         | STATEMENT     | GRANTED     | sql_base.cc:596   |              50 |              4 |
   +-------------------+--------------------+----------------+-----------------------+-----------------------+---------------------+---------------+-------------+-------------------+-----------------+----------------+

   # 额外测试,当session事务提交之后：从结果看,当事务提交之后，元数据锁会被释放。
   mysql> select * from performance_schema.metadata_locks;
   +-------------+--------------------+----------------+-------------+-----------------------+-------------+---------------+-------------+-------------------+-----------------+----------------+
   | OBJECT_TYPE | OBJECT_SCHEMA      | OBJECT_NAME    | COLUMN_NAME | OBJECT_INSTANCE_BEGIN | LOCK_TYPE   | LOCK_DURATION | LOCK_STATUS | SOURCE            | OWNER_THREAD_ID | OWNER_EVENT_ID |
   +-------------+--------------------+----------------+-------------+-----------------------+-------------+---------------+-------------+-------------------+-----------------+----------------+
   | TABLE       | performance_schema | metadata_locks | NULL        |       140735005413056 | SHARED_READ | TRANSACTION   | GRANTED     | sql_parse.cc:6012 |              50 |              7 |
   +-------------+--------------------+----------------+-------------+-----------------------+-------------+---------------+-------------+-------------------+-----------------+----------------+
   1 row in set (0.00 sec)
```

###### Session 2:(被阻塞)
```txt
     mysql> ALTER TABLE t1 ADD COLUMN x INT, ALGORITHM=INPLACE, LOCK=NONE;
   
     The online DDL operation in session 2, which requires an exclusive metadata lock on table t1 to commit table definition changes, must wait for the session 1 transaction to commit or roll back.
     > 会话2中的Online DDL操作需要表t1上的独占元数据锁来提交表定义更改，它必须等待会话1事务提交或回滚。
     >> 经过测试，Session 2会一直被阻塞.
```

###### Session 3: (被阻塞)
```txt
     mysql> SELECT * FROM t1;

     The SELECT statement issued in session 3 is blocked waiting for the exclusive metadata lock requested by the ALTER TABLE operation in session 2 to be granted.
     > 会话3中发出的SELECT语句阻塞，等待会话2中ALTER TABLE操作请求的独占元数据锁被授予。
```

###### 元数据锁查看
```txt
   You can use SHOW FULL PROCESSLIST to determine if transactions are waiting for a metadata lock.  
   > 您可以使用SHOW FULL PROCESSLIST来确定事务是否在等待元数据锁。
   mysql> SHOW FULL PROCESSLIST \G
   *************************** 1. row ***************************
        Id: 3
      User: root
      Host: localhost
        db: stu
   Command: Sleep
      Time: 267
     State: 
      Info: NULL
   *************************** 2. row ***************************
        Id: 4
      User: root
      Host: localhost
        db: stu
   Command: Query
      Time: 241
     State: Waiting for table metadata lock
      Info: ALTER TABLE t1 ADD COLUMN x INT, ALGORITHM=INPLACE, LOCK=NONE
   *************************** 3. row ***************************
        Id: 5
      User: root
      Host: localhost
        db: stu
   Command: Query
      Time: 61
     State: Waiting for table metadata lock
      Info: SELECT * FROM t1
   *************************** 4. row ***************************
        Id: 6
      User: root
      Host: localhost
        db: NULL
   Command: Query
      Time: 0
     State: starting
      Info: SHOW FULL PROCESSLIST
   4 rows in set (0.00 sec)
   
   mysql> 
  
   Metadata lock information is also exposed through the Performance Schema metadata_locks table, which provides information about metadata lock dependencies between sessions, the metadata lock a session is waiting for, and the session that currently holds the metadata lock. For more information, see Section 25.12.12.1, “The metadata_locks Table”.
     > 元数据锁信息还通过Performance Schema metadata_locks表公开，该表提供了关于会话之间的元数据锁依赖关系、会话正在等待的元数据锁以及当前持有元数据锁的会话的信息。有关更多信息，请参见第25.12.12.1节，“metadata_locks table”。
```

---

#### Online DDL Performance
&nbsp;&nbsp;The performance of a DDL operation is largely determined by whether the operation is performed(v.执行，表演（perform 的过去式和过去分词）) in place and whether it rebuilds the table.
> DDL操作的性能在很大程度上取决于该操作是否在适当的位置执行以及它是否重新构建表。

&nbsp;&nbsp;To assess(v.评价，评定；估价，估计) the relative performance of a DDL operation, you can compare results using ALGORITHM=INPLACE with results using ALGORITHM=COPY. Alternatively(adv.要不，或者), you can compare results with old_alter_table disabled and enabled.
> 要评估DDL操作的相对性能，可以比较使用ALGORITHM=INPLACE和ALGORITHM=COPY的结果。或者，您可以比较old_alter_table禁用和启用的结果。

&nbsp;&nbsp;For DDL operations that modify table data, you can determine whether a DDL operation performs changes in place or performs a table copy by looking at the “rows affected” value displayed after the command finishes. For example:
> 对于修改表数据的DDL操作，可以通过查看命令完成后显示的“受影响的行”值来确定DDL操作是就地执行更改还是执行表复制。例如:

+ Changing the default value of a column (fast, does not affect the table data):
  - Query OK, 0 rows affected (0.07 sec)
+ Adding an index (takes time, but 0 rows affected shows that the table is not copied):
  - Query OK, 0 rows affected (21.42 sec)
+ Changing the data type of a column (takes substantial(adj.大量的;) time and requires rebuilding all the rows of the table):
  - Query OK, 1671168 rows affected (1 min 35.54 sec)


&nbsp;&nbsp;Before running a DDL operation on a large table, check whether the operation is fast or slow as follows:
> 在大表上执行DDL操作前，按照如下步骤判断一下操作是快是慢:

1. Clone the table structure.
2. Populate the cloned table with a small amount of data.
3. Run the DDL operation on the cloned table.
4. Check whether the “rows affected” value is zero or not. A nonzero value means the operation copies table data, which might require special planning. For example, you might do the DDL operation during a period of scheduled downtime, or on each replica server one at a time.

&nbsp;&nbsp;Because there is some processing work involved with recording the changes made by concurrent DML operations, then applying those changes at the end, an online DDL operation could take longer overall than the table-copy mechanism that blocks table access from other sessions. The reduction in raw performance is balanced against better responsiveness for applications that use the table. When evaluating the techniques for changing table structure, consider end-user perception of performance, based on factors such as load times for web pages.
> 由于需要记录并发DML操作所做的更改，然后在最后应用这些更改，因此Online DDL操作所花费的时间可能比表复制机制(它会阻止其他会话对表的访问)要长。原始性能的降低与使用该表的应用程序更好的响应性是平衡的。在评估更改表结构的技术时，要根据网页的加载时间等因素考虑终端用户对性能的感知。

---

### [14.13.3 Online DDL Space Requirements（空间需求）](https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-space-requirements.html)
&nbsp;&nbsp;Online DDL operations have the following space requirements:
> Online DDL有如下的空间需求:

#### 1. Temporary log files:
&nbsp;&nbsp;A temporary log file records concurrent DML when an online DDL operation creates an index or alters a table. The temporary log file is extended as required by the value of innodb_sort_buffer_size up to a maximum specified by innodb_online_alter_log_max_size. If the operation takes a long time and concurrent DML modifies the table so much that the size of the temporary log file exceeds the value of innodb_online_alter_log_max_size, the online DDL operation fails with a DB_ONLINE_LOG_TOO_BIG error and uncommitted concurrent DML operations are rolled back. A large innodb_online_alter_log_max_size setting permits more DML during an online DDL operation, but it also extends the period of time at the end of the DDL operation when the table is locked to apply logged DML.
> 当Online DDL操作创建索引或修改表时，临时日志文件记录并发的DML。临时日志根据innodb_sort_buffer_size的值扩展到innodb_online_alter_log_max_size的最大值。如果操作耗时较长，并发DML修改表的时间太长，导致临时日志文件的大小超过innodb_online_alter_log_max_size，则Online DDL操作会失败，会出现DB_ONLINE_LOG_TOO_BIG错误，并回滚未提交的并发DML操作。一个大的innodb_online_alter_log_max_size设置允许在Online DDL操作期间使用更多的DML，但是它也延长了DDL操作结束时表被锁定以应用日志DML的时间。

&nbsp;&nbsp;The innodb_sort_buffer_size variable also defines the size of the temporary log file read buffer and write buffer.
> innodb_sort_buffer_size变量还定义了临时日志文件读缓冲区和写缓冲区的大小。

#### 2. Temporary sort files:
&nbsp;&nbsp;Online DDL operations that rebuild the table write temporary sort files to the MySQL temporary directory ($TMPDIR on Unix, %TEMP% on Windows, or the directory specified by --tmpdir) during index creation<sup>思维不要局限，聚簇索引不就是表创建吗</sup>. Temporary sort files are not created in the directory that contains the original table. Each temporary sort file is large enough to hold one column of data, and each sort file is removed when its data is merged into the final table or index. Operations involving temporary sort files may require temporary space equal to the amount of data in the table plus indexes. An error is reported if online DDL operation uses all of the available disk space on the file system where the data directory resides.
> 重建表的Online DDL操作在创建索引时将临时排序文件写入MySQL临时目录(Unix上为$TMPDIR, Windows上为%TEMP%，或由——TMPDIR指定的目录)。在包含原始表的目录中不会创建临时排序文件。每个临时排序文件都大到足以容纳一列数据，并且在将其数据合并到最终表或索引时删除每个排序文件。涉及临时排序文件的操作可能需要相当于表中数据量加上索引的临时空间。如果Online DDL操作使用了数据目录所在文件系统上的所有可用磁盘空间，则会报错。

&nbsp;&nbsp;If the MySQL temporary directory is not large enough to hold the sort files, set tmpdir to a different directory. Alternatively, define a separate temporary directory for online DDL operations using innodb_tmpdir. This option was introduced in MySQL 5.7.11 to help avoid temporary directory overflows that could occur as a result of large temporary sort files.
> 如果MySQL临时目录不够大，不能容纳排序文件，则将tmpdir设置为另一个目录。或者，使用innodb_tmpdir为Online DDL操作定义一个单独的临时目录。这个选项是在MySQL 5.7.11中引入的，以帮助避免由于大型临时排序文件而发生临时目录溢出。



#### 3. Intermediate(中间) table files:
&nbsp;&nbsp;Some online DDL operations that rebuild the table create a temporary intermediate table file in the same directory as the original table. An intermediate table file may require space equal to the size of the original table. Intermediate table file names begin with #sql-ib prefix and only appear briefly during the online DDL operation.
> 一些重新构建表的Online DDL操作会在与原始表相同的目录中创建临时中间表文件。中间表文件可能需要与原始表大小相等的空间。中间表文件名以#sql-ib前缀开始，只在Online DDL操作期间短暂出现。

&nbsp;&nbsp;The innodb_tmpdir option is not applicable to intermediate table files.
> innodb_tmpdir选项不适用于中间表文件。

---

### [14.13.4 Simplifying DDL Statements with Online DDL](https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-single-multi.html)
&nbsp;&nbsp;Before the introduction of online DDL, it was common practice to combine many DDL operations into a single ALTER TABLE statement. Because each ALTER TABLE statement involved copying and rebuilding the table, it was more efficient to make several changes to the same table at once, since those changes could all be done with a single rebuild operation for the table. The downside was that SQL code involving DDL operations was harder to maintain and to reuse in different scripts. If the specific changes were different each time, you might have to construct a new complex ALTER TABLE for each slightly different scenario.
> 在介绍online DDL之前，通常的做法是将许多DDL操作合并到一个ALTER TABLE语句中，因为每个ALTER TABLE语句都涉及到复制和重建表，所以一次对同一个表进行多次更改会更有效，因为这些更改都可以通过对表的一次重建操作完成.缺点是涉及DDL操作的SQL代码更难维护和在不同的脚本中重用。如果每次特定的更改都不同，那么可能必须为每个稍有不同的场景构造一个新的复杂的ALTER TABLE。

&nbsp;&nbsp;For DDL operations that can be done in place, you can separate them into individual ALTER TABLE statements for easier scripting and maintenance, without sacrificing efficiency. For example, you might take a complicated statement such as:
> 对于可以就地完成的DDL操作，可以将它们分离为单独的ALTER TABLE语句，以便更容易地编写脚本和维护，而不会牺牲效率。例如，你可能会使用一个复杂的语句，比如:
```sql
     ALTER TABLE t1 ADD INDEX i1(c1), ADD UNIQUE INDEX i2(c2), CHANGE c4_old_name c4_new_name INTEGER UNSIGNED;
```

&nbsp;&nbsp;and break it down into simpler parts that can be tested and performed independently, such as:
> 并将其分解为可以独立测试和执行的更简单的部分，例如:
```sql
     ALTER TABLE t1 ADD INDEX i1(c1);
     ALTER TABLE t1 ADD UNIQUE INDEX i2(c2);
     ALTER TABLE t1 CHANGE c4_old_name c4_new_name INTEGER UNSIGNED NOT NULL;
```

&nbsp;&nbsp;You might still use multi-part ALTER TABLE statements for:
> 你仍然可以使用多部分的ALTER TABLE语句<sup>将多个操作合并到一个DDL中</sup>:
+ Operations that must be performed in a specific sequence, such as creating an index followed by a foreign key constraint that uses that index.
  > 必须按特定顺序执行的操作，例如创建索引，然后是使用该索引的外键约束。
+ Operations all using the same specific LOCK clause, that you want to either succeed or fail as a group.
  > 所有操作都使用相同的特定LOCK子句，您希望它们作为一个组成功或失败。
+ Operations that cannot be performed in place, that is, that still use the table-copy method.
  > 不能就地执行的操作，即仍然使用表复制方法的操作。<sup>测试结果: </sup>
+ Operations for which you specify ALGORITHM=COPY or old_alter_table=1, to force the table-copying behavior if needed for precise backward-compatibility in specialized scenarios.
  > 指定ALGORITHM=COPY或old_alter_table=1的操作，如果需要在特定场景中实现精确的向后兼容性，可以强制表复制行为。


---

### [14.13.5 Online DDL Failure Conditions](https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-failure-conditions.html)
&nbsp;&nbsp;The failure of an online DDL operation is typically due to one of the following conditions:
> Online DDL操作失败通常是由于以下情况之一:

+ An ALGORITHM clause specifies an algorithm that is not compatible with the particular type of DDL operation or storage engine.
  > ALGORITHM子句指定的算法与特定类型的DDL操作或存储引擎不兼容。
+ A LOCK clause specifies a low degree of locking (SHARED or NONE) that is not compatible with the particular type of DDL operation.
  > LOCK子句指定了与特定类型的DDL操作不兼容的低级别锁(SHARED或NONE)。
+ A timeout occurs while waiting for an exclusive lock on the table, which may be needed briefly during the initial and final phases of the DDL operation.
  > 在等待表上的独占锁时发生超时，在DDL操作的初始和最后阶段可能需要短暂的超时。
+ The tmpdir or innodb_tmpdir file system runs out of disk space, while MySQL writes temporary sort files on disk during index creation. For more information, see Section 14.13.3, “Online DDL Space Requirements”.
  > 磁盘空间不足
+ The operation takes a long time and concurrent DML modifies the table so much that the size of the temporary online log exceeds the value of the innodb_online_alter_log_max_size configuration option. This condition causes a DB_ONLINE_LOG_TOO_BIG error.
  > 该操作耗时较长，并发的DML对表的修改太多，导致临时在线日志的大小超过了innodb_online_alter_log_max_size配置选项的值。这个条件会导致DB_ONLINE_LOG_TOO_BIG错误。
+ Concurrent DML makes changes to the table that are allowed with the original table definition, but not with the new one. The operation only fails at the very end, when MySQL tries to apply all the changes from concurrent DML statements. For example, you might insert duplicate values into a column while a unique index is being created, or you might insert NULL values into a column while creating a primary key index on that column. The changes made by the concurrent DML take precedence, and the ALTER TABLE operation is effectively rolled back.
  > 并发DML对原始表定义允许的表进行更改，但新表定义不允许。这个操作只在最后失败，当MySQL尝试应用所有并发DML语句的更改时。例如，您可能会在创建惟一索引时向列中插入重复的值，或者在该列上创建主键索引时向该列中插入NULL值。并发DML所做的更改优先，并且可以有效地回滚ALTER TABLE操作。

---
### [14.13.6 Online DDL Limitations](https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-limitations.html)
&nbsp;&nbsp;The following limitations apply to online DDL operations:
> 以下限制适用于Online DDL

+ The table is copied when creating an index on a TEMPORARY TABLE.
  > 在 TEMPORARY TABLE 创建索引时复制表

+ The ALTER TABLE clause LOCK=NONE is not permitted if there are ON...CASCADE or ON...SET NULL constraints(n.约束;限制;) on the table.
  > 如果字段上有，那么ALTER中不能有LOCK=NONE子句。

+ Before an online DDL operation can finish, it must wait for transactions that hold metadata locks on the table to commit or roll back. An online DDL operation may briefly(adj.简短地;短暂的;临时地;) require an exclusive metadata lock on the table during its execution phase, and always requires one in the final phase of the operation when updating the table definition. Consequently(adv.因此;结果;), transactions holding metadata locks on the table can cause an online DDL operation to block. The transactions that hold metadata locks on the table may have been started before or during the online DDL operation. A long running or inactive transaction that holds a metadata lock on the table can cause an online DDL operation to timeout.
  > 在Online DDL操作完成之前，必须等待持有元数据锁的事务提交或回滚<sup>如上测试，因为需要等待元数据锁被释放</sup>。Online DDL在执行阶段可能短暂需要独占元数据锁，并且在操作的最后阶段更新表定义的时候需要一直持有。在表上持有元数据锁的事务可能导致Online DDL操作阻塞。在表上持有元数据锁的事务可能在Online DDL操作之前或期间启动。长时间运行或不活动的事务在表上持有元数据锁，可能导致Online DDL操作超时。

+ An online DDL operation on a table in a foreign key relationship does not wait for a transaction executing on the other table in the foreign key relationship to commit or rollback. The transaction holds an exclusive metadata lock on the table it is updating and shared metadata lock on the foreign-key-related table (required for foreign key checking). The shared metadata lock permits the online DDL operation to proceed but blocks the operation in its final phase, when an exclusive metadata lock is required to update the table definition. This scenario can result in deadlocks as other transactions wait for the online DDL operation to finish.
  > 外键关系中的表上的Online DDL操作不等待外键关系中的另一个表上执行的事务提交或回滚。事务持有它正在更新的表上的排他元数据锁和外键相关表上的共享元数据锁(检查外键需要)。共享元数据锁允许Online DDL操作继续进行，但在操作的最后阶段(更新表定义需要一个排他性元数据锁)会阻塞该操作。当其他事务等待Online DDL操作完成时，此场景可能会导致死锁。

+ When running an online DDL operation, the thread that runs the ALTER TABLE statement applies an online log of DML operations that were run concurrently on the same table from other connection threads. When the DML operations are applied, it is possible to encounter a duplicate key entry error (ERROR 1062 (23000): Duplicate entry), even if the duplicate entry is only temporary and would be reverted by a later entry in the online log. This is similar to the idea of a foreign key constraint check in InnoDB in which constraints must hold during a transaction.
  > 当运行一个Online DDL操作时，运行ALTER TABLE语句的线程会应用一个在线日志，记录其他连接线程在同一个表上并发运行的DML操作。当应用DML操作时，可能会遇到重复键条目错误(error 1062(23000):重复条目)，即使重复条目只是临时的，并且会被在线日志中稍后的条目恢复。这类似于InnoDB中的外键约束检查，即在事务期间必须保持约束。

+ OPTIMIZE TABLE for an InnoDB table is mapped to an ALTER TABLE operation to rebuild the table and update index statistics and free unused space in the clustered index. Secondary indexes are not created as efficiently because keys are inserted in the order they appeared in the primary key. OPTIMIZE TABLE is supported with the addition of online DDL support for rebuilding regular and partitioned InnoDB tables.
  > 将InnoDB表的OPTIMIZE TABLE映射到ALTER TABLE操作，以重建表，更新索引统计信息，释放聚集索引中未使用的空间。二级索引的创建效率不高，因为键是按它们在主键中出现的顺序插入的。对OPTIMIZE TABLE的支持还包括Online DDL支持，用于重建常规的和分区的InnoDB表。

+ Tables created before MySQL 5.6 that include temporal(adj.世俗的;与时间有关的;) columns (DATE, DATETIME or TIMESTAMP) and have not been rebuilt using ALGORITHM=COPY do not support ALGORITHM=INPLACE. In this case, an ALTER TABLE ... ALGORITHM=INPLACE operation returns the following error:
  > MySQL5.6之前，与表如果包含与事件有关的列，那么只能使用ALGORITHM=COPY,而不能使用ALGORITHM=INPLACE
   ```txt
    ERROR 1846 (0A000): ALGORITHM=INPLACE is not supported.
    Reason: Cannot change column type INPLACE. Try ALGORITHM=COPY.
   ``` 

+ The following limitations are generally applicable to online DDL operations on large tables that involve rebuilding the table:
  > 以下限制通常适用于需要重建表的大型表上的Online DDL操作
   - There is no mechanism to pause an online DDL operation or to throttle I/O or CPU usage for an online DDL operation.
      > 没有暂停Online DDL操作或限制Online DDL操作的I/O或CPU使用的机制。
   - Rollback of an online DDL operation can be expensive should the operation fail.
     > 如果Online DDL操作失败，回滚操作的代价可能很高。
   - Long running online DDL operations can cause replication lag. An online DDL operation must finish running on the source before it is run on the replica. Also, DML that was processed concurrently on the source is only processed on the replica after the DDL operation on the replica is completed.
     > 长时间运行Online DDL操作会导致复制延迟。Online DDL操作必须在源上运行完之后才能在副本上运行。此外，在源上并发处理的DML只有在副本上的DDL操作完成后才在副本上处理。
---
## 附录
### 1. [8.11.4 Metadata Locking](https://dev.mysql.com/doc/refman/5.7/en/metadata-locking.html)
&nbsp;&nbsp;MySQL uses metadata locking to manage concurrent access to database objects and to ensure data consistency. Metadata locking applies not just to tables, but also to schemas, stored programs (procedures, functions, triggers, scheduled events), tablespaces, user locks acquired with the GET_LOCK() function (see Section 12.15, “Locking Functions”), and locks acquired with the locking service described in Section 5.5.6.1, “The Locking Service”.
>  MySQL使用元数据锁定来管理对<font color="red">**数据库对象**</font>的并发访问，并确保数据的一致性。元数据锁定不仅适用于表，还适用于schemas、存储过程(过程、函数、触发器、预定事件)、表空间、GET_LOCK()函数获得的用户锁，以及5.5.6.1节“锁定服务”中描述的通过锁定服务获得锁。

&nbsp;&nbsp;The Performance Schema metadata_locks table exposes metadata lock information, which can be useful for seeing which sessions hold locks, are blocked waiting for locks, and so forth. For details, see Section 25.12.12.1, “The metadata_locks Table”.
> Performance库metadata_locks表公开了元数据锁信息，这些信息对于查看哪些session持有锁，哪些session等待锁非常有空。具体细节查看"The metadata_locks Table"

&nbsp;&nbsp;Metadata locking does involve(v.牵涉，涉及；包含) some overhead, which increases as query volume increases. Metadata contention(n.看法，观点；争论，争吵；争夺，竞争) increases the more that multiple queries attempt to access the same objects.
> 元数据锁确实涉及一些开销，且随着查询量的增加而增加。多个查询访问相同的对象时，元数据争用会增加.

&nbsp;&nbsp;Metadata locking is not a replacement for the table definition cache, and its mutexes and locks differ from the LOCK_open mutex. The following discussion provides some information about how metadata locking works.
> 元数据锁不能替代表定义缓存，它的互斥锁和锁与LOCK_open互斥锁不同。下面的讨论提供了一些关于元数据锁定如何工作的信息。

#### Metadata Lock Acquisition（元数据锁获取）
&nbsp;&nbsp;If there are multiple waiters for a given lock, the highest-priority lock request is satisfied first, with an exception related to the max_write_lock_count system variable. Write lock requests have higher priority than read lock requests. However, if max_write_lock_count is set to some low value (say, 10), read lock requests may be preferred over pending write lock requests if the read lock requests have already been passed over in favor of 10 write lock requests. Normally this behavior does not occur because max_write_lock_count by default has a very large value.
> 如果一个指定的锁有很多个等待者，并且会出现一个与max_write_lock_count系统变量相关的异常。写锁请求的优先级高于读锁请求。但是，如果max_write_lock_count设置为某个较低的值(比如10)，如果读锁请求已经被传递给了10个写锁请求，那么读锁请求可能会优先于挂起的写锁请求。通常这种行为不会发生，因为max_write_lock_count默认值非常大。

&nbsp;&nbsp;Statements acquire metadata locks one by one, not simultaneously(adv.同时地), and perform deadlock detection in the process.
> 语句逐个获取元数据锁，而不是同时获取，并在此过程中执行死锁检测

&nbsp;&nbsp;DML statements normally acquire locks in the order in which tables are mentioned(mention: v.提到，谈到；提名，推荐) in the statement.
> DML语句通常按照表在语句中被提及的顺序获取锁。

&nbsp;&nbsp;DDL statements, LOCK TABLES, and other similar statements try to reduce the number of possible deadlocks between concurrent DDL statements by acquiring locks on explicitly(adv.清楚明确地，详述地；直截了当地，坦率地；露骨地，不隐晦地) named tables in name order. Locks might be acquired in a different order for implicitly(adv.含蓄地，暗中地；绝对地) used tables (such as tables in foreign key relationships that also must be locked).
> DDL语句、LOCK TABLES和其他类似语句试图通过按名称顺序获取显式命名表上的锁来减少并发DDL语句之间可能的死锁数量。对于隐式使用的表(例如外键关系中的表也必须被锁定)，可能会以不同的顺序获得锁。

&nbsp;&nbsp;For example, RENAME TABLE is a DDL statement that acquires locks in name order:
> 例如，RENAME TABLE是一条DDL语句，它按照**名称顺序**获取锁:
```sql
   # This RENAME TABLE statement renames tbla to something else, and renames tblc to tbla:
    RENAME TABLE tbla TO tbld, tblc TO tbla;
   # The statement acquires metadata locks, in order, on tbla, tblc, and tbld (because tbld follows tblc in name order):


   # ---

   # This slightly(adv.稍微;) different statement also renames tbla to something else, and renames tblc to tbla:
     RENAME TABLE tbla TO tblb, tblc TO tbla;
   # In this case, the statement acquires metadata locks, in order, on tbla, tblb, and tblc (because tblb precedes(v.在...之先;领先;优于) tblc in name order):  

   # Both statements acquire locks on tbla and tblc, in that order, but differ in whether the lock on the remaining table name is acquired before or after tblc.
   》 两条语句都按照顺序申请了tbla、tblc上锁，但不同的是获取其他表明上的锁是在tblc之前还是之后
   
   # Metadata lock acquisition order can make a difference in operation outcome when multiple transactions execute concurrently, as the following example illustrates.
   》 当多个事务并发执行时，元数据锁获取顺序会对操作结果产生影响，如下面的例子所示。
   
   # Begin with two tables x and x_new that have identical structure. Three clients issue statements that involve these tables:
   》 从具有相同结构的两个表x和x_new开始。三个客户端发出的语句涉及这些表:

   # Client 1:
     LOCK TABLE x WRITE, x_new WRITE;
     > The statement requests and acquires write locks in name order on x and x_new.
     >> 该语句按照名称顺序对x和x_new请求和获取写锁。
   
   # Client 2:
     INSERT INTO x VALUES(1);
     > The statement requests and blocks waiting for a write lock on x.
     >> 语句请求并阻塞等待x上的写锁。
   
   # Client 3:
     RENAME TABLE x TO x_old, x_new TO x;
     > The statement requests exclusive locks in name order on x, x_new, and x_old, but blocks waiting for the lock on x.
     >> 该语句按名称顺序请求x、x_new和x_old上的排他锁，但阻塞等待x上的锁。
   
   # Client 1:
      UNLOCK TABLES;
  
    The statement releases the write locks on x and x_new. The exclusive lock request for x by Client 3 has higher priority than the write lock request by Client 2, so Client 3 acquires its lock on x, then also on x_new and x_old, performs the renaming, and releases its locks. Client 2 then acquires its lock on x, performs the insert, and releases its lock.
    > 该语句释放x、x_new上的写锁。Client3获取独占锁的请求比Client2的写锁具有更高的优先级，所以Client3获取到了在x上的锁，然后也获得x_new、x_old上的锁。执行重命名并且释放锁，然后，Client2获取到x上的锁，执行插入操作并释放锁。

  # Lock acquisition order results in the RENAME TABLE executing before the INSERT. The x into which the insert occurs is the table that was named x_new when Client 2 issued the insert and was renamed to x by Client 3:
   > RENAME获取锁的顺序在INSERT之前，Client2进行插入操作的表"x"是x_new并被Client3重命名为Client 3;
   mysql> SELECT * FROM x;
   +------+
   | i    |
   +------+
   |    1 |
   +------+
   
   mysql> SELECT * FROM x_old;
   Empty set (0.01 sec)

```

#### Metadata Lock Release
&nbsp;&nbsp;To ensure transaction serializability, the server must not permit one session to perform a data definition language (DDL) statement on a table that is used in an uncompleted explicitly or implicitly started transaction in another session. The server achieves this by acquiring metadata locks on tables used within a transaction and deferring release of those locks until the transaction ends. A metadata lock on a table prevents changes to the table's structure. This locking approach has the implication that a table that is being used by a transaction within one session cannot be used in DDL statements by other sessions until the transaction ends.
> 为了确保事务的可序列化性，服务器一定不能允许一个会话对表执行数据定义语言(DDL)语句，而该表用于另一个会话中未完成的显式或隐式启动的事务。服务器通过获取事务中使用的表上的元数据锁并将这些锁的释放延迟到事务结束来实现这一点。表上的元数据锁防止对表结构的更改。这种锁定方法的含义是，一个会话中的事务正在使用的表在事务结束之前不能被其他会话在DDL语句中使用。

&nbsp;&nbsp;This principle applies not only to transactional tables, but also to nontransactional tables. Suppose that a session begins a transaction that uses transactional table t and nontransactional table nt as follows:
> 这一原则不仅适用于事务性表，也适用于非事务性表。假设一个会话开始了一个使用事务表t和非事务表nt的事务，如下所示:
```sql
   START TRANSACTION;
   SELECT * FROM t;
   SELECT * FROM nt;
```
&nbsp;&nbsp;The server holds metadata locks on both t and nt until the transaction ends. If another session attempts a DDL or write lock operation on either table, it blocks until metadata lock release at transaction end. For example, a second session blocks if it attempts any of these operations:
> 服务器同时持有t和nt上的元数据锁，直到事务结束。如果另一个会话试图对任意一个表执行DDL或写锁操作，它将阻塞，直到事务结束时释放元数据锁。例如，如果第二个会话尝试以下任何操作，则会阻塞:
 ```sql
   DROP TABLE t;
   ALTER TABLE t ...;
   DROP TABLE nt;
   ALTER TABLE nt ...;
   LOCK TABLE t ... WRITE;
 ```

&nbsp;&nbsp;The same behavior applies for The LOCK TABLES ... READ. That is, explicitly or implicitly started transactions that update any table (transactional or nontransactional) block and are blocked by LOCK TABLES ... READ for that table.
> 相同的行为适用于 LOCK TABLES ... READ。 换句话说，显式或隐式开启事务更新任何表并被LOCK TABLES ... READ阻塞???

&nbsp;&nbsp;If the server acquires metadata locks for a statement that is syntactically valid but fails during execution, it does not release the locks early. Lock release is still deferred to the end of the transaction because the failed statement is written to the binary log and the locks protect log consistency.
> 如果服务器为一个语法有效但在执行过程中失败的语句获取元数据锁，它不会提前释放锁。锁释放仍然延迟到事务结束，因为失败的语句被写入二进制日志，锁保护了日志的一致性。

&nbsp;&nbsp;In autocommit mode, each statement is in effect a complete transaction, so metadata locks acquired for the statement are held only to the end of the statement.
> 在自动提交模式下，每条语句实际上都是一个完整的事务，因此为该语句获取的元数据锁只持有到语句结束。

&nbsp;&nbsp;Metadata locks acquired during a PREPARE statement are released once the statement has been prepared, even if preparation occurs within a multiple-statement transaction.
> 在PREPARE语句中获得的元数据锁在语句准备完成后被释放，即使准备发生在多语句事务中。

#### Metadata Lock解决了什么问题？

---

## 参考资料
1. [14.13.1 Online DDL Operations](https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-operations.html) 
2. MySQL-5.7-Reference-Manual-14.13.1-Online-DDL-Operations.pdf (即官方文档)