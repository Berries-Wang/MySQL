# Buffer Pool
&nbsp;&nbsp;The buffer pool is an area in main memory where InnoDB caches table and index data as it is accessed. The buffer pool permits frequently used data to be accessed directly from memory, which speeds up processing. On dedicated servers, up to 80% of physical memory is often assigned to the buffer pool.(缓冲池是主内存中的一个区域，InnoDB在访问表和索引数据时将在这里缓存数据。缓冲池允许频繁使用的数据直接从内存中访问，这加快了处理速度。在专用服务器上，高达80%的物理内存通常分配给缓冲池。)

&nbsp;&nbsp;For efficiency of high-volume read operations, the buffer pool is divided into pages that can potentially hold multiple rows. For efficiency of cache management, the buffer pool is implemented as a linked list of pages; data that is rarely used is aged out of the cache using a variation of the least recently used (LRU) algorithm.(为了提高大容量读操作的效率，缓冲池被划分为可以容纳多行数据的页。为提高缓存管理的效率，缓冲池实现为页的链表。很少使用的数据使用最近最少使用(least recently used, LRU)算法的变体从缓存中老化。)

&nbsp;&nbsp;Knowing how to take advantage<sup>有利条件，优势；优点；利益；（局末平分后）占先，优势分</sup> of the buffer pool to keep frequently accessed data in memory is an important aspect of MySQL tuning.(了解如何利用缓冲池将频繁访问的数据保存在内存中是MySQL调优的一个重要方面。)

## Buffer Pool LRU Algorithm
&nbsp;&nbsp;The buffer pool is managed as a list using a variation of the LRU algorithm. When room is needed to add a new page to the buffer pool, the least recently used page is evicted and a new page is added to the middle of the list. This midpoint insertion strategy treats the list as two sublists:(缓冲池使用LRU算法的一种变体作为一个链表来管理。在需要空间向缓冲池添加新页时，会将最近最少使用的页清除，并将新页添加到列表的中间。这种中点插入策略将列表视为两个子列表:)
- At the head, a sublist of new (“young”) pages that were accessed recently(在头部，是最近访问过的新(“年轻”)页的子列表)
- At the tail, a sublist of old pages that were accessed less recently(尾部是最近访问次数较少的旧页的子链表)

&nbsp;&nbsp; **Buffer Pool List**
> <img src="./../pics/innodb-buffer-pool-list.png"/>

>> evicted: 驱逐

&nbsp;&nbsp;The algorithm keeps frequently used pages in the new sublist. The old sublist contains less frequently used pages; these pages are candidates for eviction.(该算法将经常使用的页保存在新的子链表中。旧的子列表包含不常用的页。这些页面是被驱逐的候选者。)

&nbsp;&nbsp;By default, the algorithm operates as follows:
- 3/8 of the buffer pool is devoted to the old sublist.(缓冲池的3/8用于旧的子列表。)
- The midpoint of the list is the boundary where the tail of the new sublist meets the head of the old sublist.(列表的midpoint是新子列表的尾部与旧子列表的头部的边界。)
- When InnoDB reads a page into the buffer pool, it initially inserts it at the midpoint (the head of the old sublist). A page can be read because it is required for a user-initiated operation such as an SQL query, or as part of a read-ahead operation performed automatically by InnoDB.(当InnoDB读入一个页到缓冲池时，它首先将它插入到midpoint位置(旧子列表的头部)。页面可以被读取，因为它是用户发起操作(如SQL查询)所必需的，或者是由InnoDB自动执行的预读操作的一部分。)
  > 为什么新数据是放在midpoint,而不是 New Sublist 的Head处?
- Accessing a page in the old sublist makes it “young”, moving it to the head of the new sublist. If the page was read because it was required by a user-initiated operation, the first access occurs immediately and the page is made young. If the page was read due to a read-ahead operation, the first access does not occur immediately and might not occur at all before the page is evicted.(访问旧子列表中的页面会使其“年轻”，将其移动到新子列表的头部。如果读取该页是因为用户发起的操作需要，那么第一次访问将立即发生，该页将被设置为年轻页。如果该页是由于预读操作读取的，第一次访问不会立即发生，在该页被逐出之前可能根本不会发生。)
- As the database operates, pages in the buffer pool that are not accessed “age” by moving toward the tail of the list. Pages in both the new and old sublists age as other pages are made new. Pages in the old sublist also age as pages are inserted at the midpoint. Eventually, a page that remains unused reaches the tail of the old sublist and is evicted.(当数据库运行时，缓冲池中未被访问的页通过向列表的尾部移动来“老化”。新旧子列表中的页都会随着其他页的更新而老化。旧子链表中的页也会老化，因为页是在中间位置插入的。最终，剩余未使用的页到达旧子列表的尾部并被移除。)

&nbsp;&nbsp;By default, pages read by queries are immediately moved into the new sublist, meaning they stay in the buffer pool longer. A table scan, performed for a mysqldump operation or a SELECT statement with no WHERE clause, for example, can bring a large amount of data into the buffer pool and evict an equivalent amount of older data, even if the new data is never used again. Similarly, pages that are loaded by the read-ahead background thread and accessed only once are moved to the head of the new list. These situations can push frequently used pages to the old sublist where they become subject to eviction. For information about optimizing this behavior, see Section 15.8.3.3, “Making the Buffer Pool Scan Resistant”, and Section 15.8.3.4, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)”.









## 参考资料
1. [https://dev.mysql.com/doc/refman/8.2/en/innodb-buffer-pool.html](https://dev.mysql.com/doc/refman/8.2/en/innodb-buffer-pool.html)