#  Change Buffer
## 摘要
1. Change Buffer 是用于二级索引（辅助索引）的
2. Change Buffer 仅用于数据不在Buffer Pool中的页。
3. Change Buffer 会在数据页读取到Buffer Pool中时发生合并。
4. Change Buffer 的目的是为了避免大量的随机I/O
5. 当索引是降序的，则无法使用Change Buffer
6. Change Buffer 存在内存(Buffer Pool)&磁盘(共享表空间)上
7. 调整Change Buffer的大小
   - 因为Change Buffer 是Buffer Pool的一部分，若Change Buffer太大，则会导致页面会提前从Buffer Pool中老化。
8. Change Buffer 刷入磁盘的机制，参考: [003.MySQL事务/006.InnoDB事务日志/006.Change-Buffer.md](../../../003.MySQL事务/006.InnoDB事务日志/006.Change-Buffer.md)

---

## 文档
&nbsp;&nbsp;The change buffer is a special data structure that caches changes to secondary index pages when those pages are not in the buffer pool. The buffered changes, which may result from INSERT, UPDATE, or DELETE operations (DML), are merged later when the pages are loaded into the buffer pool by other read operations.('change buffer'是一种特殊的数据结构，当二级索引页不在缓冲池中时<sup><font color='red'>针对于二级索引</font></sup>，它将更改缓存到这些页。被缓冲的更改可能来自插入、更新或删除操作(DML)，稍后在其他读操作将页加载到缓冲池时进行合并。)

> <img src="./../pics/innodb-change-buffer.png" alt=" Change Buffer"/>

> > periodic: 阶段性地；定期地

&nbsp;&nbsp;Unlike clustered indexes, secondary indexes are usually nonunique, and inserts into secondary indexes happen in a relatively random order. Similarly, deletes and updates may affect secondary index pages that are not adjacently located in an index tree. Merging cached changes at a later time, when affected pages are read into the buffer pool by other operations, avoids substantial random access I/O that would be required to read secondary index pages into the buffer pool from disk.(与聚集索引不同，辅助索引通常不是唯一的，向辅助索引插入数据的顺序是相对随机的。类似地，删除和更新可能会影响不在索引树中相邻位置的辅助索引页。稍后，当其他操作将受影响的页读入缓冲池时，合并缓存的更改，可以避免将辅助索引页从磁盘读入缓冲池时所需的大量随机I/O访问。<sup><font color='red'>辅助索引（二级索引）不是连续的，所以尽可能地避免随机I/O</font></sup>) 

&nbsp;&nbsp;Periodically<sup>adv.定期地，周期性地；偶尔，间歇</sup>, the purge operation that runs when the system is mostly idle, or during a slow shutdown, writes the updated index pages to disk. The purge operation can write disk blocks for a series of index values more efficiently than if each value were written to disk immediately.(在系统基本空闲或缓慢关闭期间运行的清除操作会定期将更新的索引页写入磁盘。与立即将每个值写入磁盘相比，清除操作可以更有效地将一系列索引值写入磁盘块。)

&nbsp;&nbsp;Change buffer merging may take several hours when there are many affected rows and numerous secondary indexes to update. During this time, disk I/O is increased, which can cause a significant slowdown for disk-bound queries. Change buffer merging may also continue to occur after a transaction is committed, and even after a server shutdown and restart (see [Section 15.21.3, “Forcing InnoDB Recovery”](https://dev.mysql.com/doc/refman/8.2/en/forcing-innodb-recovery.html) for more information).(当有许多受影响的行和许多辅助索引需要更新时，'change buffer' 合并可能需要几个小时。在此期间，磁盘I/O会增加，这可能会导致磁盘绑定查询的显著减速。在事务提交之后，甚至在服务器关闭和重启之后(更多信息请参见15.21.3节)，变更缓冲区的合并也可能继续发生。)

&nbsp;&nbsp;In memory, the change buffer occupies part of the buffer pool. On disk, the change buffer is part of the system tablespace, where index changes are buffered when the database server is shut down.(在内存中，'change buffer'占据了缓冲池的一部分。在磁盘上，'change buffer'是系统表空间的一部分，当数据库服务器关闭时，索引更改将在其中缓存。<sup><font color='red'>分布于缓冲池(内存) 和 系统表空间(磁盘)</font></sup>)

&nbsp;&nbsp;The type of data cached in the change buffer is governed by the innodb_change_buffering variable. For more information, see [Configuring Change Buffering](https://dev.mysql.com/doc/refman/8.2/en/innodb-change-buffer.html#innodb-change-buffer-configuration). You can also configure the maximum change buffer size. For more information, see [Configuring the Change Buffer Maximum Size](https://dev.mysql.com/doc/refman/8.2/en/innodb-change-buffer.html#innodb-change-buffer-maximum-size).(缓存在'change buffer'中的数据类型由innodb_change_buffer变量控制。有关更多信息，请参见配置更改缓冲。您还可以配置最大更改缓冲区大小。有关更多信息，请参见配置更改缓冲区最大大小。)

&nbsp;&nbsp;Change buffering is not supported for a secondary index if the index contains a descending index column or if the primary key includes a descending index column.(如果索引包含降序索引列，或者主键包含降序索引列，则不支持辅助索引的更改缓冲<sup>Change Buffer 无法使用的场景</sup>)

### Configuring Change Buffering
&nbsp;&nbsp;When INSERT, UPDATE, and DELETE operations are performed on a table, the values of indexed columns (particularly the values of secondary keys) are often in an unsorted order, requiring substantial<sup>adj.大量的，价值巨大的；</sup> I/O to bring secondary indexes up to date.  The change buffer caches changes to secondary index entries when the relevant page is not in the buffer pool, thus avoiding expensive I/O operations by not immediately reading in the page from disk.  The buffered changes are merged when the page is loaded into the buffer pool, and the updated page is later flushed to disk.  The InnoDB main thread merges buffered changes when the server is nearly idle, and during a slow shutdown.(当在表上执行INSERT、UPDATE和DELETE操作时，索引列的值(特别是辅助键的值)通常是无序的，需要大量的I/O来更新辅助索引。当相关页不在缓冲池中时，change buffer 缓存缓存辅助索引项的修改，从而通过不立即从磁盘读取页来避免昂贵的I/O操作。在页面加载到缓冲池时，将合并缓冲的更改，更新后的页面稍后刷写到磁盘。InnoDB主线程在服务器几乎空闲和缓慢关闭期间合并缓冲的更改。)<sup><font color="red">Change Buffer: 什么是合并缓存? 什么时候刷入到磁盘</font><sup>

&nbsp;&nbsp;Because it can result in fewer disk reads and writes, change buffering is most valuable for workloads that are I/O-bound; for example, applications with a high volume of DML operations such as bulk inserts benefit from change buffering.(因为它可以减少磁盘读写，所以change buffer对于 I/O 绑定的工作负载最有价值;例如，具有大量DML操作(如批量插入)的应用程序可以从更改缓冲中获益。)

&nbsp;&nbsp;However, the change buffer occupies a part of the buffer pool, reducing the memory available to cache data pages. If the working set almost fits in the buffer pool, or if your tables have relatively few secondary indexes, it may be useful to disable change buffering. If the working data set fits entirely within the buffer pool, change buffering does not impose extra overhead, because it only applies to pages that are not in the buffer pool.(但是，更改缓冲区占据了缓冲池的一部分，减少了可用来缓存数据页的内存。如果工作集几乎可以容纳到缓冲池中，或者表的辅助索引相对较少，那么禁用更改缓冲可能会很有用。如果工作数据集完全位于缓冲池中，那么change buffer不会带来额外的开销，因为它只适用于不在缓冲池中的页。)<sup><font color="red">Change Buffer 仅用于不在Buffer Pool中的页</font><sup>

&nbsp;&nbsp;The innodb_change_buffering variable controls the extent to which InnoDB performs change buffering. You can enable or disable buffering for inserts, delete operations (when index records are initially marked for deletion) and purge operations (when index records are physically deleted). An update operation is a combination of an insert and a delete. The default innodb_change_buffering value is all.（变量innodb_change_buffering控制InnoDB执行更改缓冲的范围。您可以为插入、删除操作(当索引记录最初被标记为删除时)和清除操作(当索引记录被物理删除时)启用或禁用缓冲。更新操作是插入操作和删除操作的组合。默认的innodb_change_buffer值为all。）
+ all
  - The default value: buffer inserts, delete-marking operations, and purges(清洗).
+ none
  - Do not buffer any operations.
+ inserts
  - Buffer insert operations.
+ deletes
  - Buffer delete-marking operations.
+ changes
  - Buffer both inserts and delete-marking operations.
+ purges
  - Buffer the physical deletion operations that happen in the background.

### Configuring the Change Buffer Maximum Size
&nbsp;&nbsp;The innodb_change_buffer_max_size variable permits configuring the maximum size of the change buffer as a percentage of the total size of the buffer pool. By default, innodb_change_buffer_max_size is set to 25. The maximum setting is 50.(innodb_change_buffer_max_size变量允许配置变更缓冲区的最大大小，占缓冲池总大小的百分比。默认情况下，innodb_change_buffer_max_size设置为25。最大设置为50。)

&nbsp;&nbsp;Consider increasing innodb_change_buffer_max_size on a MySQL server with heavy insert, update, and delete activity, where change buffer merging does not keep pace with new change buffer entries, causing the change buffer to reach its maximum size limit.(考虑增加innodb_change_buffer_max_size在MySQL服务器上有大量的插入，更新和删除活动，其中更改缓冲区合并不与新的更改缓冲区条目保持同步，导致更改缓冲区达到其最大大小限制。)

&nbsp;&nbsp;Consider decreasing innodb_change_buffer_max_size on a MySQL server with static data used for reporting, or if the change buffer consumes too much of the memory space shared with the buffer pool, causing pages to age out of the buffer pool sooner than desired.(考虑在MySQL服务器上减少用于报告的静态数据的innodb_change_buffer_max_size，或者如果更改缓冲区占用了太多与缓冲池共享的内存空间，导致页面提前从缓冲池中老化。)

&nbsp;&nbsp;Test different settings with a representative workload to determine an optimal configuration. The innodb_change_buffer_max_size variable is dynamic, which permits modifying the setting without restarting the server.(使用具有代表性的工作负载测试不同的设置，以确定最佳配置。innodb_change_buffer_max_size变量是动态的，它允许在不重启服务器的情况下修改设置。)

### Monitoring the Change Buffer
&nbsp;&nbsp;The following options are available for change buffer monitoring:(以下变量可以用于监控change buffer)

+ InnoDB Standard Monitor output includes change buffer status information. To view monitor data, issue the SHOW ENGINE INNODB STATUS statement.
  ```sql
       mysql> SHOW ENGINE INNODB STATUS\G
  ```
  - Change buffer status information is located under the INSERT BUFFER AND ADAPTIVE HASH INDEX heading and appears similar to the following:(更改缓冲区状态信息位于插入缓冲区和自适应散列索引标题下，看起来类似于以下内容)
  ```txt
    -------------------------------------
    INSERT BUFFER AND ADAPTIVE HASH INDEX
    -------------------------------------
    Ibuf: size 1, free list len 0, seg size 2, 0 merges
    merged operations:
     insert 0, delete mark 0, delete 0
    discarded operations:
     insert 0, delete mark 0, delete 0
    Hash table size 4425293, used cells 32, node heap has 1 buffer(s)
    13577.57 hash searches/s, 202.47 non-hash searches/s
  ```

+ The Information Schema INNODB_METRICS table provides most of the data points found in InnoDB Standard Monitor output plus other data points. To view change buffer metrics and a description of each, issue the following query:
  ```sql
      mysql> SELECT NAME, COMMENT FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME LIKE '%ibuf%'\G
  ```

+ The Information Schema INNODB_BUFFER_PAGE table provides metadata about each page in the buffer pool, including change buffer index and change buffer bitmap pages. Change buffer pages are identified by PAGE_TYPE. IBUF_INDEX is the page type for change buffer index pages, and IBUF_BITMAP is the page type for change buffer bitmap pages.
   - For example, you can query the INNODB_BUFFER_PAGE table to determine the approximate number of IBUF_INDEX and IBUF_BITMAP pages as a percentage of total buffer pool pages.
     ```sql
      mysql> SELECT (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE
        WHERE PAGE_TYPE LIKE 'IBUF%') AS change_buffer_pages,
        (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE) AS total_pages,
        (SELECT ((change_buffer_pages/total_pages)*100))
        AS change_buffer_page_percentage;
      +---------------------+-------------+-------------------------------+
      | change_buffer_pages | total_pages | change_buffer_page_percentage |
      +---------------------+-------------+-------------------------------+
      |                  25 |        8192 |                        0.3052 |
      +---------------------+-------------+-------------------------------+
     ```
+ Performance Schema provides change buffer mutex wait instrumentation<sup>n.使用仪器；乐器法；仪表化</sup> for advanced performance monitoring. To view change buffer instrumentation, issue the following query:(性能模式下的可视化监控)
   ```sql
      mysql> SELECT * FROM performance_schema.setup_instruments
       WHERE NAME LIKE '%wait/synch/mutex/innodb/ibuf%';
      +-------------------------------------------------------+---------+-------+
      | NAME                                                  | ENABLED | TIMED |
      +-------------------------------------------------------+---------+-------+
      | wait/synch/mutex/innodb/ibuf_bitmap_mutex             | YES     | YES   |
      | wait/synch/mutex/innodb/ibuf_mutex                    | YES     | YES   |
      | wait/synch/mutex/innodb/ibuf_pessimistic_insert_mutex | YES     | YES   |
      +-------------------------------------------------------+---------+-------+
   ```

---

## 参考资料
- [https://dev.mysql.com/doc/refman/8.2/en/innodb-change-buffer.html](https://dev.mysql.com/doc/refman/8.2/en/innodb-change-buffer.html)
- [003.MySQL事务/006.InnoDB事务日志/006.Change-Buffer.md](../../../003.MySQL事务/006.InnoDB事务日志/006.Change-Buffer.md)
- [InnoDB Change Buffer FAQ](https://dev.mysql.com/doc/refman/8.2/en/faqs-innodb-change-buffer.html)