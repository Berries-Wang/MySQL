# MySQL InnoDB意向锁
### 总结一下
1. 即意向锁主要是用来标识该表中是否存在行级锁

## 简要
&nbsp;&nbsp;InnoDB 支持多粒度锁（multiple granularity locking），它允许行级锁与表级锁共存，而意向锁就是其中的一种表锁。

&nbsp;&nbsp;意向锁是一种**不与行级锁冲突表级锁**，这一点非常重要。意向锁分为两种:
1. 意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁）
    - 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。
2. 意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁）
    - 事务要获取某些行的 X 锁，必须先获得表的 IX 锁

&nbsp;&nbsp;意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。即意向锁的主要目的是表明有人正在锁定一行或者打算锁定表中的一行。

## 意向锁解决的问题
&nbsp;&nbsp;如果另一个任务试图在该表级别上应用共享或排它锁，则受到由第一个任务控制的表级别意向锁的阻塞。第二个任务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。怎么理解呢？如下
 + 有一张表： MySql，InnoDB，Repeatable-Read：users（id PK，name）
    |id|name|
    |---|---|
    |1|ROADHOG|
    |2|Reinhardt|
    |3|Tracer|
    |4|Genji|
    |5|Hanzo|
    |6|Mccree|

    1. 事务A获取了某一行的排他锁，并未提交
        - select * from users where id = 6 for update;
    2. 事务B想获取users表的表锁： lock tables user read;
    3. 因为共享锁与排他锁互斥，所以事务 B 在视图对 users 表加共享锁的时候，必须保证：
       1. 当前没有其他事务持有 users 表的排他锁。
       2. 当前没有其他事务持有 users 表中任意一行的排他锁 
       > 为了检测是否满足第二个条件，事务 B 必须在确保 users表不存在任何排他锁的前提下，去检测表中的每一行是否存在排他锁。很明显这是一个效率很差的做法，但是有了意向锁之后，情况就不一样了：

## 锁兼容性
||意向共享锁（IS）|意向排他锁（IX）|
|---|---|---|
|意向共享锁（IS）|兼容|兼容|
|意向排他锁（IX）|兼容|兼容|

||意向共享锁（IS）|意向排他锁（IX）|
|---|---|---|
|共享锁（S）|兼容|互斥|
|排他锁（X）|互斥|互斥|
## 注意事项
1. 意向锁不会和**行级**的共享/排他锁互斥