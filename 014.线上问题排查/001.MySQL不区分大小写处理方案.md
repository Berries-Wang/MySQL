# MySQL 不区分大小写处理方案
## 背景
&nbsp;&nbsp;线上业务执行一段时间后，发现了一个Bug，两个用户的buyer_open_id基本一致，只有一个字母是大小写不一致的，如:
```txt
       AAE147H3ALfNdtRyui2yLSBK
       AAE147H3ALfNdtRyui2YLSBk
       > 如上两个buyer_open_id ,只有一个'Y'大小写不一致。
```
&nbsp;&nbsp;导致了两个用户的数据的错乱。
## 解决方案
```sql
    # env: 5.7.34-debug
    # 测试表创建
    mysql> show create table case_insensitive_summarize_data\G
    *************************** 1. row ***************************
           Table: case_insensitive_summarize_data
    Create Table: CREATE TABLE `case_insensitive_summarize_data` (
      `id` bigint(20) NOT NULL AUTO_INCREMENT,
      `gmt_create` datetime NOT NULL,
      `gmt_modified` datetime NOT NULL,
      `a` varchar(60) COLLATE utf8mb4_unicode_ci NOT NULL,
      `b` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
      `c` varchar(60) COLLATE utf8mb4_unicode_ci NOT NULL,
      `d` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
      PRIMARY KEY (`id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci

    # 造数据
    public void makeCaseInsensitiveSummarizeData() {
        System.out.println("数据开始创建...");
        int count = 0;
        while (count < 100000) {
            CaseInsensitiveSummarizeData data = new CaseInsensitiveSummarizeData();
            String uuid = UUID.randomUUID().toString().replace("-", "");
            data.setA(uuid + "A");
            data.setB(uuid + 'B');
            data.setC(uuid + "C");
            data.setD(uuid + 'D');
            caseInsensitiveSummarizeDataMakeService.makeCaseInsensitiveSummarizeData(data);


            CaseInsensitiveSummarizeData data2 = new CaseInsensitiveSummarizeData();
            data2.setA(uuid + "a");
            data2.setB(uuid + 'b');
            data2.setC(uuid + "c");
            data2.setD(uuid + 'd');
            caseInsensitiveSummarizeDataMakeService.makeCaseInsensitiveSummarizeData(data2);

            count++;
        }

        System.out.println("数据创建完成");
    }

    @Transactional
    public void makeCaseInsensitiveSummarizeData(CaseInsensitiveSummarizeData data) {
        jdbcTemplate.update(String.format("INSERT INTO case_insensitive_summarize_data(gmt_create,gmt_modified,a,b,c,d) VALUES(NOW(),NOW(),'%s','%s','%s','%s');", data.getA(), data.getB(), data.getC(), data.getD()));
    }

```
### 治本：排序规则设置为'utf8mb4_bin' OR 'utf8mb4_0900_bin'(从MySQL 8.0.17支持)
```sql
 # 通过a字段查询，能查询出两条数据
 mysql> select * from case_insensitive_summarize_data where a ='3a02547b28b645c48bbbc5f352a14981A';
 +----+---------------------+---------------------+-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------+
 | id | gmt_create          | gmt_modified        | a                                 | b                                 | c                                 | d                                 |
 +----+---------------------+---------------------+-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------+
 |  3 | 2023-11-16 01:06:50 | 2023-11-16 01:06:50 | 3a02547b28b645c48bbbc5f352a14981A | 3a02547b28b645c48bbbc5f352a14981B | 3a02547b28b645c48bbbc5f352a14981C | 3a02547b28b645c48bbbc5f352a14981D |
 |  4 | 2023-11-16 01:06:50 | 2023-11-16 01:06:50 | 3a02547b28b645c48bbbc5f352a14981a | 3a02547b28b645c48bbbc5f352a14981b | 3a02547b28b645c48bbbc5f352a14981c | 3a02547b28b645c48bbbc5f352a14981d |
 +----+---------------------+---------------------+-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------+
 2 rows in set (1.34 sec)

 # 通过b字段查询，b字段的排序规则为 utf8mb4_bin ，因此只能查询出一条数据。
 mysql> select * from case_insensitive_summarize_data where b = '3a02547b28b645c48bbbc5f352a14981b';
 +----+---------------------+---------------------+-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------+
 | id | gmt_create          | gmt_modified        | a                                 | b                                 | c                                 | d                                 |
 +----+---------------------+---------------------+-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------+
 |  4 | 2023-11-16 01:06:50 | 2023-11-16 01:06:50 | 3a02547b28b645c48bbbc5f352a14981a | 3a02547b28b645c48bbbc5f352a14981b | 3a02547b28b645c48bbbc5f352a14981c | 3a02547b28b645c48bbbc5f352a14981d |
 +----+---------------------+---------------------+-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------+
 1 row in set (1.32 sec)
```

### 治标：仅查询,给字段加上'binary'
```sql
  # 如下，在查询时添加上 binary , 也能使得大小写敏感，从而查询出一条数据。 那么有个问题，使用了binary还会走索引吗? 
  mysql> select * from case_insensitive_summarize_data where a = binary '3a02547b28b645c48bbbc5f352a14981A';
  +----+---------------------+---------------------+-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------+
  | id | gmt_create          | gmt_modified        | a                                 | b                                 | c                                 | d                                 |
  +----+---------------------+---------------------+-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------+
  |  3 | 2023-11-16 01:06:50 | 2023-11-16 01:06:50 | 3a02547b28b645c48bbbc5f352a14981A | 3a02547b28b645c48bbbc5f352a14981B | 3a02547b28b645c48bbbc5f352a14981C | 3a02547b28b645c48bbbc5f352a14981D |
  +----+---------------------+---------------------+-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------+
  1 row in set (1.31 sec)

  # 给表添加上索引
  mysql> create index idx_a on case_insensitive_summarize_data (a) using BTREE;
  Query OK, 0 rows affected (5.42 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  
  # 查询1：再次执行查询操作： 使用索引，性能较好
  mysql> desc select * from case_insensitive_summarize_data where a = '3a02547b28b645c48bbbc5f352a14981A';
  +----+-------------+---------------------------------+------------+------+---------------+-------+---------+-------+------+----------+-------+
  | id | select_type | table                           | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |
  +----+-------------+---------------------------------+------------+------+---------------+-------+---------+-------+------+----------+-------+
  |  1 | SIMPLE      | case_insensitive_summarize_data | NULL       | ref  | idx_a         | idx_a | 242     | const |    2 |   100.00 | NULL  |
  +----+-------------+---------------------------------+------------+------+---------------+-------+---------+-------+------+----------+-------+
  1 row in set, 1 warning (0.01 sec)
  
  # 查询2：从以下查询计划可知，如果在字段上使用binary，会导致性能的损失,见: [006.MySQL查询优化与调优工具集/001.MySQL查询优化之explain.md]
  mysql> desc select * from case_insensitive_summarize_data where a = binary '3a02547b28b645c48bbbc5f352a14981A';
  +----+-------------+---------------------------------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
  | id | select_type | table                           | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |
  +----+-------------+---------------------------------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
  |  1 | SIMPLE      | case_insensitive_summarize_data | NULL       | range | idx_a         | idx_a | 242     | NULL |    2 |   100.00 | Using index condition |
  +----+-------------+---------------------------------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
  1 row in set, 2 warnings (0.00 sec)
  
  # 查询3：对比查询1、2、3这几个查询计划，发现，保持原样SQL不变，在条件中添加“a = binary '3a02547b28b645c48bbbc5f352a14981A'”，能在保证性能的基础下兼顾大小写敏感。
  # 怎么理解呢? where a = '3a02547b28b645c48bbbc5f352a14981A' 还是使用了idx_a索引的，即过滤掉了大部分数据。
  # 由MySQL工作原理可知，MySQL Server会在存储引擎返回的时候应用WHERE条件，此时（存储引擎使用索引且返回符合条件的数据后）加上 a = binary '3a02547b28b645c48bbbc5f352a14981A'条件，
  # 只需要判断很少一部分数据，因此性能损耗也是最少的。(可参见附录的‘查询计划’)
  mysql> desc select * from case_insensitive_summarize_data where a = binary '3a02547b28b645c48bbbc5f352a14981A' and a = '3a02547b28b645c48bbbc5f352a14981A';
  +----+-------------+---------------------------------+------------+------+---------------+-------+---------+-------+------+----------+-------+
  | id | select_type | table                           | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |
  +----+-------------+---------------------------------+------------+------+---------------+-------+---------+-------+------+----------+-------+
  |  1 | SIMPLE      | case_insensitive_summarize_data | NULL       | ref  | idx_a         | idx_a | 242     | const |    2 |   100.00 | NULL  |
  +----+-------------+---------------------------------+------------+------+---------------+-------+---------+-------+------+----------+-------+
  1 row in set, 2 warnings (0.03 sec)
  
  mysql> 
  
  # 如果直接在排序规则为 'utf8mb4_bin' 上建索引呢？
  create index idx_b on case_insensitive_summarize_data (b) using BTREE;
  查询4：
  mysql> explain select * from case_insensitive_summarize_data where b = '3a02547b28b645c48bbbc5f352a14981b';
  +----+-------------+---------------------------------+------------+------+---------------+-------+---------+-------+------+----------+-------+
  | id | select_type | table                           | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |
  +----+-------------+---------------------------------+------------+------+---------------+-------+---------+-------+------+----------+-------+
  |  1 | SIMPLE      | case_insensitive_summarize_data | NULL       | ref  | idx_b         | idx_b | 242     | const |    1 |   100.00 | NULL  |
  +----+-------------+---------------------------------+------------+------+---------------+-------+---------+-------+------+----------+-------+
  1 row in set, 1 warning (0.00 sec)
  
  mysql> 
 
 # 在a上如果需要建唯一索引呢?
  mysql> create unique index uk_a on case_insensitive_summarize_data (a) using BTREE;
  ERROR 1062 (23000): Duplicate entry '3a02547b28b645c48bbbc5f352a14981A' for key 'uk_a'
  mysql> 
  
 # 在b上建立唯一索引呢?
 mysql> create unique index uk_b on case_insensitive_summarize_data (b) using BTREE;
 Query OK, 0 rows affected (4.66 sec)
 Records: 0  Duplicates: 0  Warnings: 0
 mysql> 

```
## 总结
1. 如果需要在保证性能的前提下，保证大小写敏感，可以采用治标的方法。
2. 如果需要建唯一索引，那么采用治本的方法。

## 附录
### 执行计划
```txt
       mysql> desc format=json  select * from case_insensitive_summarize_data where a = 'dd471d91541c4da491b3ce746cbe63bdA' and a = binary 'dd471d91541c4da491b3ce746cbe63bdA'\G
       *************************** 1. row ***************************
       EXPLAIN: {
         "query_block": {
           "select_id": 1,
           "cost_info": {
             "query_cost": "2.40"
           },
           "table": {
             "table_name": "case_insensitive_summarize_data",
             "access_type": "ref",
             "possible_keys": [
               "idx_a"
             ],
             "key": "idx_a",
             "used_key_parts": [
               "a"
             ],
             "key_length": "242",
             "ref": [
               "const"
             ],
             "rows_examined_per_scan": 2,
             "rows_produced_per_join": 2,
             "filtered": "100.00",
             "cost_info": {
               "read_cost": "2.00",
               "eval_cost": "0.40",
               "prefix_cost": "2.40",
               "data_read_per_join": "1K"
             },
             "used_columns": [
               "id",
               "gmt_create",
               "gmt_modified",
               "a",
               "b",
               "c",
               "d"
             ]
           }
         }
       }
       1 row in set, 2 warnings (0.01 sec)
       
       
       mysql> desc format=json  select * from case_insensitive_summarize_data where a = 'dd471d91541c4da491b3ce746cbe63bdA' \G
       *************************** 1. row ***************************
       EXPLAIN: {
         "query_block": {
           "select_id": 1,
           "cost_info": {
             "query_cost": "2.40"
           },
           "table": {
             "table_name": "case_insensitive_summarize_data",
             "access_type": "ref",
             "possible_keys": [
               "idx_a"
             ],
             "key": "idx_a",
             "used_key_parts": [
               "a"
             ],
             "key_length": "242",
             "ref": [
               "const"
             ],
             "rows_examined_per_scan": 2,
             "rows_produced_per_join": 2,
             "filtered": "100.00",
             "cost_info": {
               "read_cost": "2.00",
               "eval_cost": "0.40",
               "prefix_cost": "2.40",
               "data_read_per_join": "1K"
             },
             "used_columns": [
               "id",
               "gmt_create",
               "gmt_modified",
               "a",
               "b",
               "c",
               "d"
             ]
           }
         }
       }
       1 row in set, 1 warning (0.00 sec)
       
       mysql> desc format=json  select * from case_insensitive_summarize_data where a = binary 'dd471d91541c4da491b3ce746cbe63bdA'\G
       *************************** 1. row ***************************
       EXPLAIN: {
         "query_block": {
           "select_id": 1,
           "cost_info": {
             "query_cost": "3.81"
           },
           "table": {
             "table_name": "case_insensitive_summarize_data",
             "access_type": "range",
             "possible_keys": [
               "idx_a"
             ],
             "key": "idx_a",
             "used_key_parts": [
               "a"
             ],
             "key_length": "242",
             "rows_examined_per_scan": 2,
             "rows_produced_per_join": 2,
             "filtered": "100.00",
             "index_condition": "(`stu`.`case_insensitive_summarize_data`.`a` = <cache>(cast('dd471d91541c4da491b3ce746cbe63bdA' as char charset binary)))", # look! 这里做了一次转换，参考附录 "Cast Function and Operator Descriptions "
             "cost_info": {
               "read_cost": "3.41",
               "eval_cost": "0.40",
               "prefix_cost": "3.81",
               "data_read_per_join": "1K"
             },
             "used_columns": [
               "id",
               "gmt_create",
               "gmt_modified",
               "a",
               "b",
               "c",
               "d"
             ]
           }
         }
       }
       1 row in set, 2 warnings (0.00 sec)    
```

### Unicode Character Sets 
#### utf8mb4
&nbsp;&nbsp;utf8mb4: A UTF-8 encoding of the Unicode character set using one to four bytes per character.

&nbsp;&nbsp;Most Unicode character sets have a general collation (indicated by _general in the name or by the absence of a language specifier), a binary collation (indicated by _bin in the name), and several language-specific collations (indicated by language specifiers). For example, for utf8mb4, utf8mb4_general_ci and utf8mb4_bin are its general and binary collations, and utf8mb4_danish_ci is one of its language-specific collations.(大多数Unicode字符集都有一个通用的排序规则)

&nbsp;&nbsp;Most character sets have a single binary collation. utf8mb4 is an exception that has two: utf8mb4_bin and (as of MySQL 8.0.17) utf8mb4_0900_bin. These two binary collations have the same sort order but are distinguished by their pad attribute and collating weight characteristics. （大多数字符集只有一个二进制排序规则，但是utf8mb4有两个）

##### _general_ci Versus _unicode_ci Collations
&nbsp;&nbsp;For any Unicode character set, operations performed using the xxx_general_ci collation are faster than those for the xxx_unicode_ci collation. For example, comparisons for the utf8mb4_general_ci collation are faster, but slightly less correct, than comparisons for utf8mb4_unicode_ci. The reason is that utf8mb4_unicode_ci supports mappings such as expansions; that is, when one character compares as equal to combinations of other characters. For example, ß is equal to ss in German and some other languages. utf8mb4_unicode_ci also supports contractions and ignorable characters. utf8mb4_general_ci is a legacy collation that does not support expansions, contractions, or ignorable characters. It can make only one-to-one comparisons between characters.(对于任何Unicode字符集，使用xxx_general_ci 排序规则比xxx_unicode_ci排序规则更快。例如，utf8mb4_general_ci比xxx_unicode_ci更快，但是稍微不太正确。原因是utf8mb4_unicode_ci支持拓展之类的映射。也就是一个字符和其他字符的组合进行等值比较。例如，在德语和其他语言中ß与ss相等。utf8mb4_unicode_ci也支持收缩和可忽略字符。utf8mb4_general_ci 是不支持展开、收缩和可忽略字符的排序规则。他只能在字符之间进行一对一的比较。)

### Cast Function and Operator Descriptions 
#### BINARY expr
&nbsp;&nbsp;The BINARY operator converts the expression to a binary string (a string that has the binary character set and binary collation). A common use for BINARY is to force a character string comparison to be done byte by byte using numeric byte values rather than character by character. The BINARY operator also causes trailing spaces in comparisons to be significant<sup>重要的</sup>. For information about the differences between the binary collation of the binary character set and the _bin collations of nonbinary character sets, see Section 10.8.5, “[The binary Collation Compared to _bin Collations](https://dev.mysql.com/doc/refman/8.0/en/charset-binary-collations.html)”. (BINARY 操作将表达式转换为二进制字符串(一个有着二进制字符集和二进制排序规则的字符串)。BINARY一个常见的用法就是使用数字字节强制一个字节一个字节地进行比较，而不是一个字符一个字符地进行比较。BINARY操作符还会使得比较中的尾随空格变得重要。关于有关二进制字符集的二进制排序与非二进制字符集的_bin排序之间差异的信息，见:[The binary Collation Compared to _bin Collations](https://dev.mysql.com/doc/refman/8.0/en/charset-binary-collations.html))

&nbsp;&nbsp;The BINARY operator is deprecated as of MySQL 8.0.27, and you should expect its removal in a future version of MySQL. Use CAST(... AS BINARY) instead<sup>顶替</sup>. (BINARY操作符在 8.0.27中被弃用，你应该期望他在后续的版本中移除，使用'CAST(... AS BINARY)(如上查询计划)'代替)

&nbsp;&nbsp;To convert a string expression to a binary string, these constructs are equivalent:
```sql
   CONVERT(expr USING BINARY)
   CAST(expr AS BINARY)
   BINARY expr
```

&nbsp;&nbsp;If a value is a string literal, it can be designated as a binary string without converting it by using the _binary character set introducer:(如果是字符串字面量，那可以将其指定为二进制字符串而不用_binary字符集转换器进行转换)
```sql
 mysql> SELECT 'a' = 'A';
         -> 1
 mysql> SELECT _binary 'a' = 'A';
         -> 0
```

### The binary Collation Compared to _bin Collations （MySQL 5.7）
&nbsp;&nbsp;This section describes how the binary collation for binary strings compares to _bin collations for nonbinary strings.（主要说明如何比较二进制字符串的二进制排序和非二进制字符串的_bin排序）

&nbsp;&nbsp;Binary strings (as stored using the BINARY, VARBINARY, and BLOB data types) have a character set and collation named binary. Binary strings are sequences of bytes and the numeric values of those bytes determine comparison and sort order. See Section 10.10.8, “The Binary Character Set”.（二进制字符串(使用INARY, VARBINARY, BLOB类型存储)有一个名字为binary的字符集和排序规则。二进制字符串时字节序列，这些字节的数值决定比较和排序规则）

&nbsp;&nbsp;Nonbinary strings (as stored using the CHAR, VARCHAR, and TEXT data types) have a character set and collation other than binary. A given nonbinary character set can have several collations, each of which defines a particular comparison and sort order for the characters in the set. For most character sets, one of these is the binary collation, indicated by a _bin suffix in the collation name. For example, the binary collations for latin1 and big5 are named latin1_bin and big5_bin, respectively. utf8mb4 is an exception that has two binary collations, utf8mb4_bin and utf8mb4_0900_bin; see Section 10.10.1, “Unicode Character Sets”.(非二进制字符串(使用CHAR, VARCHAR, TEXT类型存储)有一个除binary外的字符集和排序规则，一个给定的非二进制字符集有几个排序规则，其中每一个都为集合中的字符定义了特定的比较和排序顺序。对于大多数的字符集，其中之一就是二进制排序规则，排序规则名字使用_bin作为后缀。)

#### The Unit for Comparison and Sorting
&nbsp;&nbsp;Binary strings are sequences of bytes. For the binary collation, comparison and sorting are based on numeric byte values. Nonbinary strings are sequences of characters, which might be multibyte. Collations for nonbinary strings define an ordering of the character values for comparison and sorting. For _bin collations, this ordering is based on numeric character code values, which is similar to ordering for binary strings except that character code values might be multibyte.(二进制字符串是字节序列，对于二进制排序规则，比较和排序是基于字节值得数值。非二进制字符串是字符序列，字符或许是多字节。非二进制字符串的排序规则定义了字符的比较和排序规则。对于_bin排序规则，排序是基于字符的code值，除了字符代码值可能是多字节之外，这与二进制字符串排序类似)

---

#### Character Set Conversion
&nbsp;&nbsp;A nonbinary string has a character set and is automatically converted to another character set in many cases, even when the string has a _bin collation:(非二进制字符串有一个字符集并且在大多数情况下他都自动转为其他的字符集，即使字符串具有_bin排序规则)
+ When assigning column values to another column that has a different character set:
  ```sql
    UPDATE t1 SET utf8mb4_bin_column=latin1_column;
    INSERT INTO t1 (latin1_column) SELECT utf8mb4_bin_column FROM t2;
  ```
+ When assigning column values for INSERT or UPDATE using a string literal:
  ```sql
     SET NAMES latin1;
     INSERT INTO t1 (utf8mb4_bin_column) VALUES ('string-in-latin1');
  ```
+ When sending results from the server to a client:
  ```sql
    SET NAMES latin1;
    SELECT utf8mb4_bin_column FROM t2;
  ```

&nbsp;&nbsp;For binary string columns, no conversion occurs. For cases similar to those preceding, the string value is copied byte-wise.(对于二进制字符串列，不会发生转换，对于与上述类似的情况，将按字节复制字符串值)

---

#### Lettercase Conversion
&nbsp;&nbsp;Collations for nonbinary character sets provide information about lettercase of characters, so characters in a nonbinary string can be converted from one lettercase to another, even for _bin collations that ignore lettercase for ordering:(非二进制字符集排序规则提供字符大写的信息，因此，非二进制字符串中的字符可以从一种字母转换为另一种字母，尽管_bin排序规则在排序中忽略了大写)
```sql
    mysql> SET NAMES utf8mb4 COLLATE utf8mb4_bin;
    mysql> SELECT LOWER('aA'), UPPER('zZ');
    +-------------+-------------+
    | LOWER('aA') | UPPER('zZ') |
    +-------------+-------------+
    | aa          | ZZ          |
    +-------------+-------------+
```

&nbsp;&nbsp;The concept of lettercase does not apply to bytes in a binary string. To perform lettercase conversion, the string must first be converted to a nonbinary string using a character set appropriate(合适的) for the data stored in the string:(这种情况不会应用到二进制字符串的字节上。为了执行大写转换，字符串必须先转为合适字符集的非二进制字符串)
```sql
   mysql> SET NAMES binary;
   mysql> SELECT LOWER('aA'), LOWER(CONVERT('aA' USING utf8mb4));
   +-------------+------------------------------------+
   | LOWER('aA') | LOWER(CONVERT('aA' USING utf8mb4)) |
   +-------------+------------------------------------+
   | aA          | aa                                 |
   +-------------+------------------------------------+
```

---

#### Trailing Space Handling in Comparisons
&nbsp;&nbsp;Nonbinary strings have PAD SPACE behavior for all collations, including _bin collations. Trailing spaces are insignificant in comparisons: （非二进制字符串所有的排序规则都有空格填充属性，包括_bin排序规则。在比较中，尾部的空格是不重要的。）
```sql
  mysql> SET NAMES utf8 COLLATE utf8_bin;
  mysql> SELECT 'a ' = 'a';
  +------------+
  | 'a ' = 'a' |
  +------------+
  |          1 |
  +------------+
```

&nbsp;&nbsp;For binary strings, all bytes are significant<sup>重要的，意义重大的；</sup> in comparisons, including trailing spaces:（对于二进制字符串，所有字节在比较中都是重要的，包括尾部的空格）
```sql
    mysql> SET NAMES binary;
    mysql> SELECT 'a ' = 'a';
    +------------+
    | 'a ' = 'a' |
    +------------+
    |          0 |
    +------------+
```

##### 以下是MySQL8.0版本文档
&nbsp;&nbsp;MySQL collations have a pad attribute, which has a value of PAD SPACE or NO PAD:(MySQL 排序规则有填充属性，属性值有填充空格和无填充)
+ Most MySQL collations have a pad attribute of PAD SPACE.
+ The Unicode collations based on UCA 9.0.0 and higher have a pad attribute of NO PAD; see Section 10.10.1, “[Unicode Character Sets](https://dev.mysql.com/doc/refman/8.0/en/charset-unicode-sets.html)”.

&nbsp;&nbsp;For nonbinary strings (CHAR, VARCHAR, and TEXT values), the string collation pad attribute determines treatment in comparisons of trailing spaces at the end of strings:(非二进制字符串（CHAR, VARCHAR, TEXT的值），字符串排序规则的填充属性决定这尾部填充空格在比较中的处理方式)
+ For PAD SPACE collations, trailing spaces are insignificant<sup>微不足道的，无足轻重的</sup> in comparisons; strings are compared without regard<sup>关注</sup> to trailing spaces.(PAD SPACE 排序规则，尾部空格在比较重不重要；字符串比较不会关注尾部的空格)
+ NO PAD collations treat trailing spaces as significant in comparisons, like any other character. (NO PAD 排序规则，尾部空格在比较重很重要，像其他一样。)

&nbsp;&nbsp;The differing behaviors can be demonstrated<sup>证明，证实；展示</sup> using the two utf8mb4 binary collations, one of which is PAD SPACE, the other of which is NO PAD. The example also shows how to use the INFORMATION_SCHEMA COLLATIONS table to determine the pad attribute for collations.
```sql
        # Server version: 8.0.30-debug Source distribution
        mysql> SELECT COLLATION_NAME, PAD_ATTRIBUTE FROM INFORMATION_SCHEMA.COLLATIONS WHERE COLLATION_NAME LIKE 'utf8mb4%bin';
        +------------------+---------------+
        | COLLATION_NAME   | PAD_ATTRIBUTE |
        +------------------+---------------+
        | utf8mb4_bin      | PAD SPACE     |
        | utf8mb4_0900_bin | NO PAD        |
        +------------------+---------------+
        mysql> SET NAMES utf8mb4 COLLATE utf8mb4_bin;
        mysql> SELECT 'a ' = 'a';
        +------------+
        | 'a ' = 'a' |
        +------------+
        |          1 |
        +------------+
        mysql> SET NAMES utf8mb4 COLLATE utf8mb4_0900_bin;
        mysql> SELECT 'a ' = 'a';
        +------------+
        | 'a ' = 'a' |
        +------------+
        |          0 |
        +------------+
```

---

#### Trailing Space Handling for Inserts and Retrievals
&nbsp;&nbsp;CHAR(N) columns store nonbinary strings N characters long. For inserts, values shorter than N characters are extended with spaces. For retrievals, trailing spaces are removed.(非二进制字符串插入时会填充空格，检索数据时会移除空格)

&nbsp;&nbsp;BINARY(N) columns store binary strings N bytes long. For inserts, values shorter than N bytes are extended with 0x00 bytes. For retrievals, nothing is removed; a value of the declared length is always returned.(二进制字符串插入时会填充空格，检索数据时，则不会移除)
> 通过如下的例子，排序规则不会影响到这一点

```sql
      mysql> CREATE TABLE t1 (
               a CHAR(10) CHARACTER SET utf8 COLLATE utf8_bin,
               b BINARY(10)
             );
      mysql> INSERT INTO t1 VALUES ('x','x');
      mysql> INSERT INTO t1 VALUES ('x ','x ');
      mysql> SELECT a, b, HEX(a), HEX(b) FROM t1;
      +------+------------+--------+----------------------+
      | a    | b          | HEX(a) | HEX(b)               |
      +------+------------+--------+----------------------+
      | x    | x          | 78     | 78000000000000000000 |
      | x    | x          | 78     | 78200000000000000000 |
      +------+------------+--------+----------------------+
```

---

## 参考资料
1. [006.MySQL查询优化与调优工具集/001.MySQL查询优化之explain.md](../006.MySQL查询优化与调优工具集/001.MySQL查询优化之explain.md)
2. [https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#cast-spatial-types](https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#cast-spatial-types)
3. [https://dev.mysql.com/doc/refman/8.0/en/charset-unicode-sets.html](https://dev.mysql.com/doc/refman/8.0/en/charset-unicode-sets.html)
4. [The binary Collation Compared to _bin Collations](https://dev.mysql.com/doc/refman/8.0/en/charset-binary-collations.html)
