# MySQL 不区分大小写处理方案
## 背景
&nbsp;&nbsp;线上业务执行一段时间后，发现了一个Bug，两个用户的buyer_open_id基本一致，只有一个字母是大小写不一致的，如:
```txt
       AAE147H3ALfNdtRyui2yLSBK
       AAE147H3ALfNdtRyui2YLSBk
       > 如上两个buyer_open_id ,只有一个'Y'大小写不一致。
```
&nbsp;&nbsp;导致了两个用户的数据的错乱。
## 解决方案
```sql
    # env: 5.7.34-debug
    # 测试表创建
    mysql> show create table case_insensitive_summarize_data\G
    *************************** 1. row ***************************
           Table: case_insensitive_summarize_data
    Create Table: CREATE TABLE `case_insensitive_summarize_data` (
      `id` bigint(20) NOT NULL AUTO_INCREMENT,
      `gmt_create` datetime NOT NULL,
      `gmt_modified` datetime NOT NULL,
      `a` varchar(60) COLLATE utf8mb4_unicode_ci NOT NULL,
      `b` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
      `c` varchar(60) COLLATE utf8mb4_unicode_ci NOT NULL,
      `d` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
      PRIMARY KEY (`id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci

    # 造数据
    public void makeCaseInsensitiveSummarizeData() {
        System.out.println("数据开始创建...");
        int count = 0;
        while (count < 100000) {
            CaseInsensitiveSummarizeData data = new CaseInsensitiveSummarizeData();
            String uuid = UUID.randomUUID().toString().replace("-", "");
            data.setA(uuid + "A");
            data.setB(uuid + 'B');
            data.setC(uuid + "C");
            data.setD(uuid + 'D');
            caseInsensitiveSummarizeDataMakeService.makeCaseInsensitiveSummarizeData(data);


            CaseInsensitiveSummarizeData data2 = new CaseInsensitiveSummarizeData();
            data2.setA(uuid + "a");
            data2.setB(uuid + 'b');
            data2.setC(uuid + "c");
            data2.setD(uuid + 'd');
            caseInsensitiveSummarizeDataMakeService.makeCaseInsensitiveSummarizeData(data2);

            count++;
        }

        System.out.println("数据创建完成");
    }

    @Transactional
    public void makeCaseInsensitiveSummarizeData(CaseInsensitiveSummarizeData data) {
        jdbcTemplate.update(String.format("INSERT INTO case_insensitive_summarize_data(gmt_create,gmt_modified,a,b,c,d) VALUES(NOW(),NOW(),'%s','%s','%s','%s');", data.getA(), data.getB(), data.getC(), data.getD()));
    }

```
### 治本：排序规则设置为'utf8mb4_bin' OR 'utf8mb4_0900_bin'(从MySQL 8.0.17支持)
```sql
 # 通过a字段查询，能查询出两条数据
 mysql> select * from case_insensitive_summarize_data where a ='3a02547b28b645c48bbbc5f352a14981A';
 +----+---------------------+---------------------+-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------+
 | id | gmt_create          | gmt_modified        | a                                 | b                                 | c                                 | d                                 |
 +----+---------------------+---------------------+-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------+
 |  3 | 2023-11-16 01:06:50 | 2023-11-16 01:06:50 | 3a02547b28b645c48bbbc5f352a14981A | 3a02547b28b645c48bbbc5f352a14981B | 3a02547b28b645c48bbbc5f352a14981C | 3a02547b28b645c48bbbc5f352a14981D |
 |  4 | 2023-11-16 01:06:50 | 2023-11-16 01:06:50 | 3a02547b28b645c48bbbc5f352a14981a | 3a02547b28b645c48bbbc5f352a14981b | 3a02547b28b645c48bbbc5f352a14981c | 3a02547b28b645c48bbbc5f352a14981d |
 +----+---------------------+---------------------+-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------+
 2 rows in set (1.34 sec)

 # 通过b字段查询，b字段的排序规则为 utf8mb4_bin ，因此只能查询出一条数据。
 mysql> select * from case_insensitive_summarize_data where b = '3a02547b28b645c48bbbc5f352a14981b';
 +----+---------------------+---------------------+-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------+
 | id | gmt_create          | gmt_modified        | a                                 | b                                 | c                                 | d                                 |
 +----+---------------------+---------------------+-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------+
 |  4 | 2023-11-16 01:06:50 | 2023-11-16 01:06:50 | 3a02547b28b645c48bbbc5f352a14981a | 3a02547b28b645c48bbbc5f352a14981b | 3a02547b28b645c48bbbc5f352a14981c | 3a02547b28b645c48bbbc5f352a14981d |
 +----+---------------------+---------------------+-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------+
 1 row in set (1.32 sec)
```

### 治标：仅查询,给字段加上'binary'
```sql
  # 如下，在查询时添加上 binary , 也能使得大小写敏感，从而查询出一条数据。 那么有个问题，使用了binary还会走索引吗? 
  mysql> select * from case_insensitive_summarize_data where a = binary '3a02547b28b645c48bbbc5f352a14981A';
  +----+---------------------+---------------------+-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------+
  | id | gmt_create          | gmt_modified        | a                                 | b                                 | c                                 | d                                 |
  +----+---------------------+---------------------+-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------+
  |  3 | 2023-11-16 01:06:50 | 2023-11-16 01:06:50 | 3a02547b28b645c48bbbc5f352a14981A | 3a02547b28b645c48bbbc5f352a14981B | 3a02547b28b645c48bbbc5f352a14981C | 3a02547b28b645c48bbbc5f352a14981D |
  +----+---------------------+---------------------+-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------+
  1 row in set (1.31 sec)

  # 给表添加上索引
  mysql> create index idx_a on case_insensitive_summarize_data (a) using BTREE;
  Query OK, 0 rows affected (5.42 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  
  # 查询1：再次执行查询操作： 使用索引，性能较好
  mysql> desc select * from case_insensitive_summarize_data where a = '3a02547b28b645c48bbbc5f352a14981A';
  +----+-------------+---------------------------------+------------+------+---------------+-------+---------+-------+------+----------+-------+
  | id | select_type | table                           | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |
  +----+-------------+---------------------------------+------------+------+---------------+-------+---------+-------+------+----------+-------+
  |  1 | SIMPLE      | case_insensitive_summarize_data | NULL       | ref  | idx_a         | idx_a | 242     | const |    2 |   100.00 | NULL  |
  +----+-------------+---------------------------------+------------+------+---------------+-------+---------+-------+------+----------+-------+
  1 row in set, 1 warning (0.01 sec)
  
  # 查询2：从以下查询计划可知，如果在字段上使用binary，会导致性能的损失,见: [006.MySQL查询优化与调优工具集/001.MySQL查询优化之explain.md]
  mysql> desc select * from case_insensitive_summarize_data where a = binary '3a02547b28b645c48bbbc5f352a14981A';
  +----+-------------+---------------------------------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
  | id | select_type | table                           | partitions | type  | possible_keys | key   | key_len | ref  | rows | filtered | Extra                 |
  +----+-------------+---------------------------------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
  |  1 | SIMPLE      | case_insensitive_summarize_data | NULL       | range | idx_a         | idx_a | 242     | NULL |    2 |   100.00 | Using index condition |
  +----+-------------+---------------------------------+------------+-------+---------------+-------+---------+------+------+----------+-----------------------+
  1 row in set, 2 warnings (0.00 sec)
  
  # 查询3：对比查询1、2、3这几个查询计划，发现，保持原样SQL不变，在条件中添加“a = binary '3a02547b28b645c48bbbc5f352a14981A'”，能在保证性能的基础下兼顾大小写敏感。
  # 怎么理解呢? where a = '3a02547b28b645c48bbbc5f352a14981A' 还是使用了idx_a索引的，即过滤掉了大部分数据。
  # 由MySQL工作原理可知，MySQL Server会在存储引擎返回的时候应用WHERE条件，此时（存储引擎使用索引且返回符合条件的数据后）加上 a = binary '3a02547b28b645c48bbbc5f352a14981A'条件，
  # 只需要判断很少一部分数据，因此性能损耗也是最少的。
  mysql> desc select * from case_insensitive_summarize_data where a = binary '3a02547b28b645c48bbbc5f352a14981A' and a = '3a02547b28b645c48bbbc5f352a14981A';
  +----+-------------+---------------------------------+------------+------+---------------+-------+---------+-------+------+----------+-------+
  | id | select_type | table                           | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |
  +----+-------------+---------------------------------+------------+------+---------------+-------+---------+-------+------+----------+-------+
  |  1 | SIMPLE      | case_insensitive_summarize_data | NULL       | ref  | idx_a         | idx_a | 242     | const |    2 |   100.00 | NULL  |
  +----+-------------+---------------------------------+------------+------+---------------+-------+---------+-------+------+----------+-------+
  1 row in set, 2 warnings (0.03 sec)
  
  mysql> 
  
  # 如果直接在排序规则为 'utf8mb4_bin' 上建索引呢？
  create index idx_b on case_insensitive_summarize_data (b) using BTREE;
  查询4：
  mysql> explain select * from case_insensitive_summarize_data where b = '3a02547b28b645c48bbbc5f352a14981b';
  +----+-------------+---------------------------------+------------+------+---------------+-------+---------+-------+------+----------+-------+
  | id | select_type | table                           | partitions | type | possible_keys | key   | key_len | ref   | rows | filtered | Extra |
  +----+-------------+---------------------------------+------------+------+---------------+-------+---------+-------+------+----------+-------+
  |  1 | SIMPLE      | case_insensitive_summarize_data | NULL       | ref  | idx_b         | idx_b | 242     | const |    1 |   100.00 | NULL  |
  +----+-------------+---------------------------------+------------+------+---------------+-------+---------+-------+------+----------+-------+
  1 row in set, 1 warning (0.00 sec)
  
  mysql> 
 
 # 在a上如果需要建唯一索引呢?
  mysql> create unique index uk_a on case_insensitive_summarize_data (a) using BTREE;
  ERROR 1062 (23000): Duplicate entry '3a02547b28b645c48bbbc5f352a14981A' for key 'uk_a'
  mysql> 
  
 # 在b上建立唯一索引呢?
 mysql> create unique index uk_b on case_insensitive_summarize_data (b) using BTREE;
 Query OK, 0 rows affected (4.66 sec)
 Records: 0  Duplicates: 0  Warnings: 0
 mysql> 

```
## 总结
1. 如果需要在保证性能的前提下，保证大小写敏感，可以采用治标的方法。
2. 如果需要建唯一索引，那么采用治本的方法。

## 参考资料
1. [006.MySQL查询优化与调优工具集/001.MySQL查询优化之explain.md](../006.MySQL查询优化与调优工具集/001.MySQL查询优化之explain.md)

