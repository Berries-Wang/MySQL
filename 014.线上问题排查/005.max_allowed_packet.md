# max_allowed_packet
MySQL是C/S架构的，MySQL客户端和服务器之间的通信协议是"半双工"的,这意味着，在任意一个时刻，要么是由服务端向客户端发送数据，要么是由客户端向服务端发送数据。

客户端用一个单独的数据包将查询传给服务器，这也就是为什么当查询的语句很长的时候，参数 max_allowed_packet<sup>若查询太大，服务端会拒绝接受更多的数据并抛出相应错误</sup> 就特别重要了。

当客户端从服务器取数据时，看起来是一个拉数据的过程，但实际上是MySQL向客户端推送数据的过程。客户端不断的接收从服务器推送的数据，客户端也没有办法让服务器停下来。 多数连接MySQL的库函数都可以获得全部结果集并缓存到内存中，还可以逐行获取需要的数据。默认是获得全部结果集并缓存到内存中。MySQL通常需要等所有的数据都已经发送给客户端才能释放这条查询所占用的资源，所以接收全部结果并缓存通常可以减少服务器的压力，让查询能够早点结束，早点释放相应资源。


## 示例
```shell
    Server version: 5.7.34-debug-log Source distribution

    mysql> show variables like '%max_allowed_packet%';
    +--------------------------+------------+
    | Variable_name            | Value      |
    +--------------------------+------------+
    | max_allowed_packet       | 1024       | # 1024 bytes ,1KB ,修改my.cnf: max_allowed_packet=1024
    | slave_max_allowed_packet | 1073741824 |
    +--------------------------+------------+
    2 rows in set (0.01 sec)

    mysql> show create table student\G
    *************************** 1. row ***************************
           Table: student
    Create Table: CREATE TABLE `student` (
      `id` bigint(20) NOT NULL AUTO_INCREMENT,
      `name` varchar(10) DEFAULT NULL,
      `id_card` varchar(50) DEFAULT NULL,
      PRIMARY KEY (`id`),
      UNIQUE KEY `id_card` (`id_card`)
    ) ENGINE=InnoDB AUTO_INCREMENT=213 DEFAULT CHARSET=latin1

    # 插入数据超过包大小报错
    mysql> insert into student(name,id_card) values('wang','001'),('wang0','0010'),...10000条数据... ON DUPLICATE KEY UPDATE name=VALUES(name);
    ERROR 1153 (08S01): Got a packet bigger than 'max_allowed_packet' bytes
```



## 参考资料
1. 《高性能MySQL·第三版》 P211