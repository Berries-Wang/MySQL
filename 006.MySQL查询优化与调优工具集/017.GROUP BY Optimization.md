# GROUP BY Optimization
&nbsp;&nbsp;The most general way to satisfy a GROUP BY clause is to scan the whole table and create a new temporary table where all rows from each group are consecutive, and then use this temporary table to discover groups and apply aggregate functions (if any). In some cases, MySQL is able to do much better than that and avoid creation of temporary tables by using index access.(满足GROUP BY子句的最常见方法是扫描整个表并创建一个新的临时表，其中每个组的所有行都是连续的，然后使用这个临时表来发现组并应用聚合函数(如果有的话)。在某些情况下，MySQL可以做得更好，通过使用索引访问来避免创建临时表。)

&nbsp;&nbsp;The most important preconditions for using indexes for GROUP BY are that all GROUP BY columns reference attributes from the same index, and that the index stores its keys in order (as is true, for example, for a BTREE index, but not for a HASH index). Whether use of temporary tables can be replaced by index access also depends on which parts of an index are used in a query, the conditions specified for these parts, and the selected aggregate functions.(GROUP BY 使用索引最重要的前提条件是所有GROUP BY列都引用同一个索引中的字段，并且索引中的字段是按照顺序存储(例如，对于BTREE索引是这样，但对于HASH索引则不是)。是否可以用索引访问代替临时表的使用，还取决于查询中使用了索引的哪些部分、为这些部分指定的条件以及所选的聚集函数。)

&nbsp;&nbsp;There are two ways to execute a GROUP BY query through index access, as detailed in the following sections. The first method applies the grouping operation together with all range predicates (if any). The second method first performs a range scan, and then groups the resulting tuples.(GROUP BY 查询有两种使用索引的方法，第一种方法将分组操作与所有范围谓词(如果有的话)一起应用。第二种方法首先执行范围扫描，然后对结果元组进行分组。)

## GROUP BY 查询使用索引场景方式一： Loose Index Scan
&nbsp;&nbsp;The most efficient way to process GROUP BY is when an index is used to directly retrieve the grouping columns.  With this access method, MySQL uses the property of some index types that the keys are ordered (for example, BTREE).  This property enables use of lookup groups in an index without having to consider all keys in the index that satisfy all WHERE conditions.  This access method considers only a fraction of the keys in an index, so it is called a Loose Index Scan.  When there is no WHERE clause, a Loose Index Scan reads as many keys as the number of groups, which may be a much smaller number than that of all keys.  If the WHERE clause contains range predicates , a Loose Index Scan looks up the first key of each group that satisfies the range conditions, and again reads the smallest possible number of keys.  This is possible under the following conditions:(处理GROUP BY的最有效方法是使用索引直接检索分组列。使用这种访问方法，MySQL要求索引是有序的(例如BTREE)。这个属性允许在索引中使用查找组，而不必考虑索引中满足所有WHERE条件的所有键。这种访问方法只考虑索引中的一小部分键，因此称为松散索引扫描(Loose index Scan)。当没有WHERE子句时，松散索引扫描读取的键数目与组的数目相同，这可能比所有键的数目小得多。如果WHERE子句包含范围谓词，松散索引扫描将查找满足范围条件的每组的第一个键，并再次读取尽可能少的键。这在以下情况下是可能的:)
+ The query is over a single table.(查询在单个表上)
+ The GROUP BY names only columns that form a leftmost prefix of the index and no other columns. (If, instead of GROUP BY, the query has a DISTINCT clause, all distinct attributes refer to columns that form a leftmost prefix of the index.) For example, if a table t1 has an index on (c1,c2,c3), Loose Index Scan is applicable if the query has GROUP BY c1, c2. It is not applicable if the query has GROUP BY c2, c3 (the columns are not a leftmost prefix) or GROUP BY c1, c2, c4 (c4 is not in the index).(GROUP BY只命名构成索引最左边前缀的列，不命名其他列。（如果查询具有DISTINCT子句而不是GROUP BY，则所有不同的属性都引用构成索引最左边前缀的列。）例如，如果表t1在（c1，c2，c3）上具有索引，则如果查询具有GROUP BY c1，c2则适用松散索引扫描。如果查询具有GROUP BY c2、c3（列不是最左边的前缀）或GROUP BY c1、c2、c4（c4不在索引中），则不适用)
+ The only aggregate functions used in the select list (if any) are MIN() and MAX(), and all of them refer to the same column. The column must be in the index and must immediately follow the columns in the GROUP BY.(选择列表中使用的唯一聚合函数（如果有的话）是MIN（）和MAX（），它们都引用同一列。列必须在索引中，并且必须紧跟在GROUP BY中的列之后)
+ Any other parts of the index than those from the GROUP BY referenced in the query must be constants (that is, they must be referenced in equalities with constants), except for the argument of MIN() or MAX() functions.(除了查询中引用的组以外，索引的任何其他部分都必须是常量(也就是说，它们必须在具有常量的等式中引用)，MIN()或MAX()函数的参数除外)
+ For columns in the index, full column values must be indexed, not just a prefix. For example, with c1 VARCHAR(20), INDEX (c1(10)), the index uses only a prefix of c1 values and cannot be used for Loose Index Scan.(对于索引中的列，必须索引完整的列值，而不仅仅是前缀。例如，对于c1 VARCHAR(20)， INDEX (c1(10))，索引只使用c1值的前缀，不能用于松散索引扫描。)

&nbsp;&nbsp;If Loose Index Scan is applicable to a query, the EXPLAIN output shows Using index for group-by in the Extra column.（如果Loose Index Scan适用于查询，那么EXPLAIN输出中就会展示Using index for group-by）

&nbsp;&nbsp;Assume that there is an index idx(c1,c2,c3) on table t1(c1,c2,c3,c4). The Loose Index Scan access method can be used for the following queries:(假设表t1(c1,c2,c3,c4)上有一个索引idx(c1,c2,c3,c4)。松散索引扫描访问方法可用于以下查询:)
```sql
    SELECT c1, c2 FROM t1 GROUP BY c1, c2;
    SELECT DISTINCT c1, c2 FROM t1;
    SELECT c1, MIN(c2) FROM t1 GROUP BY c1;
    SELECT c1, c2 FROM t1 WHERE c1 < const GROUP BY c1, c2;
    SELECT MAX(c3), MIN(c3), c1, c2 FROM t1 WHERE c2 > const GROUP BY c1, c2;
    SELECT c2 FROM t1 WHERE c1 < const GROUP BY c1, c2;
    SELECT c1, c2 FROM t1 WHERE c3 = const GROUP BY c1, c2;
```

&nbsp;&nbsp;The following queries cannot be executed with this quick select method, for the reasons given:(下面的查询无法使用快速选择方法执行，原因如下:)
- There are aggregate functions other than MIN() or MAX():(除了MIN()和MAX()之外，还有其他聚合函数:)
  ```sql
     SELECT c1, SUM(c2) FROM t1 GROUP BY c1;
  ```
- The columns in the GROUP BY clause do not form a leftmost prefix of the index:(GROUP BY子句中的列并不构成索引最左侧的前缀:)
  ```sql
     SELECT c1, c2 FROM t1 GROUP BY c2, c3;
  ```
- The query refers to a part of a key that comes after the GROUP BY part, and for which there is no equality with a constant:
  ```sql
     SELECT c1, c3 FROM t1 GROUP BY c1, c2;
  ```
&nbsp;&nbsp;Were the query to include WHERE c3 = const, Loose Index Scan could be used.

&nbsp;&nbsp;The Loose Index Scan access method can be applied to other forms of aggregate function references in the select list, in addition to the MIN() and MAX() references already supported:

+ AVG(DISTINCT), SUM(DISTINCT), and COUNT(DISTINCT) are supported. AVG(DISTINCT) and SUM(DISTINCT) take a single argument. COUNT(DISTINCT) can have more than one column argument.
+ There must be no GROUP BY or DISTINCT clause in the query.
+ The Loose Index Scan limitations described previously still apply.

&nbsp;&nbsp;Assume that there is an index idx(c1,c2,c3) on table t1(c1,c2,c3,c4). The Loose Index Scan access method can be used for the following queries:
```sql
    SELECT COUNT(DISTINCT c1), SUM(DISTINCT c1) FROM t1;
    
    SELECT COUNT(DISTINCT c1, c2), COUNT(DISTINCT c2, c1) FROM t1;
```




## GROUP BY 查询使用索引场景方式二： Tight Index Scan