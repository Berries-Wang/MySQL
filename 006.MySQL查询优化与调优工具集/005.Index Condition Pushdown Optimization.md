# 8.2.1.5 Index Condition Pushdown（ICP） Optimization
> 要想明白ICP优化原理，请先阅读:[MySQL学习笔记](./../README.md)

&nbsp;&nbsp;Index Condition Pushdown (ICP) is an optimization for the case where MySQL retrieves<sup>v.取回；恢复;</sup> rows from a table using an index. Without ICP, the storage engine traverses<sup>v.横贯;穿过;</sup> the index to locate rows in the base table and returns them to the MySQL server which evaluates<sup>v.评估;估算;</sup> the WHERE condition for the rows. With ICP enabled, and if parts of the WHERE condition can be evaluated by using only columns from the index, the MySQL server pushes this part of the WHERE condition down to the storage engine. The storage engine then evaluates the pushed index condition by using the index entry and only if this is satisfied<sup>adj.满意的;满足的;确信的;v.使满意;使满足;satisfy的过去式和过去分词</sup> is the row read from the table. ICP can reduce the number of times the storage engine must access the base table and the number of times the MySQL server must access the storage engine.(**索引条件下推（Index Condition Pushdown.ICP）是针对MySQL使用索引从表中检索行的情况进行优化。如果没有ICP,存储引擎遍历索引来定位基表中的行，并将他们返回给MySQL Server,MySQL Server计算行的WHERE条件。在启用ICP的条件下，如果WHERE条件中的一部分可以通过仅使用索引中的列来求值，MySQL Server将把WHERE条件的这一部分下推到存储引擎。然后，存储引擎通过使用索引条目来计算推入的索引条件，并且只有在满足条件时才从表中读取行。ICP可以减少存储引擎访问基本表的次数，也可以减少MySQL Server访问存储引擎的次数。**)

&nbsp;&nbsp;Applicability of the Index Condition Pushdown optimization is subject to these conditions:(**索引条件下推优化的适用于以下条件:**)
- ICP is used for the range, ref, eq_ref, and ref_or_null access methods when there is a need to access full table rows.(**当需要访问完整的表行时，ICP用于range、ref、eq_ref和ref_or_null访问方法。**)
- ICP can be used for InnoDB and MyISAM tables, including partitioned<sup>划分;</sup> InnoDB and MyISAM tables.(**ICP可以用于InnoDB和MyISAM表，包括分区的InnoDB和MyISAM表。**)
- For InnoDB tables, ICP is used only for secondary indexes. The goal of ICP is to reduce the number of full-row reads and thereby<sup>因此;从而;</sup> reduce I/O operations. For InnoDB clustered indexes<sup>clustered indexes: 聚簇索引</sup>, the complete record is already read into the InnoDB buffer. Using ICP in this case does not reduce I/O.(**对于InnoDB存储引擎，ICP仅支持二级索引。ICP的目标是减少完整行读取的次数从而减少I/O操作，对于InnoDB聚簇索引，完整行早就被读取到InnoDB缓冲池中，此时使用ICP不能减少I/O操作**)
- ICP is not supported with secondary indexes created on virtual generated<sup>产生；引发；生成（generate 的过去式及过去分词）</sup> columns. InnoDB supports secondary indexes on virtual generated columns.(**ICP不支持在虚拟行上建的二级索引，InnoDB支持在虚拟行上创建的二级索引**)
- Conditions that refer to subqueries cannot be pushed down.(**子查询上的条件不能被下推**)
- Conditions that refer to stored functions cannot be pushed down. Storage engines cannot invoke stored functions.(**存储过程上的条件不能被下推，存储引擎不可以调用存储过程**)
- Triggered conditions cannot be pushed down. (For information about triggered conditions, see Section 8.2.2.3, “Optimizing Subqueries with the EXISTS Strategy”.) (**触发条件不能被下推**)

&nbsp;&nbsp;To understand how this optimization works, first consider how an index scan proceeds when Index Condition Pushdown is not used:(**To understand how this optimization works, first consider how an index scan proceeds when Index Condition Pushdown is not used:**)
1. Get the next row, first by reading the index tuple, and then by using the index tuple to locate and read the full table row.(**获取下一行，首先读取索引元组，然后使用索引元组定位并读取完整的表行。**)
2. Test the part of the WHERE condition that applies to this table. Accept or reject the row based on the test result.(**测试WHERE条件中应用于该表的部分。根据测试结果接受或拒绝该行。**)

&nbsp;&nbsp;Using Index Condition Pushdown, the scan proceeds like this instead:(**使用Index Condition Pushdown，扫描过程如下:**)
1. Get the next row's index tuple (but not the full table row).(**获取下一行的索引元组(但不是完整的表行)。**)
2. Test the part of the WHERE condition that applies to this table and can be checked using only index columns. If the condition is not satisfied<sup>adj.满意的;满足的;确信的;v.使满意;使满足;satisfy的过去式和过去分词</sup> , proceed to the index tuple for the next row.(**测试WHERE条件中应用于该表且只能使用索引列进行检查的部分。如果不满足条件，则继续到下一行的索引元组。**)
3. If the condition is satisfied, use the index tuple to locate and read the full table row.(**如果满足条件，则使用索引元组定位并读取整个表行。**)
4. Test the remaining part of the WHERE condition that applies to this table. Accept or reject the row based on the test result.(**测试适用于此表的WHERE条件的其余部分。根据测试结果接受或拒绝该行。**)

&nbsp;&nbsp;EXPLAIN output shows Using index condition in the Extra column when Index Condition Pushdown is used. It does not show Using index because that does not apply when full table rows must be read.(**当使用索引条件下推时，EXPLAIN输出显示在Extra列中使用索引条件。它不显示使用索引，因为当必须读取完整的表行时不适用。**)

&nbsp;&nbsp;Suppose that a table contains information about people and their addresses and that the table has an index defined as INDEX (zipcode, lastname, firstname). If we know a person's zipcode value but are not sure about the last name, we can search like this:(**假设一个表包含有关人员及其地址的信息，并且该表定义有这样一个索引:(zipcode, lastname, firstname)。如果我们知道一个人的邮政编码值，但不确定他的姓氏，我们可以这样搜索:**)
```sql
   SELECT * FROM people
     WHERE zipcode='95054'
     AND lastname LIKE '%etrunia%'
     AND address LIKE '%Main Street%';
```
+ MySQL can use the index to scan through people with zipcode='95054'. The second part (lastname LIKE '%etrunia%') cannot be used to limit the number of rows that must be scanned, so without Index Condition Pushdown, this query must retrieve full table rows for all people who have zipcode='95054'.(**MySQL可以使用索引扫描zipcode='95054'的人。第二部分(姓氏如'%etrunia%')不能用于限制必须扫描的行数，因此如果没有Index Condition Pushdown，该查询必须检索zipcode='95054'的所有人的完整表行。**)
+ With Index Condition Pushdown, MySQL checks the lastname LIKE '%etrunia%' part before reading the full table row. This avoids reading full rows corresponding to index tuples that match the zipcode condition but not the lastname condition.(**在索引条件下，MySQL在读取整个表行之前检查姓氏，比如'%etrunia%'部分。这样可以避免读取与zipcode条件匹配但与姓氏条件不匹配的索引元组对应的完整行。**)

&nbsp;&nbsp;Index Condition Pushdown is enabled by default. It can be controlled with the optimizer_switch system variable by setting the index_condition_pushdown flag:(**ICP默认是打开的，可以通过系统变量‘optimizer_switch’来控制ICP**)
```conf
   SET optimizer_switch = 'index_condition_pushdown=off';
   SET optimizer_switch = 'index_condition_pushdown=on';
```


## 参考资料
1. 官方文档:[8.2.1.5 Index Condition Pushdown Optimization](https://dev.mysql.com/doc/refman/5.7/en/index-condition-pushdown-optimization.html)