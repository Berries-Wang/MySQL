# Condition Filtering(条件过滤)
## 总结
+ 即: 在连接的过程中，优化器 or 手动控制是否使用WHERE条件过滤需要往下一次连接传递的数据行。
  + 通过[009.Hash Join Optimization.md](./009.Hash%20Join%20Optimization.md) 可以知晓，连接条件也可以作为数据行过滤条件
+ EXPLAIN 过滤行数计算：
  ```txt
        +----+------------+--------+------------------+---------+---------+------+----------+
        | id | table      | type   | possible_keys    | key     | ref     | rows | filtered |
        +----+------------+--------+------------------+---------+---------+------+----------+
        | 1  | employee   | ref    | name,h_date,dept | name    | const   | 8    | 16.31    |
        | 1  | department | eq_ref | PRIMARY          | PRIMARY | dept_no | 1    | 100.00   |

    ${被过滤掉的行数} = ${fows} * (1 - ${filtered})
  ```
+ 说明：[rows & filtered 的值的含义](#rows--filtered-值含义)
## 文档
&nbsp;&nbsp;In join processing, prefix rows are those rows passed from one table in a join to the next. In general, the optimizer attempts to put tables with low prefix counts early in the join order to keep the number of row combinations from increasing rapidly. To the extent that the optimizer can use information about conditions on rows selected from one table and passed to the next, the more accurately it can compute row estimates and choose the best execution plan.(在连接中，前缀行是在连接中从一个表传递到下一个表的那些行。一般来说，优化器会尝试讲前缀技术较低的表放在连接顺序的早期，以防止行组合数量的快速增加。如果优化器可以使用从一个表中选择并传递到下一个表的行的信息，那么他可以更准确地计算行估计并选择最佳的执行计划： 即尽量提前过滤掉更多的数据，避免更大数量的行传递到下一步)

&nbsp;&nbsp;Without condition filtering, the prefix row count for a table is based on the estimated number of rows selected by the WHERE clause according to whichever access method the optimizer chooses. Condition filtering enables the optimizer to use other relevant conditions in the WHERE clause not taken into account by the access method, and thus improve its prefix row count estimates. For example, even though there might be an index-based access method that can be used to select rows from the current table in a join, there might also be additional conditions for the table in the WHERE clause that can filter (further restrict) the estimate for qualifying rows passed to the next table.(如果没有条件过滤，表的前缀行数量将基于WHERE子句根据优化器选择的任何访问方法(指定的是优化方式)所选择的估计行数。条件过滤使优化器能够在WHERE子句中使用访问方法没有考虑到的其他相关条件，从而改进其前缀行数估计。例如，尽管可能存在基于索引的访问方法，可用于从连接中的当前表中选择行，但WHERE子句中可能还存在用于表的附加条件，这些条件可以过滤（进一步限制）传递给下一个表的符合条件的行估计)

&nbsp;&nbsp;A condition contributes to the filtering estimate only if:(条件只有在以下情况下才有助于过滤估计)
+ It refers to the current table.(他指的是当前表)
+ It depends on a constant value or values from earlier tables in the join sequence.（他依赖于连接序列中早期表中的一个或多个常量值。）
+ It was not already taken into account by the access method.(访问方法尚未将其考虑在内)

### rows & filtered 值含义
&nbsp;&nbsp;In EXPLAIN output, the rows column indicates the row estimate for the chosen access method, and the filtered column reflects the effect of condition filtering. filtered values are expressed as percentages. The maximum value is 100, which means no filtering of rows occurred. Values decreasing from 100 indicate increasing amounts of filtering.（在EXPLAIN输出中，rows列表示所选访问方法的行估计，而filtered列反映条件过滤的效果。过滤后的值以百分比表示。最大值是100，这意味着没有对行进行过滤。从100开始递减的值表示过滤量在增加。）

&nbsp;&nbsp;The prefix row count (the number of rows estimated to be passed from the current table in a join to the next) is the product of the rows and filtered values. That is, the prefix row count is the estimated row count, reduced by the estimated filtering effect. For example, if rows is 1000 and filtered is 20%, condition filtering reduces the estimated row count of 1000 to a prefix row count of 1000 × 20% = 1000 × 0.2 = 200.(前缀行计数（估计从联接中的当前表传递到下一个表的行数）是行(rows)和筛选值(filtered)的乘积。也就是说，前缀行计数是估计的行计数，减去估计的过滤效果。例如，如果${rows}为1000，${filtered}为20%，则条件过滤会将估计的行数1000减少为前缀行数1000×20%=1000×0.2=200)
```txt
     即被过滤前缀行计数 = 估计的行计数 - 估计的过滤效果  = 估计的行计数 * (1 - 20%) = 估计行计数 * 80%
     传递给下一张表的行数 =  ${rows} * ${filtered}
```


&nbsp;&nbsp;Consider the following query:
```sql
   SELECT *
      FROM employee JOIN department ON employee.dept_no = department.dept_no
      WHERE employee.first_name = 'John'
      AND employee.hire_date BETWEEN '2018-01-01' AND '2018-06-01';
```
&nbsp;&nbsp;Suppose that the data set has these characteristics:(假设数据集具有以下特征:)
- The employee table has 1024 rows.
- The department table has 12 rows.
- Both tables have an index on dept_no.
- The employee table has an index on first_name.
- 8 rows satisfy<sup>使满意;满足</sup> this condition on employee.first_name:
  ```sql
      employee.first_name = 'John'
  ```
- 150 rows satisfy this condition on employee.hire_date:
  ```sql
      employee.hire_date BETWEEN '2018-01-01' AND '2018-06-01'
  ```
- 1 row satisfies both conditions:
  ```sql
     employee.first_name = 'John' AND employee.hire_date BETWEEN '2018-01-01' AND '2018-06-01'
  ```

&nbsp;&nbsp;Without condition filtering, EXPLAIN produces output like this:
```txt
    +----+------------+--------+------------------+---------+---------+------+----------+
    | id | table      | type   | possible_keys    | key     | ref     | rows | filtered |
    +----+------------+--------+------------------+---------+---------+------+----------+
    | 1  | employee   | ref    | name,h_date,dept | name    | const   | 8    | 100.00   |
    | 1  | department | eq_ref | PRIMARY          | PRIMARY | dept_no | 1    | 100.00   |
    +----+------------+--------+------------------+---------+---------+------+----------+
```

&nbsp;&nbsp;For employee, the access method on the name index picks up the 8 rows that match a name of 'John'. No filtering is done (filtered is 100%), so all rows are prefix rows for the next table: The prefix row count is rows × filtered = 8 × 100% = 8.(对于employee, name索引上的访问方法选取与名称“John”匹配的8行。没有进行过滤(filtered是100%)，所以所有行都是下一个表的前缀行:前缀行数为rows × filtered = 8 × 100% = 8。)

&nbsp;&nbsp;With condition filtering, the optimizer additionally takes into account conditions from the WHERE clause not taken into account by the access method. In this case, the optimizer uses heuristics to estimate a filtering effect of 16.31% for the BETWEEN condition on employee.hire_date. As a result, EXPLAIN produces output like this:(通过条件过滤，优化器还会考虑访问方法没有考虑到的WHERE子句中的条件。在本例中，优化器使用启发式方法来估计employee.hire_date上BETWEEN条件的过滤效果为16.31%。因此，EXPLAIN产生如下输出:)
```txt
   +----+------------+--------+------------------+---------+---------+------+----------+
   | id | table      | type   | possible_keys    | key     | ref     | rows | filtered |
   +----+------------+--------+------------------+---------+---------+------+----------+
   | 1  | employee   | ref    | name,h_date,dept | name    | const   | 8    | 16.31    |
   | 1  | department | eq_ref | PRIMARY          | PRIMARY | dept_no | 1    | 100.00   |
```

&nbsp;&nbsp;Now the prefix row count is rows × filtered = 8 × 16.31% = 1.3, which more closely reflects actual data set.(现在前缀行数为rows × filtered = 8 × 16.31% = 1.3，更接近实际数据集。)

&nbsp;&nbsp;Normally, the optimizer does not calculate the condition filtering effect (prefix row count reduction) for the last joined table because there is no next table to pass rows to. An exception occurs for EXPLAIN: To provide more information, the filtering effect is calculated for all joined tables, including the last one.(通常，优化器不计算最后一个连接表的条件过滤效果(减少前缀行计数)，因为没有下一个表可以传递行。EXPLAIN出现异常:为了提供更多信息，对所有连接表(包括最后一个表)计算过滤效果。以上翻译结果来自有道神经网络翻译（YNMT）· 通用场景)

&nbsp;&nbsp;To control whether the optimizer considers additional filtering conditions, use the condition_fanout_filter flag of the optimizer_switch system variable (see Section 8.9.2, “Switchable Optimizations”). This flag is enabled by default but can be disabled to suppress condition filtering (for example, if a particular query is found to yield better performance without it).(为了控制优化器是否考虑额外的过滤条件，使用optimizer_switch系统变量的condition_fanout_filter标志(参见'8.9.2, “Switchable Optimizations”')。这个标志在默认情况下是启用的，但是可以禁用它来抑制条件过滤(例如，如果发现一个特定的查询不使用它可以产生更好的性能)。)

&nbsp;&nbsp;If the optimizer overestimates the effect of condition filtering, performance may be worse than if condition filtering is not used. In such cases, these techniques may help:(如果优化器高估了条件过滤的效果，那么性能可能会比不使用条件过滤时更差。在这种情况下，这些技术可能会有所帮助:)
- If a column is not indexed, index it so that the optimizer has some information about the distribution of column values and can improve its row estimates.(如果没有对列建立索引，则对其建立索引，以便优化器获得有关列值分布的一些信息，并可以改进其行估计。)
- Similarly, if no column histogram information is available, generate a histogram (see Section 8.9.6, “Optimizer Statistics”).(类似地，如果没有可用的列直方图信息，则生成直方图)
- Change the join order. Ways to accomplish this include join-order optimizer hints (see Section 8.9.3, “Optimizer Hints”), STRAIGHT_JOIN immediately following the SELECT, and the STRAIGHT_JOIN join operator.(实现这一点的方法包括连接顺序优化器提示(参见第8.9.3节，“优化器提示”)，紧接SELECT的紧接语句，以及连接操作符。)
- Disable condition filtering for the session:
  ```sql
       SET optimizer_switch = 'condition_fanout_filter=off';
       
       # Or, for a given query, using an optimizer hint:
       SELECT /*+ SET_VAR(optimizer_switch = 'condition_fanout_filter=off') */ ...
  ```


## 参考资料
1. [https://dev.mysql.com/doc/refman/8.2/en/condition-filtering.html](https://dev.mysql.com/doc/refman/8.2/en/condition-filtering.html)