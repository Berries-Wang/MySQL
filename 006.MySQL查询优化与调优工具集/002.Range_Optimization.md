# 8.2.1.2 Range Optimization (范围优化)
&nbsp;&nbsp;The range access method uses a single index to retrieve a subset of table rows that are contained within one or several index value intervals. It can be used for a single-part or multiple-part index. The following sections describe conditions under which the optimizer uses range access.
> 范围查找使用单索引去检索包含在一个或多个索引值区间内表行的子集。他能够使用单字段或多字段索引。下面几节描述优化器使用范围访问的条件.

## Range Access Method for Single-Part Indexes
&nbsp;&nbsp;For a single-part index, index value intervals can be conveniently represented by corresponding conditions in the WHERE clause, denoted as range conditions rather than “intervals.”
> 对于单字段索引，索引值区间可以方便的使用WHERE子句中的相应条件表示，表示为范围条件而不是“范围”

&nbsp;&nbsp;The definition of a range condition for a single-part index is as follows:
> 单字段索引范围条件定义如下:
1. For both BTREE and HASH indexes, comparison of a key part with a constant value is a range condition when using the =, <=>, IN(), IS NULL, or IS NOT NULL operators.
   > 对于BTREE 和 HASH索引，当使用 = 、 <=> 、 IN 、 IS　NULL 或IS NOT NULL操作符时，索引部分字段与常量值比较是一个范围条件。
2. Additionally, for BTREE indexes, comparison of a key part with a constant value is a range condition when using the >, <, >=, <=, BETWEEN, !=, or <> operators, or LIKE comparisons if the argument to LIKE is a constant string that does not start with a wildcard character.
   > 此外，对于BTREE索引，当使用 = 、 <=> 、 IN 、 IS　NULL 或IS NOT NULL操作符时以及使用LIKE比较符且LIKE的参数不是以通配符开始的常量字符串时，索引部分字段与常量值比较是一个范围条件。
3. For all index types, multiple range conditions combined with OR or AND form a range condition.
   > 对于所有索引类型，多个范围条件与OR或AND组合形成一个范围条件

&nbsp;&nbsp;常量值的概念:
1. A constant from the query string
   > 来自于查询字符串的常量
3. A column of a const or system table from the same join
   > 来自同一连接的const表或system表的一列
4. The result of an uncorrelated subquery
   > 不相关的子查询的结果
5. Any expression composed entirely from subexpressions of the preceding types
   > 任何完全由上述类型的子表达式组成的表达式

&nbsp;&nbsp;Some nonconstant values may be converted to constants during the optimizer constant propagation phase.
  > 在优化器常量传播阶段一些非常量值或许会被转换为常量。

&nbsp;&nbsp;MySQL tries to extract range conditions from the WHERE clause for each of the possible indexes. During the extraction process, conditions that cannot be used for constructing the range condition are dropped, conditions that produce overlapping ranges are combined, and conditions that produce empty ranges are removed.
> MySQL 尝试从WHERE子句中为每个可能的索引提取范围条件。在提取过程中，不能用于构造范围条件的条件会被删除，产生重叠范围的条件将会被合并，产生空范围的条件将被删除。

&nbsp;&nbsp;举例如下:
```sql
  # key1 is an indexed column and nonkey is not indexed:
  SELECT * FROM t1 WHERE
  (key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
  (key1 < 'bar' AND nonkey = 4) OR
  (key1 < 'uux' AND key1 > 'z');
  # The extraction process for key key1 is as follows:
  # key1 提取的过程如下: 
  # 1. 以原始的where子句开始
    (key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
    (key1 < 'bar' AND nonkey = 4) OR
    (key1 < 'uux' AND key1 > 'z')
  # 2. Remove nonkey = 4 and key1 LIKE '%b' because they cannot be used for a range  scan. The correct way to remove them is to replace them with TRUE, so that we do not miss any matching rows when doing the range scan. Replacing them with TRUE yields: 
   > 移除monkey=4和key1 LIKE '%b',因为他们不能用于范围扫描(**无法使用索引**)。移除他们的正确方法就是将他们替换为TRUE,所以在扫描行的时候不会错过任何行。用真正的结果代替他们:
    (key1 < 'abc' AND (key1 LIKE 'abcde%' OR TRUE)) OR
    (key1 < 'bar' AND TRUE) OR
    (key1 < 'uux' AND key1 > 'z')
  # 3. Collapse conditions that are always true or false:
     > 折叠起总是为TRUE 或 为FALSE 的条件
      a. (key1 LIKE 'abcde%' OR TRUE) is always true
      b. (key1 < 'uux' AND key1 > 'z') is always false
  # 3.1 Replacing these conditions with constants yields:
       > 用常量替换条件
      (key1 < 'abc' AND TRUE) OR (key1 < 'bar' AND TRUE) OR (FALSE)
  # 3.2. Removing unnecessary TRUE and FALSE constants yields:
         > 移除不必要的TRUE　or false
      (key1 < 'abc') OR (key1 < 'bar')
   # 4. Combining overlapping intervals into one yields the final condition to be used for the range scan:
   > 将重叠的间隔组合成一个，产生用于范围扫描的最终条件:
     (key1 < 'bar')
```
&nbsp;&nbsp;In general (and as demonstrated by the preceding example), the condition used for a range scan is less restrictive than the WHERE clause. MySQL performs an additional check to filter out rows that satisfy the range condition but not the full WHERE clause.
> 通常(如前面的示例所示)，用于范围扫描的条件比WHERE子句的限制要少。MySQL执行额外的检查来过滤出满足范围条件但不满足完整WHERE子句的行。

&nbsp;&nbsp;The range condition extraction algorithm can handle nested AND/OR constructs of arbitrary depth, and its output does not depend on the order in which conditions appear in WHERE clause.
> 范围条件提取算法可以处理任意深度的嵌套AND/OR构造，其输出不依赖于WHERE子句中条件出现的顺序。

&nbsp;&nbsp;MySQL does not support merging multiple ranges for the range access method for spatial indexes. To work around this limitation, you can use a UNION with identical SELECT statements, except that you put each spatial predicate in a different SELECT.
> MySQL不支持对空间索引的范围访问方法合并多个范围。为了解决这个限制，您可以在相同的SELECT语句中使用UNION，只是将每个空间谓词放在不同的SELECT中。

## Range Access Method for Multiple-Part Indexes
&nbsp;&nbsp;Range conditions on a multiple-part index are an extension of range conditions for a single-part index. A range condition on a multiple-part index restricts index rows to lie within one or several key tuple intervals. Key tuple intervals are defined over a set of key tuples, using ordering from the index.
> 多字段索引上的范围条件是单字段索引范围条件的一个拓展，