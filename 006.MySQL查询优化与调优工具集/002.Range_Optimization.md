# 8.2.1.2 Range Optimization (范围优化)
&nbsp;&nbsp;The range access method uses a single index to retrieve a subset of table rows that are contained within one or several index value intervals. It can be used for a single-part or multiple-part index. The following sections describe conditions under which the optimizer uses range access.
> 范围查找使用单索引去检索包含在一个或多个索引值区间内表行的子集。他能够使用单字段或多字段索引。下面几节描述优化器使用范围访问的条件.

## Range Access Method for Single-Part Indexes
&nbsp;&nbsp;For a single-part index, index value intervals can be conveniently represented by corresponding conditions in the WHERE clause, denoted as range conditions rather than “intervals.”
> 对于单字段索引，索引值区间可以方便的使用WHERE子句中的相应条件表示，表示为范围条件而不是“范围”

&nbsp;&nbsp;The definition of a range condition for a single-part index is as follows:
> 单字段索引范围条件定义如下:
1. For both BTREE and HASH indexes, comparison of a key part with a constant value is a range condition when using the =, <=>, IN(), IS NULL, or IS NOT NULL operators.
   > 对于BTREE 和 HASH索引，当使用 = 、 <=> 、 IN 、 IS　NULL 或IS NOT NULL操作符时，索引部分字段与常量值比较是一个范围条件。
2. Additionally, for BTREE indexes, comparison of a key part with a constant value is a range condition when using the >, <, >=, <=, BETWEEN, !=, or <> operators, or LIKE comparisons if the argument to LIKE is a constant string that does not start with a wildcard character.
   > 此外，对于BTREE索引，当使用 = 、 <=> 、 IN 、 IS　NULL 或IS NOT NULL操作符时以及使用LIKE比较符且LIKE的参数不是以通配符开始的常量字符串时，索引部分字段与常量值比较是一个范围条件。
3. For all index types, multiple range conditions combined with OR or AND form a range condition.
   > 对于所有索引类型，多个范围条件与OR或AND组合形成一个范围条件

&nbsp;&nbsp;常量值的概念:
1. A constant from the query string
   > 来自于查询字符串的常量
3. A column of a const or system table from the same join
   > 来自同一连接的const表或system表的一列
4. The result of an uncorrelated subquery
   > 不相关的子查询的结果
5. Any expression composed entirely from subexpressions of the preceding types
   > 任何完全由上述类型的子表达式组成的表达式

&nbsp;&nbsp;Some nonconstant values may be converted to constants during the optimizer constant propagation phase.
  > 在优化器常量传播阶段一些非常量值或许会被转换为常量。

&nbsp;&nbsp;MySQL tries to extract range conditions from the WHERE clause for each of the possible indexes. During the extraction process, conditions that cannot be used for constructing the range condition are dropped, conditions that produce overlapping ranges are combined, and conditions that produce empty ranges are removed.
> MySQL 尝试从WHERE子句中为每个可能的索引提取范围条件。在提取过程中，不能用于构造范围条件的条件会被删除，产生重叠范围的条件将会被合并，产生空范围的条件将被删除。

&nbsp;&nbsp;举例如下:
```sql
  # key1 is an indexed column and nonkey is not indexed:
  SELECT * FROM t1 WHERE
  (key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
  (key1 < 'bar' AND nonkey = 4) OR
  (key1 < 'uux' AND key1 > 'z');
  # The extraction process for key key1 is as follows:
  # key1 提取的过程如下: 
  # 1. 以原始的where子句开始
    (key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
    (key1 < 'bar' AND nonkey = 4) OR
    (key1 < 'uux' AND key1 > 'z')
  # 2. Remove nonkey = 4 and key1 LIKE '%b' because they cannot be used for a range  scan. The correct way to remove them is to replace them with TRUE, so that we do not miss any matching rows when doing the range scan. Replacing them with TRUE yields: 
   > 移除monkey=4和key1 LIKE '%b',因为他们不能用于范围扫描(**无法使用索引**)。移除他们的正确方法就是将他们替换为TRUE,所以在扫描行的时候不会错过任何行。用真正的结果代替他们:
    (key1 < 'abc' AND (key1 LIKE 'abcde%' OR TRUE)) OR
    (key1 < 'bar' AND TRUE) OR
    (key1 < 'uux' AND key1 > 'z')
  # 3. Collapse conditions that are always true or false:
     > 折叠起总是为TRUE 或 为FALSE 的条件
      a. (key1 LIKE 'abcde%' OR TRUE) is always true
      b. (key1 < 'uux' AND key1 > 'z') is always false
  # 3.1 Replacing these conditions with constants yields:
       > 用常量替换条件
      (key1 < 'abc' AND TRUE) OR (key1 < 'bar' AND TRUE) OR (FALSE)
  # 3.2. Removing unnecessary TRUE and FALSE constants yields:
         > 移除不必要的TRUE　or false
      (key1 < 'abc') OR (key1 < 'bar')
   # 4. Combining overlapping intervals into one yields the final condition to be used for the range scan:
   > 将重叠的间隔组合成一个，产生用于范围扫描的最终条件:
     (key1 < 'bar')
```
&nbsp;&nbsp;In general (and as demonstrated by the preceding example), the condition used for a range scan is less restrictive than the WHERE clause. MySQL performs an additional check to filter out rows that satisfy the range condition but not the full WHERE clause.
> 通常(如前面的示例所示)，用于范围扫描的条件比WHERE子句的限制要少。MySQL执行额外的检查来过滤出满足范围条件但不满足完整WHERE子句的行。

&nbsp;&nbsp;The range condition extraction algorithm can handle nested AND/OR constructs of arbitrary depth, and its output does not depend on the order in which conditions appear in WHERE clause.
> 范围条件提取算法可以处理任意深度的嵌套AND/OR构造，其输出不依赖于WHERE子句中条件出现的顺序。

&nbsp;&nbsp;MySQL does not support merging multiple ranges for the range access method for spatial indexes. To work around this limitation, you can use a UNION with identical SELECT statements, except that you put each spatial predicate in a different SELECT.
> MySQL不支持对空间索引的范围访问方法合并多个范围。为了解决这个限制，您可以在相同的SELECT语句中使用UNION，只是将每个空间谓词放在不同的SELECT中。

## Range Access Method for Multiple-Part Indexes
&nbsp;&nbsp;Range conditions on a multiple-part index are an extension of range conditions for a single-part index. A range condition on a multiple-part index restricts(约束、限制) index rows to lie within one or several key tuple intervals. Key tuple intervals are defined over a set of key tuples, using ordering from the index.
> 多字段索引上的范围条件是单字段索引范围条件的一个拓展，多部分索引上的范围条件限制索引行位于一个或多个键元组(即索引节点元素)区间内。键元组间隔是在一组键元组上定义的，使用从索引开始的排序。

&nbsp;&nbsp;For example, consider a multiple-part index defined as key1(key_part1, key_part2, key_part3), and the following set of key tuples listed in key order:
```sql
   key_part1  key_part2  key_part3
      NULL       1         'abc'
      NULL       1         'xyz'
      NULL       2         'foo'
       1         1         'abc'
       1         1         'xyz'
       1         2         'abc'
       2         1         'aaa'
```
&nbsp;&nbsp;The condition key_part1 = 1 defines this interval（区间）:
```sql
   (1,-inf,-inf) <= (key_part1,key_part2,key_part3) < (1,+inf,+inf)
```
&nbsp;&nbsp;The interval covers the 4th, 5th, and 6th tuples in the preceding data set and can be used by the range access method.By contrast, the condition key_part3 = 'abc' does not define a single interval and cannot be used by the range access method.
> 这个区间覆盖了前面第4,5,6个键元组,可用于范围查找方法。相比之下，key_part3 = 'abc' 不能定义在一个单区间并且不能用于多范围查找方法。

&nbsp;&nbsp;The following descriptions indicate how range conditions work for multiple-part indexes in greater detail.
> 下面的描述更详细的说明了多字段索引的范围条件如何工作：
- For HASH indexes, each interval containing identical(完全相同的) values can be used. This means that the interval can be produced only for conditions in the following form:
  > 对于HASH索引，可以使用包含相同值的区间。这意味着只有在下列条件下才会产生区间：
  ```sql
      key_part1 cmp const1
      AND key_part2 cmp const2
      AND ...
      AND key_partN cmp constN;
  ```
  > Here, const1, const2, … are constants, cmp is one of the =, <=>, or IS NULL comparison operators, and the conditions cover all index parts. (That is, there are N conditions, one for each part of an N-part index.) For example, the following is a range condition for a three-part HASH index:
  ```sql
    key_part1 = 1 AND key_part2 IS NULL AND key_part3 = 'foo'
  ```
- For a BTREE index, an interval might be usable for conditions combined with AND, where each condition compares a key part with a constant value using =, <=>, IS NULL, >, <, >=, <=, !=, <>, BETWEEN, or LIKE 'pattern' (where 'pattern' does not start with a wildcard). An interval can be used as long as it is possible to determine a single key tuple containing all rows that match the condition (or two intervals if <> or != is used).
  > 对于BTREE索引，区间可能适用于与AND组合的条件，其中每个条件使用=，<=>，IS NULL，>，<，>=，<=，！=，<>将键部分与常数值进行比较，BETWEEN或LIKE“pattern”（其中“pattern“不以通配符开头）。只要可以确定包含所有符合条件的行的单个关键字元组，就可以使用区间（如果使用<>或！=，则可以使用两个区间）。

  > The optimizer attempts to use additional key parts to determine the interval as long as the comparison operator is =, <=>, or IS NULL. If the operator is >, <, >=, <=, !=, <>, BETWEEN, or LIKE, the optimizer uses it but considers no more key parts. For the following expression, the optimizer uses = from the first comparison. It also uses >= from the second comparison but considers no further key parts and does not use the third comparison for interval construction:
  >> 只要比较运算符为=、<=>或is NULL，优化器就会尝试使用其他关键部分来确定间隔。如果运算符为>，<，>=，<=，！=，<>，BETWEEN或LIKE，优化器使用它，但不考虑更多的关键部分。对于以下表达式，优化器在第一次比较中使用=。它还使用了第二次比较中的>=，但没有考虑其他关键部分，也没有将第三次比较用于区间构造：
  ```sql 
     key_part1 = 'foo' AND key_part2 >= 10 AND key_part3 > 10
  ```
  >>> The single interval is:
  ```sql
      ('foo',10,-inf) < (key_part1,key_part2,key_part3) < ('foo',+inf,+inf)
  ```
  + It is possible that the created interval contains more rows than the initial condition. For example, the preceding interval includes the value ('foo', 11, 0), which does not satisfy the original condition.
    > 创建的间隔可能包含比初始条件更多的行。例如，前面的间隔包括不满足原始条件的值（'foo'，11，0）。