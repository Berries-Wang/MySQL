# Hash Join Optimization
&nbsp;&nbsp;By default, MySQL (8.0.18 and later) employs hash joins whenever<sup>adv.究竟什么时候；不论何时，随便什么时候</sup> possible. It is possible to control whether hash joins are employed using one of the BNL and NO_BNL optimizer hints, or by setting block_nested_loop=on or block_nested_loop=off as part of the setting for the optimizer_switch server system variable.(MySQL 8.0.18及之后的版本会尽可能的使用Hash Join,可能通过判断是否命中BNL 或 NO_BNL优化器或者设置系统变量来控制是否使用Hash Join)

&nbsp;&nbsp;[**需要等值连接**]: Beginning with MySQL 8.0.18, MySQL employs a hash join for any query for which each join has an equi-join<sup>等值连接</sup> condition, and in which there are no indexes that can be applied to any join conditions, such as this one:
```sql
    SELECT *
      FROM t1
        JOIN t2
          ON t1.c1=t2.c1;
```

&nbsp;&nbsp;A hash join can also be used when there are one or more indexes that can be used for single-table predicates.(当存在一个或多个索引可用于单表判断时，也可以使用Hash Join)

&nbsp;&nbsp;A hash join is usually faster than and is intended to be used in such cases instead of the block nested loop algorithm (see Block Nested-Loop Join Algorithm) employed in previous versions of MySQL. Beginning with MySQL 8.0.20, support for block nested loop is removed, and the server employs a hash join wherever a block nested loop would have been used previously.(散列连接通常比以前版本的MySQL中使用的块嵌套循环算法(参见块嵌套循环连接算法)更快，并且打算在这种情况下使用它。从MySQL 8.0.20开始，删除了对块嵌套循环的支持，服务器在以前使用块嵌套循环的地方使用散列连接。[TO 009.Hash Join Optimization.md](./006.MySQL查询优化与调优工具集/006.Nested-Loop Join Algorithms.md))

&nbsp;&nbsp;In the example just shown and the remaining examples in this section, we assume that the three tables t1, t2, and t3 have been created using the following statements:
```sql
    CREATE TABLE t1 (c1 INT, c2 INT);
    CREATE TABLE t2 (c1 INT, c2 INT);
    CREATE TABLE t3 (c1 INT, c2 INT);

    --->
    # 版本信息:  8.0.30-debug
    mysql> EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.c1=t2.c1\G
    *************************** 1. row ***************************
               id: 1
      select_type: SIMPLE
            table: t1
       partitions: NULL
             type: ALL
    possible_keys: NULL
              key: NULL
          key_len: NULL
              ref: NULL
             rows: 1
         filtered: 100.00
            Extra: NULL
    *************************** 2. row ***************************
               id: 1
      select_type: SIMPLE
            table: t2
       partitions: NULL
             type: ALL
    possible_keys: NULL
              key: NULL
          key_len: NULL
              ref: NULL
             rows: 1
         filtered: 100.00
            Extra: Using where; Using join buffer (hash join)
    2 rows in set, 1 warning (0.01 sec)
    
    mysql> 

   (Prior to MySQL 8.0.20, it was necessary to include the FORMAT=TREE option to see whether hash joins were being used for a given join.)
   
   mysql> EXPLAIN  FORMAT=TREE SELECT * FROM t1 JOIN t2 ON t1.c1=t2.c1\G
   *************************** 1. row ***************************
   EXPLAIN: -> Inner hash join (t2.c1 = t1.c1)  (cost=0.70 rows=1)
       -> Table scan on t2  (cost=0.35 rows=1)
       -> Hash
           -> Table scan on t1  (cost=0.35 rows=1)
   
   1 row in set (0.01 sec)

mysql> 
    
```

&nbsp;&nbsp;[**需要等值连接**]The hash join is used for queries involving<sup>v.涉及；包括；使陷于（involve 的 ing 形式）</sup> multiple joins as well, as long as at least one join condition for each pair of tables is an equi-join, like the query shown here:(多表连接也可以使用Hash Join,只要至少有一个连接是等值连接)
```sql
    SELECT * FROM t1
      JOIN t2 ON (t1.c1 = t2.c1 AND t1.c2 < t2.c2)
      JOIN t3 ON (t2.c1 = t3.c1);
```

&nbsp;&nbsp;[**非等值连接作为过滤器使用**]In cases like the one just shown, which makes use of an inner join, any extra conditions which are not equi-joins are applied as filters after the join is executed. (For outer joins, such as left joins, semijoins, and antijoins, they are printed as part of the join.) This can be seen here in the output of EXPLAIN:（在使用内部连接的情况下，在执行连接后，任何非等连接的额外条件都将作为过滤器应用。(对于外部连接，如左连接、半连接和反连接，它们被打印为连接的一部分。)这可以在EXPLAIN的输出中看到:）
```sql
  # 版本: 8.0.30-debug

      mysql> EXPLAIN  FORMAT=TREE  SELECT * FROM t1 JOIN t2 ON (t1.c1 = t2.c1 AND t1.c2 < t2.c2) JOIN t3 ON (t2.c1 = t3.c1) \G
      *************************** 1. row ***************************
      EXPLAIN: -> Inner hash join (t3.c1 = t1.c1)  (cost=1.05 rows=1)
          -> Table scan on t3  (cost=0.35 rows=1)
          -> Hash
              -> Filter: (t1.c2 < t2.c2)  (cost=0.70 rows=1)
                  -> Inner hash join (t2.c1 = t1.c1)  (cost=0.70 rows=1)
                      -> Table scan on t2  (cost=0.35 rows=1)
                      -> Hash
                          -> Table scan on t1  (cost=0.35 rows=1)
      
      1 row in set (0.02 sec)
      
      mysql> 
```

&nbsp;&nbsp;As also can be seen from the output just shown, multiple hash joins can be (and are) used for joins having multiple equi-join conditions.(仅从刚才的EXPLAIN输出可以看出，多Hash Join也能够用于多个等值连接条件)

&nbsp;&nbsp;Prior to MySQL 8.0.20, a hash join could not be used if any pair of joined tables did not have at least one equi-join condition, and the slower block nested loop algorithm was employed. In MySQL 8.0.20 and later, the hash join is used in such cases, as shown here:(MySQL 8.0.20之前，Hash Join 不能用用于没有等值连接的条件的查询，在MySQL 8.0.20及后面的版本，Hash Join可以用于这样的条件，如下:)
```sql
  # 版本: 8.0.30-debug
    
    mysql> EXPLAIN FORMAT=TREE SELECT * FROM t1   JOIN t2 ON (t1.c1 = t2.c1) JOIN t3 ON (t2.c1 < t3.c1)\G
    *************************** 1. row ***************************
    EXPLAIN: -> Filter: (t1.c1 < t3.c1)  (cost=1.05 rows=1)    # 过滤
        -> Inner hash join (no condition)  (cost=1.05 rows=1)
            -> Table scan on t3  (cost=0.35 rows=1)
            -> Hash
                -> Inner hash join (t2.c1 = t1.c1)  (cost=0.70 rows=1)   # 等值连接
                    -> Table scan on t2  (cost=0.35 rows=1)
                    -> Hash
                        -> Table scan on t1  (cost=0.35 rows=1)
    
    1 row in set (0.00 sec)
    
    mysql> 
```

&nbsp;&nbsp; A hash join is also applied for a Cartesian<sup>adj.（与）笛卡尔极其思想（有关）的；笛卡尔哲学的</sup> product—that is, when no join condition is specified, as shown here:(用于生成笛卡尔乘积，没有指定连接条件，如下)
```sql
  # 版本: 8.0.30-debug

     mysql> EXPLAIN FORMAT=TREE SELECT *   FROM t1 JOIN t2 WHERE t1.c2 > 50 \G
     *************************** 1. row ***************************
     EXPLAIN: -> Inner hash join (no condition)  (cost=0.70 rows=1)
         -> Table scan on t2  (cost=0.35 rows=1)
         -> Hash
             -> Filter: (t1.c2 > 50)  (cost=0.35 rows=1) # 过滤
                 -> Table scan on t1  (cost=0.35 rows=1)
     
     1 row in set (0.00 sec)
```

&nbsp;&nbsp;In MySQL 8.0.20 and later, it is no longer necessary for the join to contain at least one equi-join condition in order for a hash join to be used. This means that the types of queries which can be optimized using hash joins include those in the following list (with examples):
- Inner non-equi-join:
  ```sql 
      (版本: 8.0.30-debug)
 
      mysql> EXPLAIN FORMAT=TREE SELECT * FROM t1 JOIN t2 ON t1.c1 < t2.c1\G
      *************************** 1. row ***************************
      EXPLAIN: -> Filter: (t1.c1 < t2.c1)  (cost=0.70 rows=1)
          -> Inner hash join (no condition)  (cost=0.70 rows=1)
              -> Table scan on t2  (cost=0.35 rows=1)
              -> Hash
                  -> Table scan on t1  (cost=0.35 rows=1)
      
      1 row in set (0.00 sec)
  ```

- Semijoin:
  ```sql
    (版本: 8.0.30-debug)

     mysql> EXPLAIN FORMAT=TREE SELECT * FROM t1   WHERE t1.c1 IN (SELECT t2.c2 FROM t2)\G
     *************************** 1. row ***************************
     EXPLAIN: -> Hash semijoin (t2.c2 = t1.c1)  (cost=0.70 rows=1)
         -> Table scan on t1  (cost=0.35 rows=1)
         -> Hash
             -> Table scan on t2  (cost=0.35 rows=1)
     
     1 row in set (0.01 sec)
     
     mysql> 
  ```

- Antijoin:
  ```sql
      (版本: 8.0.30-debug)
      mysql> EXPLAIN FORMAT=TREE SELECT * FROM t2   WHERE NOT EXISTS (SELECT * FROM t1 WHERE t1.c1 = t2.c1)\G
     *************************** 1. row ***************************
     EXPLAIN: -> Hash antijoin (t1.c1 = t2.c1)  (cost=0.70 rows=1)
         -> Table scan on t2  (cost=0.35 rows=1)
         -> Hash
             -> Table scan on t1  (cost=0.35 rows=1)
     
     1 row in set, 1 warning (0.00 sec)
     
     mysql> 
  ```
- Left outer join:
  ```sql
      (版本: 8.0.30-debug)
     mysql> EXPLAIN FORMAT=TREE SELECT * FROM t1 LEFT JOIN t2 ON t1.c1 = t2.c1\G
     *************************** 1. row ***************************
     EXPLAIN: -> Left hash join (t2.c1 = t1.c1)  (cost=0.70 rows=1)
         -> Table scan on t1  (cost=0.35 rows=1)
         -> Hash
             -> Table scan on t2  (cost=0.35 rows=1)
     
     1 row in set (0.00 sec)
     
     mysql> 
  ```

- Right outer join (observe that MySQL rewrites all right outer joins as left outer joins):
  ```sql
      (版本: 8.0.30-debug)
     mysql> EXPLAIN FORMAT=TREE SELECT * FROM t1 RIGHT JOIN t2 ON t1.c1 = t2.c1\G
     *************************** 1. row ***************************
     EXPLAIN: -> Left hash join (t1.c1 = t2.c1)  (cost=0.70 rows=1)
         -> Table scan on t2  (cost=0.35 rows=1)
         -> Hash
             -> Table scan on t1  (cost=0.35 rows=1)
     
     1 row in set (0.00 sec)
     
     mysql> 
  ```

&nbsp;&nbsp;By default, MySQL 8.0.18 and later employs hash joins whenever possible. It is possible to control whether hash joins are employed using one of the BNL and NO_BNL optimizer hints.(默认情况下，MySQL 8.0.18及以后版本尽可能使用散列连接。可以使用BNL和NO_BNL优化器提示之一来控制是否使用散列连接。)
> (MySQL 8.0.18 supported hash_join=on or hash_join=off as part of the setting for the optimizer_switch server system variable as well as the optimizer hints HASH_JOIN or NO_HASH_JOIN. In MySQL 8.0.19 and later, these no longer have any effect.)

&nbsp;&nbsp;Memory usage by hash joins can be controlled using the join_buffer_size system variable; a hash join cannot use more memory than this amount. When the memory required for a hash join exceeds the amount available, MySQL handles this by using files on disk. If this happens, you should be aware<sup>adj.知道的，明白的；察觉到的，意识到的；</sup> that the join may not succeed if a hash join cannot fit into memory and it creates more files than set for open_files_limit. To avoid such problems, make either of the following changes:(join_buffer_size系统变量控制着Hash Join内存使用。一个Hash Join使用的内存不能超过这个大小。当申请的内存超过这个大小，MySQL会使用磁盘文件来处理。如果发生这种情况，您应该意识到，如果散列连接无法装入内存，并且它创建的文件多于open_files_limit所设置的文件，则连接可能不会成功。为了避免这个情况，为避免此类问题，请进行以下更改之一:)
- Increase join_buffer_size so that the hash join does not spill<sup>v.（使）洒出，泼出，溢出；</sup> over to disk.
- Increase open_files_limit.

&nbsp;&nbsp;Beginning with MySQL 8.0.18, join buffers for hash joins are allocated incrementally<sup>adv.递增地；增值地</sup>; thus, you can set join_buffer_size higher without small queries allocating very large amounts of RAM, but outer joins allocate the entire buffer. In MySQL 8.0.20 and later, hash joins are used for outer joins (including antijoins and semijoins) as well, so this is no longer an issue.(从MySQL 8.0.18开始，哈希连接的连接缓冲区是增量分配的;因此，您可以将join_buffer_size设置得更高，而不会使小查询分配大量的RAM，但是外部连接会分配整个缓冲区。在MySQL 8.0.20及更高版本中，散列连接也用于外部连接(包括反连接和半连接)，因此这不再是一个问题。)

---

## 参考资料
1. [8.2.1.4 Hash Join Optimization](https://dev.mysql.com/doc/refman/8.0/en/hash-joins.html)