# Block Nested-Loop and Batched Key Access Joins
In MySQL, a Batched Key Access (BKA) Join algorithm is available that uses both index access to the joined table and a join buffer. The BKA algorithm supports inner join, outer join, and semijoin operations, including nested outer joins. Benefits of BKA include improved join performance due to more efficient table scanning. Also, the Block Nested-Loop (BNL) Join algorithm previously used only for inner joins is extended and can be employed for outer join and semijoin operations, including nested outer joins. (在MySQL中，通过索引访问连接表和join buffer的情况下可以使用BKA连接算法。BKA算法适用于Inner JOIN , outer join以及semijoin操作，包括嵌套外连接。BKA的好处包括由于更有效的表扫描而提高的连接性能。此外，以前仅用于inner join的BNL算法也得到了拓展，可以用于outer join 和 semijoin操作，包括嵌套的外连接)

&nbsp;&nbsp;The following sections discuss the join buffer management that underlies the extension of the original BNL algorithm, the extended BNL algorithm, and the BKA algorithm. For information about semijoin strategies, see Section 8.2.2.1, “Optimizing Subqueries, Derived Tables, and View References with Semijoin Transformations”(下面几节将讨论连接缓冲区管理，它是原始BNL算法、扩展BNL算法和BKA算法扩展的基础。)

## Join Buffer Management for Block Nested-Loop and Batched Key Access Algorithms
&nbsp;&nbsp;MySQL can employ<sup>v.雇用；使用，利用；忙于，</sup> join buffers to execute not only inner joins without index access to the inner table, but also outer joins and semijoins that appear after subquery flattening. Moreover<sup>adv.此外，而且</sup>, a join buffer can be effectively used when there is an index access to the inner table.(MySQL不仅可以在没有索引访问inner表的inner join中使用join buffer，还包括在子查询扁平化之后出现的外连接和半连接。而且，当对内部表进行索引访问时，可以有效地使用连接缓冲区)

&nbsp;&nbsp;The join buffer management code slightly<sup>稍微,轻微地</sup> more efficiently utilizes<sup>v.利用;使用;</sup> join buffer space when storing the values of the interesting row columns: No additional bytes are allocated in buffers for a row column if its value is NULL, and the minimum number of bytes is allocated for any value of the VARCHAR type.(在存储感兴趣的行列的值时，连接缓冲区管理代码稍微有效地利用了连接缓冲区空间: 如果值为NULL时，则不会分配空间;varchar类型只会分配最小数量的字节。)

&nbsp;&nbsp;The code supports two types of buffers, regular<sup>adj.恒定的，规则的（尤指间隔相同）；经常做（或发生）的，频繁的；</sup> and incremental<sup>adj.增加的，递增的；逐渐的，逐步的</sup>. Suppose<sup>v.推断，料想，猜想；假设，假定，设想；</sup> that join buffer B1 is employed to join tables t1 and t2 and the result of this operation is joined with table t3 using join buffer B2:(BKA支持两种类型的buffer,大小恒定的和大小会增加的。假设join buffer B1被用于t1 t2,并且连接的结果使用B2与t3相连接)
- A regular join buffer contains columns from each join operand<sup>n.[计] 操作数；[计] 运算对象</sup>. If B2 is a regular join buffer, each row r put into B2 is composed<sup>组成</sup> of the columns of a row r1 from B1 and the interesting columns of a matching row r2 from table t3.（常规的join buffer包含来自于每个连接对象的列。若B2是一个常规的join buffer,放入B2的每一行都由B1中的行的列以及t3中符合的行的列所组成）
- An incremental join buffer contains only columns from rows of the table produced by the second join operand. That is, it is incremental to a row from the first operand buffer. If B2 is an incremental join buffer, it contains the interesting columns of the row r2 together with a link to the row r1 from B1.（一个增量的join buffer仅包含由第二次连接操作产生行的列组成，也就是说，从第一个操作数缓冲区开始逐行增加。若B2是一个增量join buffer,他包含着行r2中感兴趣的列以及B1中行r1的链接）

&nbsp;&nbsp;[**第一次连接操作的缓冲区始终是常规缓冲区,往后都是增量的**]Incremental join buffers are always incremental relative to a join buffer from an earlier join operation, so the buffer from the first join operation is always a regular buffer. In the example just given, the buffer B1 used to join tables t1 and t2 must be a regular buffer.(增量连接缓冲区相对于早期连接操作的连接缓冲区始终是增量的，因此第一次连接操作的缓冲区始终是常规缓冲区。在刚刚给出的例子中，用于连接表t1和表t2的缓冲区B1必须是一个常规缓冲区)

&nbsp;&nbsp;Each row of the incremental buffer used for a join operation contains only the interesting columns of a row from the table to be joined. These columns are augmented with a reference to the interesting columns of the matched row from the table produced by the first join operand. Several rows in the incremental buffer can refer to the same row r whose columns are stored in the previous join buffers insofar as all these rows match row r.(用于连接操作的增量缓冲区的每一行只包含要连接的表中一行中感兴趣的列。通过引用第一个连接操作数生成的表中匹配行中感兴趣的列来扩充这些列。增量缓冲区中的几行可以引用同一行r，其列存储在以前的连接缓冲区中，只要所有这些行都与行r匹配。)

&nbsp;&nbsp;[**增量缓冲区减少被复制的次数**]Incremental buffers enable less frequent copying of columns from buffers used for previous join operations. This provides a savings in buffer space because in the general case a row produced by the first join operand can be matched by several rows produced by the second join operand. It is unnecessary to make several copies of a row from the first operand. Incremental buffers also provide a savings in processing time due to the reduction in copying time.(增量缓冲区允许更少地从先前连接操作使用的缓冲区复制列。这节省了缓冲区空间，因为在一般情况下，第一个连接操作数产生的一行可以与第二个连接操作数产生的几行相匹配。从第一个操作数开始对一行进行多次复制是不必要的。增量缓冲区还减少了复制时间，从而节省了处理时间。)

&nbsp;&nbsp;The block_nested_loop and batched_key_access flags of the optimizer_switch system variable control how the optimizer uses the Block Nested-Loop and Batched Key Access join algorithms. By default, block_nested_loop is on and batched_key_access is off. See Section 8.9.2, “Switchable Optimizations”. Optimizer hints may also be applied; see Optimizer Hints for Block Nested-Loop and Batched Key Access Algorithms.(系统变量optimizer_switch参数block_nested_loop batched_key_access控制这优化器如何使用BNL和BKA连接算法。默认情况下，block_nested_loop被打开，batched_key_access是关闭的。优化器提示也可以被引用，见: [Optimizer Hints for Block Nested-Loop and Batched Key Access Algorithms](#optimizer-hints-for-block-nested-loop-and-batched-key-access-algorithms))


## Block Nested-Loop Algorithm for Outer Joins and Semijoins
&nbsp;&nbsp;The original implementation of the MySQL BNL algorithm is extended to support outer join and semijoin operations.(原始的BNL算法被拓展为支持outer join 和 semijoin操作)

&nbsp;&nbsp;When these operations are executed with a join buffer, each row put into the buffer is supplied<sup>提供;供应;</sup> with a match flag.(当使用join buffer执行这些操作时，将为放入buffer的每一行提供一个匹配的标志)

&nbsp;&nbsp;[**缓冲区慢慢被拓展，并且一次次往后传递**]If an outer join operation is executed using a join buffer, each row of the table produced by the second operand is checked for a match against each row in the join buffer. When a match is found, a new extended row is formed<sup>v.构成；创立；</sup> (the original row plus columns from the second operand) and sent for further extensions by the remaining join operations. In addition, the match flag of the matched row in the buffer is enabled. After all rows of the table to be joined have been examined, the join buffer is scanned. Each row from the buffer that does not have its match flag enabled is extended by NULL complements<sup>v.补充（complement 的三单形式）</sup> (NULL values for each column in the second operand) and sent for further extensions by the remaining join operations.(如果使用join buffer来执行outer join操作，则将检查由第二个操作数生成的表的每一行是否与连接缓冲区中的每一行匹配。当一个匹配的行被找到，将形成一个新的拓展行（原始的行加上第二个操作数的列）并且由剩下的连接操作发送给进一步的拓展。此外，缓冲区匹配行的匹配标识被启用。再检查了要连接的表的所有行之后，将扫描连接缓冲区，缓冲区中未启用匹配标识的每一行都通过NULL补充（第二个操作数中的每列NULL值）进行拓展，并由剩余的连接操作发送进一步拓展)

&nbsp;&nbsp;The block_nested_loop flag of the optimizer_switch system variable controls how the optimizer uses the Block Nested-Loop algorithm. By default, block_nested_loop is on. See Section 8.9.2, “Switchable Optimizations”. Optimizer hints may also be applied; see Optimizer Hints for Block Nested-Loop and Batched Key Access Algorithms.

&nbsp;&nbsp;In EXPLAIN output, use of BNL for a table is signified<sup>n.所指（语言符号的意义）；意指</sup> when the Extra value contains Using join buffer (Block Nested Loop) and the type value is ALL, index, or range.

&nbsp;&nbsp;Some cases involving the combination of one or more subqueries with one or more left joins, particularly<sup>adv.非常，尤其；特别是；清楚地，明确地</sup> those returning many rows, may use BNL even though it is not ideal<sup>adj.理想的，最佳的；想象的;n.理想;典范</sup> in such instances. This is a known issue which is fixed in MySQL 8.0. If upgrading MySQL is not immediately feasible for you, you may wish to disable BNL in the meantime by setting optimizer_switch='block_nested_loop=off' or employing the NO_BNL optimizer hint to let the optimizer choose a better plan, using one or more index hints (see Section 8.9.4, “Index Hints”), or some combination of these, to improve the performance of such queries. (在某些情况下，涉及一个或多个子查询与一个或多个左连接的组合，特别是返回很多行的情况，可以使用BNL，即使他在这种情况下不是理想的。这是个已知的问题，已在MySQL8.0中被修复(如何修复的?通过[Hash Join Optimization](./009.Hash%20Join%20Optimization.md)修复的)。如果升级MySQL对你来说不是立即可行的，你可能希望在此期间禁用BNL，通过设置opeimizer_switch="block_nested_loop=off" 或使用NO_BNL优化器提示让优化器选择更好的计划，使用一个或多个索引提示，或者这些的一个组合，以提高此类查询的性能。)


## Batched Key Access Joins
&nbsp;&nbsp;MySQL implements a method of joining tables called the Batched Key Access (BKA) join algorithm. BKA can be applied when there is an index access to the table produced by the second join operand. Like the BNL join algorithm, the BKA join algorithm employs a join buffer to accumulate<sup>v.积累</sup> the interesting columns of the rows produced by the first operand of the join operation. Then the BKA algorithm builds keys to access the table to be joined for all rows in the buffer and submits these keys in a batch to the database engine for index lookups. The keys are submitted to the engine through the [Multi-Range Read (MRR)](../002.MySQL查询优化技术/004.MySQL之Multi-Range%20Read.md) interface (see Section 8.2.1.10, “Multi-Range Read Optimization”). After submission of the keys, the MRR engine functions perform lookups in the index in an optimal way, fetching the rows of the joined table found by these keys, and starts feeding the BKA join algorithm with matching rows. Each matching row is coupled with a reference to a row in the join buffer. (MySQL实现了一种被称为BKA的连接算法.当对第二个连接操作数生成的表进行索引访问时，可以应用BKA。BKA连接算法使用连接缓冲区来累计连接操作的第一个操作数产生的行中的匹配的列，然后，BKA算法为缓冲区的所有行构建键来访问要连接的表，并将这些键批量提交给数据库引擎进行索引查找。这些键通过MRR接口进行提交。提交键之后，MRR引擎函数将使用最优方式在引擎中执行查找，获取由这些键找到的连接表的行，并开始向BKA连接算法提供匹配的行。每个匹配的行都与对连接缓冲区中的一行的引用相藕合。)

&nbsp;&nbsp;When BKA is used, the value of join_buffer_size defines how large the batch of keys is in each request to the storage engine. The larger the buffer, the more sequential access is made to the right hand table of a join operation, which can significantly improve performance.(当使用BKA时，join_buffer_size的值定义了对存储引擎的每个请求中键的批处理有多大。缓冲区越大，对连接操作的右表进行的顺序访问就越多，这可以显著提高性能。)

&nbsp;&nbsp;For BKA to be used, the batched_key_access flag of the optimizer_switch system variable must be set to on. BKA uses MRR, so the mrr flag must also be on. Currently, the cost estimation<sup>n.估计，估算；判断，评价；尊重，尊敬</sup> for MRR is too pessimistic<sup>adj.悲观的</sup>. Hence, it is also necessary for mrr_cost_based to be off for BKA to be used. The following setting enables BKA:
> mysql> SET optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';

&nbsp;&nbsp;There are two scenarios<sup>n.情节；脚本；情景介绍（scenario 的复数）</sup> by which MRR functions execute:
- The first scenario is used for conventional<sup>adj.依照惯例的，遵循习俗的；老一套的，习惯的</sup> disk-based storage engines such as InnoDB and MyISAM. For these engines, usually the keys for all rows from the join buffer are submitted to the MRR interface at once <sup>at once: 立刻;马上;</sup>. Engine-specific MRR functions perform index lookups for the submitted keys, get row IDs (or primary keys) from them, and then fetch rows for all these selected row IDs one by one by request from BKA algorithm. Every row is returned with an association reference that enables access to the matched row in the join buffer. The rows are fetched by the MRR functions in an optimal way: They are fetched in the row ID (primary key) order. This improves performance because reads are in disk order rather than random order.

- The second scenario is used for remote storage engines such as NDB. A package of keys for a portion<sup>一部分</sup> of rows from the join buffer, together with their associations, is sent by a MySQL Server (SQL node) to NDB Cluster data nodes. In return, the SQL node receives a package (or several packages) of matching rows coupled<sup>耦合的;成对的;</sup> with corresponding associations. The BKA join algorithm takes these rows and builds new joined rows. Then a new set of keys is sent to the data nodes and the rows from the returned packages are used to build new joined rows. The process continues until the last keys from the join buffer are sent to the data nodes, and the SQL node has received and joined all rows matching these keys. This improves performance because fewer key-bearing packages sent by the SQL node to the data nodes means fewer round trips between it and the data nodes to perform the join operation.

&nbsp;&nbsp;With the first scenario, a portion of the join buffer is reserved to store row IDs (primary keys) selected by index lookups and passed as a parameter to the MRR functions.(在第一个场景中，保留一部分连接缓冲区来存储由索引查找选择的行id(主键)，并将其作为参数传递给MRR函数。)

&nbsp;&nbsp;There is no special buffer to store keys built for rows from the join buffer. Instead, a function that builds the key for the next row in the buffer is passed as a parameter to the MRR functions.(没有特殊的缓冲区来存储为连接缓冲区中的行构建的键。相反，将为缓冲区中的下一行构建键的函数作为参数传递给MRR函数。)

&nbsp;&nbsp;In EXPLAIN output, use of BKA for a table is signified when the Extra value contains Using join buffer (Batched Key Access) and the type value is ref or eq_ref.

## Optimizer Hints for Block Nested-Loop and Batched Key Access Algorithms
&nbsp;&nbsp;In addition to using the optimizer_switch system variable to control optimizer use of the BNL and BKA algorithms session-wide, MySQL supports optimizer hints to influence<sup>影响</sup> the optimizer on a per-statement basis. See Section 8.9.3, “Optimizer Hints”.

&nbsp;&nbsp;To use a BNL or BKA hint to enable join buffering for any inner table of an outer join, join buffering must be enabled for all inner tables of the outer join.(要使用BNL或BKA提示为外部连接的任何内部表启用连接缓冲，必须为外部连接的所有内部表启用连接缓冲。)


---

## 参考资料
1. [ Block Nested-Loop and Batched Key Access Joins](https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html)