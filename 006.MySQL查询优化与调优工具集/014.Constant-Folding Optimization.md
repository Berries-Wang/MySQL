# Constant-Folding Optimization (常量折叠优化) (MySQL8+)
## 摘要
1. 常量折叠即将无效的条件去除。
2. 将耗性能的等值查询替换为范围查询
## 文档
&nbsp;&nbsp;Comparisons between constants and column values in which the constant value is out of range or of the wrong type with respect to the column type are now handled once during query optimization rather row-by-row than during execution. The comparisons that can be treated in this manner are >, >=, <, <=, <>/!=, =, and <=>. (常量和超出范围的列值之间的比较，或者常量的类型与列的类型不一致，现在在查询优化期间只处理一次，而不是在执行期间逐行处理。可以用这种方式处理的比较是  >, >=, <, <=, <>/!=, =, 及 <=>)

&nbsp;&nbsp;Consider the table created by the following statement: (考虑下表)
```sql
   CREATE TABLE t (c TINYINT UNSIGNED NOT NULL);
```
+ The WHERE condition in the query SELECT * FROM t WHERE c < 256 contains the integral constant 256 which is out of range for a TINYINT UNSIGNED column. Previously, this was handled by treating both operands as the larger type, but now, since any allowed value for c is less than the constant, the WHERE expression can instead be folded as WHERE 1, so that the query is rewritten as SELECT * FROM t WHERE 1. (查询中的WHERE条件SELECT * FROM t WHERE c < 256包含整数常数256，它超出了TINYINT无符号列的范围。以前，这是通过将两个操作数都视为较大的类型来处理的，但现在，由于c的任何允许值都小于常量，WHERE表达式可以折叠为WHERE 1，因此查询被重写为SELECT * FROM t WHERE 1)

&nbsp;&nbsp;This makes it possible for the optimizer to remove the WHERE expression altogether. If the column c were nullable (that is, defined only as TINYINT UNSIGNED) the query would be rewritten like this:(这使得优化器可以完全删除WHERE表达式。如果列c可为空(即仅定义为TINYINT UNSIGNED)，查询将重写为:)
```sql
    SELECT * FROM t WHERE c IS NOT NULL
```

&nbsp;&nbsp;Folding is performed for constants compared to supported MySQL column types as follows:(与MySQL支持的列类型相比，对常量执行折叠，如下所示:)
-  Integer column type.  Integer types are compared with constants of the following types as described here:(Integer列类型。整数类型与常量的比较如下所述)
   + Integer value.  If the constant is out of range for the column type, the comparison is folded to 1 or IS NOT NULL, as already shown.(整数值。如果常量超出了列类型的范围，比较结果会被折叠为1或者IS NOT NULL，如上所示。)
    ```txt 
       If the constant is a range boundary, the comparison is folded to =. For example (using the same table as already defined):(如果常量是范围的边界，比较会折叠为=;例如(使用已经定义的相同的表):)
       mysql> EXPLAIN SELECT * FROM t WHERE c >= 255;
       *************************** 1. row ***************************
                  id: 1
         select_type: SIMPLE
               table: t
          partitions: NULL
                type: ALL
       possible_keys: NULL
                 key: NULL
             key_len: NULL
                 ref: NULL
                rows: 5
            filtered: 20.00
               Extra: Using where
       1 row in set, 1 warning (0.00 sec)
       
       mysql> SHOW WARNINGS; # 直接优化为 = 255.
       *************************** 1. row ***************************
         Level: Note
          Code: 1003
       Message: /* select#1 */ select `test`.`t`.`ti` AS `ti` from `test`.`t` where (`test`.`t`.`ti` = 255)
       1 row in set (0.00 sec)
    ```
   + Floating- or fixed-point value.  If the constant is one of the decimal types (such as DECIMAL, REAL, DOUBLE, or FLOAT) and has a nonzero decimal portion, it cannot be equal; fold accordingly. For other comparisons, round up or down to an integer value according to the sign, then perform a range check and handle as already described for integer-integer comparisons.(浮点值或定点值。如果常量是小数类型之一（如decimal、REAL、DOUBLE或FLOAT），并且具有非零小数部分，则它不能相等；相应地折叠。对于其他比较，根据符号向上或向下取整到一个整数值，然后执行范围检查和处理，如前面针对整数-整数比较所述。)
      + A REAL value that is too small to be represented as DECIMAL is rounded to .01 or -.01 depending on the sign, then handled as a DECIMAL.(太小而不能表示为DECIMAL的REAL值会根据符号四舍五入到.01或-.01，然后作为DECIMAL处理。)
   + String types.  Try to interpret the string value as an integer type, then handle the comparison as between integer values. If this fails, attempt to handle the value as a REAL.(字符串类型。尝试将字符串值解释为整数类型，然后处理整数值之间的比较。如果失败，尝试将该值作为REAL处理。)
- DECIMAL or REAL column.  Decimal types are compared with constants of the following types as described here:
   + Integer value.  Perform a range check against the column value's integer part. If no folding results, convert the constant to DECIMAL with the same number of decimal places as the column value, then check it as a DECIMAL (see next). (对列值的整数部分执行范围检查。如果没有折叠结果，则将该常量转换为与列值具有相同小数位数的浮点数，然后将他作为浮点数比较(参见下一节)。)
   + DECIMAL or REAL value.  Check for overflow (that is, whether the constant has more digits in its integer part than allowed for the column's decimal type). If so, fold.（DECIMAL或REAL值。检查是否存在溢出（即，常量的整数部分的位数是否超过列的十进制类型所允许的位数）。如果是，请折叠。）
     - If the constant has more significant fractional digits than column's type, truncate the constant. If the comparison operator is = or <>, fold. If the operator is >= or <=, adjust the operator due to truncation. For example, if column's type is DECIMAL(3,1), SELECT * FROM t WHERE f >= 10.13 becomes SELECT * FROM t WHERE f > 10.1.（如果常量的有效小数位数多于列的类型，则截断该常量。如果比较运算符为=或<>，请折叠。如果运算符为>=或<=，则由于截断而调整运算符。例如，如果列的类型为DECIMAL（3,1），则SELECT*FROM t WHERE f>=10.13将变为SELECT*FROM t WHERE f>10.1。）
     - If the constant has fewer decimal digits than the column's type, convert it to a constant with same number of digits. For underflow of a REAL value (that is, too few fractional digits to represent it), convert the constant to decimal 0.（如果常量的小数位数少于列的类型，请将其转换为具有相同位数的常量。对于REAL值的下溢（也就是说，小数位数太少而无法表示它），请将常数转换为十进制0。）
   + String value.  If the value can be interpreted as an integer type, handle it as such. Otherwise, try to handle it as REAL.
- FLOAT or DOUBLE column.  FLOAT(m,n) or DOUBLE(m,n) values compared with constants are handled as follows:
   + If the value overflows the range of the column, fold.（如果值溢出列的范围，请折叠）
   + If the value has more than n decimals, truncate, compensating during folding. For = and <> comparisons, fold to TRUE, FALSE, or IS [NOT] NULL as described previously; for other operators, adjust the operator. （如果值的小数位数超过n，则截断，在折叠过程中进行补偿。对于=和<>比较，如前所述，折叠为TRUE、FALSE或IS[NOT]NULL；对于其他操作员，请调整操作员。）
   + If the value has more than m integer digits, fold.（如果值的整数位数超过m，请折叠）

&nbsp;&nbsp;Limitations.  This optimization cannot be used in the following cases:
- With comparisons using BETWEEN or IN.
- With BIT columns or columns using date or time types.
- During the preparation phase for a prepared statement, although it can be applied during the optimization phase when the prepared statement is actually executed. This due to the fact that, during statement preparation, the value of the constant is not yet known. (在准备语句的准备阶段，尽管它可以在实际执行准备语句的优化阶段应用。这是由于在语句准备过程中，常量的值尚不清楚。)

## 参考资料
1. [8.2.1.14 Constant-Folding Optimization](https://dev.mysql.com/doc/refman/8.2/en/constant-folding-optimization.html)