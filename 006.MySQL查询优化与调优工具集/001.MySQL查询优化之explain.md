# EXPLAIN
## EXPLAIN Statement
```sql
  {EXPLAIN | DESCRIBE | DESC}
    tbl_name [col_name | wild]

  {EXPLAIN | DESCRIBE | DESC}
      [explain_type]
      {explainable_stmt | FOR CONNECTION connection_id}
  
  {EXPLAIN | DESCRIBE | DESC} ANALYZE [FORMAT = TREE] select_statement
  
  explain_type: {
      FORMAT = format_name
  }
  
  format_name: {
      TRADITIONAL
    | JSON
    | TREE
  }
  
  explainable_stmt: {
      SELECT statement
    | TABLE statement
    | DELETE statement
    | INSERT statement
    | REPLACE statement
    | UPDATE statement
  }
```
---

## 功能
可以使用explain来获取关于**查询执行计划**的信息，即:explain命令是查看查询优化器如何决定执行查询的主要方法，这个功能存在局限性，并不总会说出真相，但是他的输出是可以获取的最好信息。
   + explain 仅仅能解释SELECT查询(高版本中也能支持其他的)，不能对存储过程，INSERT,UPDATE,DELETE以及其他的语句做解释
## 使用方式
要使用explain，则只需要在查询的select关键字之前添加EXPLAIN即可。但是，需要注意的是：
   1. MySQL会在查询上设置一个标记，当执行查询是，这个标记会使其**返回关于在查询计划中每一步的信息，而不是执行他**(不是真正执行)
   2. 他会返回一行或者多行信息，显示出执行计划中的每一部分和执行顺序。
   3. 在查询中，每个表在输出中只有一行。若：
        + 若查询的是两个表的联接，则输出中将有两行。
        + 别名表单算一个表，因此，若将一个表与自己联接，输出行中也会有两行。
        + 这里的表意义较广，可以是一个子查询，一个union结果等。
### 请注意
**认为增加EXPLAIN时MySQL不会执行查询，这是错误的**，如果查询在FROM子句中包括子查询，则MySQL实际上会执行子查询，将其结果放在一个临时表中，然后完成**外层查询优化**，他必须在可以完成外层查询优化之前处理掉所有类似的子查询，这对于EXPLAIN是必须要做的(可能会在高版本中去掉该限制)。
### EXPLAIN只是一个近似的结果，别无其他，有时候他是一个很好的近似，但在其他时候，可能与真相相差甚远。见如下限制：
  1. explain不会反馈触发器，存储过程或者UDF会如何影响查询
  2. 不支持存储过程，仅支持select操作
  3. 不会反馈MySQL在执行查询的时候所做的特定优化
  4. 不会反馈关于查询的执行计划的所有信息
  5. 不区分具有相同名字的事物。例如，他对内存排序和临时文件都使用filesort，并且对磁盘上和内存中的临时表都显示为Using Temporary
  6. 可能会误导。例如，对一个有着很小limit的查询显示为全索引扫描。

---

## EXPLAIN 输出
&nbsp;&nbsp;EXPLAIN的每个输出行提供关于一个表的信息。每行包含表“EXPLAIN Output Columns”中总结的值，并在表中进行了更详细的描述。列名显示在表的第一列中;第二列提供了当使用FORMAT=JSON时在输出中显示的等价属性名。
### EXPLAIN Output Columns
|Column|	JSON Name|	Meaning|
|---|---|---|
|id	              |select_id     |The SELECT identifier|
|select_type	    |None          |The SELECT type|
|table	          |table_name    |The table for the output row|
|partitions       |partitions    |The matching partitions|
|type             |access_type	 |The join type|
|possible_keys	  |possible_keys |The possible indexes to choose|
|key              |key           |The index actually chosen|
|key_len          |key_length    |The length of the chosen key|
|ref	            |ref           |The columns compared to the index|
|rows             |rows	         |Estimate of rows to be examined|
|filtered         |filtered      |Percentage of rows filtered by table condition|
|Extra	          |None          |Additional information|

```txt
   # Attensions
     a. JSON properties which are NULL are not displayed in JSON-formatted EXPLAIN output.
```
### EXPLAIN OUTPUT 列说明
#### id (JSON name: select_id)
&nbsp;&nbsp;The SELECT identifier. This is the sequential number of the SELECT within the query. The value can be NULL if the row refers to the union result of other rows. In this case, the table column shows a value like <unionM,N> to indicate that the row refers to the union of the rows with id values of M and N.(SELECT标识符。这是查询中的SELECT序号。如果该行引用其他行的并集结果时该值可能为NULL。在这种情况下,这一列可能会展示类似于<unionM,N>这样一个值，以指示该行引用 id 值为 M 和 N 的行的并集)

#### select_type (JSON name: none)
&nbsp;&nbsp;The type of SELECT, which can be any of those shown in the following table. A JSON-formatted EXPLAIN exposes the SELECT type as a property of a query_block, unless it is SIMPLE or PRIMARY. The JSON names (where applicable) are also shown in the table.(SELECT的类型，可以是下表中所示的任何类型。json格式的EXPLAIN将SELECT类型作为query_block的属性公开，除非它是SIMPLE或PRIMARY。JSON名称(如适用)也显示在表中)
|select_type Value|	JSON Name|	Meaning|
|---|---|---|
|SIMPLE	             |None	                     |Simple SELECT (not using UNION or subqueries)|
|PRIMARY	             |None	                     |Outermost(最外层) SELECT|
|UNION	             |None	                     |Second or later SELECT statement in a UNION|
|DEPENDENT UNION      |dependent (true)            |Second or later SELECT statement in a UNION, dependent on outer query|
|UNION RESULT	       |union_result	               |Result of a UNION.|
|SUBQUERY	          |None	                     |First SELECT in subquery|
|DEPENDENT SUBQUERY   |dependent (true)            |First SELECT in subquery, dependent on outer query|
|DERIVED	             |None	                     |Derived(派生的) table <sub>Derived table实际上是一种特殊的subquery，它位于SQL语句中FROM子句里面，可以看做是一个单独的表。MySQL5.7之前的处理都是对Derived table进行Materialize，生成一个临时表保存Derived table的结果，然后利用临时表来协助完成其他父查询的操作，比如JOIN等操作。MySQL5.7中对Derived table做了一个新特性（MySQL5.7 Merge derived table特性:见附录'Merge Derived Table'）。该特性允许将符合条件的Derived table中的子表与父查询的表合并进行直接JOIN。</sub>|
|DEPENDENT DERIVED    |dependent (true)            |Derived table dependent on another table|
|MATERIALIZED	       |materialized_from_subquery	|Materialized(实体化) subquery (说明MySQL对于此查询会创建临时表)|
|UNCACHEABLE SUBQUERY |cacheable (false)	         |A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query(不能将结果缓存的子查询，必须重新计算外部查询的每一行)|
|UNCACHEABLE UNION	 |cacheable (false)	         |The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)|

#### table (JSON name: table_name)
&nbsp;&nbsp; The name of the table to which the row of output refers. This can also be one of the following values:(输出行所指向的表的名称。这也可以是以下值之一)
- \<unionM,N\>: The row refers to the union of the rows with id values of M and N.(行是指id值为M和N的行的并集。)
- \<derivedN\>: The row refers to the derived table result for the row with an id value of N. A derived table may result, for example, from a subquery in the FROM clause.(The row refers to the derived table result for the row with an id value of N. A derived table may result, for example, from a subquery in the FROM clause.)
- \<subqueryN\>: The row refers to the result of a materialized subquery for the row with an id value of N.(行引用id值为N的行的物化子查询的结果)


#### partitions (JSON name: partitions)
&nbsp;&nbsp;The partitions from which records would be matched by the query. The value is NULL for nonpartitioned tables. (查询将从其中匹配记录的分区。对于非分区表，该值为NULL。)

#### type (JSON name: access_type)
&nbsp;&nbsp;The join type. For descriptions of the different types, see EXPLAIN Join Types.(连接类型，见附录 'EXPLAIN Join Types')

#### possible_keys (JSON name: possible_keys)
&nbsp;&nbsp;The possible_keys column indicates the indexes from which MySQL can choose to find the rows in this table. Note that this column is totally independent of the order of the tables as displayed in the output from EXPLAIN. That means that some of the keys in possible_keys might not be usable in practice with the generated table order.（possible_keys列表示MySQL可以从中选择查找该表中的行的索引。注意，这一列完全独立于EXPLAIN输出中显示的表的顺序。这意味着'possible_keys'中的一些索引在实际中可能无法用于生成的表顺序）

#### key (JSON name: key)
&nbsp;&nbsp;The key column indicates the key (index) that MySQL actually decided to use. If MySQL decides to use one of the possible_keys indexes to look up rows, that index is listed as the key value.(key列表示MySQL实际决定使用的键(索引)。如果MySQL决定使用一个'possible_keys'索引来查找行，那么该索引将被列为键值。).

&nbsp;&nbsp;It is possible that key may name an index that is not present in the possible_keys value. This can happen if none of the possible_keys indexes are suitable for looking up rows, but all the columns selected by the query are columns of some other index. That is, the named index covers the selected columns, so although it is not used to determine which rows to retrieve, an index scan is more efficient than a data row scan.(可能索引的名称没有出现在possible_keys中。这种情况出现在possible_keys中的索引都不适合查找行，但是所有的列可以通过其他索引查询到，也就是说，索引覆盖所选的列，因此尽管不使用索引来确定要检索哪些行，但索引扫描比数据行扫描更有效)

&nbsp;&nbsp;For InnoDB, a secondary index might cover the selected columns even if the query also selects the primary key because InnoDB stores the primary key value with each secondary index. If key is NULL, MySQL found no index to use for executing the query more efficiently.(对于InnoDB，即使查询也选择了主键，二级索引也可能覆盖所选的列，因为InnoDB将主键值存储在每个二级索引中。如果key为NULL, MySQL找不到索引来更有效地执行查询。)

&nbsp;&nbsp;To force MySQL to use or ignore an index listed in the possible_keys column, use FORCE INDEX, USE INDEX, or IGNORE INDEX in your query.(强制使用或忽略索引)

#### key_len (JSON name: key_length)
&nbsp;&nbsp;The key_len column indicates the length of the key that MySQL decided to use. The value of key_len enables you to determine how many parts of a multiple-part key MySQL actually uses. If the key column says NULL, the key_len column also says NULL.(key_len 字段表明MySQL决定使用key的多长部分，key_len的值让你确定了多字段索引的多少部分被MySQL实际使用。如果key列为NULL，那么key_len列也是NULL)

&nbsp;&nbsp;Due to the key storage format, the key length is one greater for a column that can be NULL than for a NOT NULL colum。(由于索引存储格式的原因，允许为NULL列的长度比NOT NULL列的长度大1)

#### ref (JSON name: ref)
&nbsp;&nbsp;The ref column shows which columns or constants are compared to the index named in the key column to select rows from the table.(ref列显示哪些列或常量与key列指定的索引进行比较，以便从表中选择行)

&nbsp;&nbsp;If the value is func, the value used is the result of some function. To see which function, use SHOW WARNINGS following EXPLAIN to see the extended EXPLAIN output. The function might actually be an operator such as an arithmetic<sup>算数</sup> operator.

#### rows (JSON name: rows)
&nbsp;&nbsp;The rows column indicates the number of rows MySQL believes it must examine<sup>v.检查，调查；考核，测验；</sup> to execute the query.

&nbsp;&nbsp;For InnoDB tables, this number is an estimate<sup>v.估计；判断，评价n.估计，估价；估价单；看法，判断</sup>, and may not always be exact<sup>adj.确切的，精确的；严谨的，</sup>.

#### filtered (JSON name: filtered)
&nbsp;&nbsp;The filtered column indicates an estimated percentage of table rows that are filtered by the table condition. The maximum value is 100, which means no filtering of rows occurred. Values decreasing<sup>v.减少；缩减（decrease 的现在分词）</sup> from 100 indicate increasing amounts of filtering. rows shows the estimated number of rows examined<sup>v.检查；调查（examine 的过去式和过去分词）</sup> and rows × filtered shows the number of rows that are joined with the following table. For example, if rows is 1000 and filtered is 50.00 (50%), the number of rows to be joined with the following table is 1000 × 50% = 500. (那么有多少行被过滤掉了呢? 1-${filtered}) (filtered列表明被表条件过滤掉行数的估计百分比，最大值是100,这意味着没有对行进行过滤。从100开始递减表示过滤量在增加。rows行显示检查的估计行数，rows x filtered显示与下表连接的行数。)

#### Extra (JSON name: none)
&nbsp;&nbsp;This column contains additional information about how MySQL resolves the query. For descriptions of the different values,see ‘附录: EXPLAIN Extra Information.’

&nbsp;&nbsp;There is no single JSON property corresponding to the Extra column; however, values that can occur in this column are exposed as JSON properties, or as the text of the message property.(没有单独的JSON属性对应于Extra列;但是，可以在此列中出现的值将作为JSON属性或消息属性的文本公开。)


---
## 附录
### EXPLAIN Extra Information
&nbsp;&nbsp;The Extra column of EXPLAIN output contains additional information about how MySQL resolves the query. The following list explains the values that can appear in this column. Each item also indicates for JSON-formatted output which property displays the Extra value. For some of these, there is a specific property. The others display as the text of the message property.(该Extra列包含着MySQL解析这个查询的额外信息，接下来的列表中的值可能会出现在该列中。对于json格式的输出，每个项还指示哪个属性显示Extra值。对于其中的一些，有一个特定的属性。其他显示为消息属性的文本)

&nbsp;&nbsp;If you want to make your queries as fast as possible, look out for Extra column values of Using filesort and Using temporary, or, in JSON-formatted EXPLAIN output, for using_filesort and using_temporary_table properties equal to true.(如果想要使你的查询尽可能快，查一下Extra列的值是否包含Using filesort 和 Using temporary，或者在JSON-formatted的Extra的输出中，using_filesort 和 using_temporary_table属性是否为true)

#### Backward index scan (JSON: backward_index_scan)
&nbsp;&nbsp;The optimizer is able to use a descending index <sup>降序索引</sup> on an InnoDB table. Shown together with Using index. 

#### Child of 'table' pushed join@1 (JSON: message text)
&nbsp;&nbsp;This table is referenced as the child of table in a join that can be pushed down to the NDB kernel. Applies only in NDB Cluster, when pushed-down joins are enabled. See the description of the ndb_join_pushdown server system variable for more information and examples.

#### const row not found (JSON property: const_row_not_found)
&nbsp;&nbsp;For a query such as SELECT ... FROM tbl_name, the table was empty.

#### Deleting all rows (JSON property: message)
&nbsp;&nbsp;For DELETE, some storage engines (such as MyISAM) support a handler method that removes all table rows in a simple and fast way. This Extra value is displayed if the engine uses this optimization.

#### Distinct (JSON property: distinct)
&nbsp;&nbsp;MySQL is looking for distinct values, so it stops searching for more rows for the current row combination after it has found the first matching row.(MySQL正在寻找不同的值。因此，在找到第一个匹配行之后，它停止为当前行组合搜索更多行。)

#### FirstMatch(tbl_name) (JSON property: first_match)
&nbsp;&nbsp;The semijoin<sup>n.半连接：数据库关系代数中的一种操作，用于组合两个关系，结果包含第一个关系中满足连接条件的元组。</sup> FirstMatch join shortcutting<sup>简化</sup> strategy is used for tbl_name.
```sql
  半连接主要场景：检查一个结果集（外表）的记录是否在另外一个结果集（子表）中存在匹配记录，半连接仅关注”子表是否存在匹配记录”，而并不考虑”子表存在多少条匹配记录”，半连接的返回结果集仅使用外表的数据集，查询语句中IN或EXISTS语句常使用半连接来处理。
  MySQL 5种半连接策略:
    1、DuplicateWeedout
    2、FirstMatch
    3、LooseScan
    4、Materializelookup
    5、MaterializeScan
```

#### Full scan on NULL key (JSON property: message)
&nbsp;&nbsp;This occurs for subquery optimization as a fallback strategy when the optimizer cannot use an index-lookup access method.(当优化器不能使用索引查找访问方法时，子查询优化作为回退策略会出现这种情况。)

#### Impossible HAVING (JSON property: message)
&nbsp;&nbsp;The HAVING clause is always false and cannot select any rows.

#### Impossible WHERE (JSON property: message)
&nbsp;&nbsp;The WHERE clause is always false and cannot select any rows.

#### Impossible WHERE noticed after reading const tables (JSON property: message)
&nbsp;&nbsp;MySQL has read all const (and system) tables and notice that the WHERE clause is always false.

#### LooseScan(m..n) (JSON property: message)
&nbsp;&nbsp;The semijoin LooseScan strategy is used. m and n are key part numbers.

#### No matching min/max row (JSON property: message)
&nbsp;&nbsp;No row satisfies<sup>v.满足（satisfy 的第三人称单数）</sup> the condition for a query such as SELECT MIN(...) FROM ... WHERE condition.

#### no matching row in const table (JSON property: message)
&nbsp;&nbsp;For a query with a join, there was an empty table or a table with no rows satisfying<sup>adj.令人满意的；令人满足的</sup> a unique index condition.

#### No matching rows after partition pruning<sup>v.修剪</sup> (JSON property: message)
&nbsp;&nbsp;For DELETE or UPDATE, the optimizer found nothing to delete or update after partition pruning. It is similar in meaning to Impossible WHERE for SELECT statements.

#### No tables used (JSON property: message)
&nbsp;&nbsp;The query has no FROM clause, or has a FROM DUAL clause.

&nbsp;&nbsp;For INSERT or REPLACE statements, EXPLAIN displays this value when there is no SELECT part. For example, it appears for EXPLAIN INSERT INTO t VALUES(10) because that is equivalent<sup>adj.等同的，等效的.n.对等的人（或事物），对应的人（或事物）</sup> to EXPLAIN INSERT INTO t SELECT 10 FROM DUAL.

#### Not exists (JSON property: message)
&nbsp;&nbsp;MySQL was able to do a LEFT JOIN optimization on the query and does not examine<sup>v.检查，调查；考核，测验；（医生）诊察；</sup> more rows in this table for the previous row combination after it finds one row that matches the LEFT JOIN criteria<sup>n.（评判或做决定的）标准，准则，尺度 （criterion 的复数）</sup>. Here is an example of the type of query that can be optimized this way:

```sql
    SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id
       WHERE t2.id IS NULL;

     Assume that t2.id is defined as NOT NULL. In this case, MySQL scans t1 and looks up the rows in t2 using the values of t1.id. If MySQL finds a matching row in t2, it knows that t2.id can never be NULL, and does not scan through the rest of the rows in t2 that have the same id value. In other words, for each row in t1, MySQL needs to do only a single lookup in t2, regardless(adv.不顾，不加理会；不管怎样，无论如何) of how many rows actually match in t2.
     
     In MySQL 8.0.17 and later, this can also indicate that a WHERE condition of the form NOT IN (subquery) or NOT EXISTS (subquery) has been transformed internally into an antijoin. This removes the subquery and brings its tables into the plan for the topmost(adj.最高的；顶端的) query, providing improved cost planning. By merging semijoins and antijoins, the optimizer can reorder tables in the execution plan more freely, in some cases resulting in a faster plan.
     > antijoin: n.反连接：数据库操作中的一种连接类型，用于返回一个表中与另一个表中没有匹配项的记录。
     
     You can see when an antijoin transformation is performed for a given query by checking the Message column from SHOW WARNINGS following execution of EXPLAIN, or in the output of EXPLAIN FORMAT=TREE.
```

#### Plan isn't ready yet (JSON property: none)
&nbsp;&nbsp;This value occurs with EXPLAIN FOR CONNECTION when the optimizer has not finished creating the execution plan for the statement executing in the named connection. If execution plan output comprises<sup>包含;由..组成</sup> multiple<sup>adj.多个的，多种的；</sup> lines, any or all of them could have this Extra value, depending on the progress of the optimizer in determining the full execution plan.

#### Range checked for each record (index map: N) (JSON property: message)
&nbsp;&nbsp;MySQL found no good index to use, but found that some of indexes might be used after column values from preceding<sup>adj.先前的，前面的</sup> tables are known. For each row combination in the preceding tables, MySQL checks whether it is possible to use a range or index_merge access method to retrieve<sup>v.找回，收回；检索（储存于计算机的信息）</sup> rows. This is not very fast, but is faster than performing a join with no index at all. The applicability<sup>n. 适用性；适应性</sup> criteria are as described in Section 8.2.1.2, “Range Optimization”, and Section 8.2.1.3, “Index Merge Optimization”, with the exception that all column values for the preceding table are known and considered to be constants.

&nbsp;&nbsp;Indexes are numbered beginning with 1, in the same order as shown by SHOW INDEX for the table. The index map value N is a bitmask value that indicates which indexes are candidates<sup>n. 候选人；申请者；应征人员（candidate 的复数）</sup>. For example, a value of 0x19 (binary 11001) means that indexes 1, 4, and 5 are considered.

#### Recursive (JSON property: recursive)
&nbsp;&nbsp;This indicates that the row applies to the recursive<sup>adj. [数] 递归的；循环的</sup> SELECT part of a recursive common table expression. See Section 13.2.20, “WITH (Common Table Expressions)”.

#### Rematerialize (JSON property: rematerialize)
&nbsp;&nbsp;Rematerialize (X,...) is displayed in the EXPLAIN row for table T, where X is any lateral derived table whose rematerialization is triggered when a new row of T is read. For example:
```sql
     SELECT
       ...
     FROM
       t,
       LATERAL (derived table that refers to t) AS dt
     ...
```
&nbsp;&nbsp;The content of the derived table is rematerialized to bring it up to date each time a new row of t is processed by the top query.

#### Scanned N databases (JSON property: message)
&nbsp;&nbsp;This indicates how many directory scans the server performs when processing a query for INFORMATION_SCHEMA tables, as described in Section 8.2.3, “Optimizing INFORMATION_SCHEMA Queries”. The value of N can be 0, 1, or all.

#### Select tables optimized away (JSON property: message)
&nbsp;&nbsp;The optimizer determined 1) that at most one row should be returned, and 2) that to produce this row, a deterministic<sup>确定性的</sup> set of rows must be read. When the rows to be read can be read during the optimization phase (for example, by reading index rows), there is no need to read any tables during query execution.

&nbsp;&nbsp;The first condition is fulfilled when the query is implicitly<sup>adv. 含蓄地，暗中地；绝对地</sup> grouped (contains an aggregate function but no GROUP BY clause). The second condition is fulfilled when one row lookup is performed per index used. The number of indexes read determines the number of rows to read.

&nbsp;&nbsp;Consider the following implicitly grouped query:
```sql
    SELECT MIN(c1), MIN(c2) FROM t1;
```

&nbsp;&nbsp;Suppose that MIN(c1) can be retrieved by reading one index row and MIN(c2) can be retrieved by reading one row from a different index. That is, for each column c1 and c2, there exists an index where the column is the first column of the index. In this case, one row is returned, produced by reading two deterministic<sup>adj. 确定性的；命运注定论的</sup> rows.

&nbsp;&nbsp;This Extra value does not occur if the rows to read are not deterministic. Consider this query:
```sql
   SELECT MIN(c2) FROM t1 WHERE c1 <= 10;
```

&nbsp;&nbsp;Suppose that (c1, c2) is a covering index. Using this index, all rows with c1 <= 10 must be scanned to find the minimum c2 value. By contrast, consider this query:
```sql
   SELECT MIN(c2) FROM t1 WHERE c1 = 10;
```

&nbsp;&nbsp;In this case, the first index row with c1 = 10 contains the minimum c2 value. Only one row must be read to produce the returned row.

&nbsp;&nbsp;For storage engines that maintain an exact row count per table (such as MyISAM, but not InnoDB), this Extra value can occur for COUNT(*) queries for which the WHERE clause is missing or always true and there is no GROUP BY clause. (This is an instance of an implicitly grouped query where the storage engine influences<sup>n. 影响，影响力；作用（influence 的复数形式）</sup> whether a deterministic number of rows can be read.)

#### Skip_open_table, Open_frm_only, Open_full_table (JSON property: message)
&nbsp;&nbsp;These values indicate file-opening optimizations that apply to queries for INFORMATION_SCHEMA tables.
- Skip_open_table: Table files do not need to be opened. The information is already available from the data dictionary.
- Open_frm_only: Only the data dictionary need be read for table information.
- Open_full_table: Unoptimized information lookup. Table information must be read from the data dictionary and by reading table files.

#### Start temporary, End temporary (JSON property: message)
&nbsp;&nbsp;This indicates temporary table use for the semijoin Duplicate Weedout strategy.

#### unique row not found (JSON property: message)
&nbsp;&nbsp;For a query such as SELECT ... FROM tbl_name, no rows satisfy<sup>v. 使满意，使满足；满</sup> the condition for a UNIQUE index or PRIMARY KEY on the table.

#### Using filesort (JSON property: using_filesort)
&nbsp;&nbsp;MySQL must do an extra <sup>adj. 额外的；另外收费的</sup> pass<sup>转变，翻译为处理</sup> to find out how to retrieve<sup>v.找回;检索;</sup> the rows in sorted order. The sort is done by going through all rows according to the join type and storing the sort key and pointer to the row for all rows that match the WHERE clause. The keys then are sorted and the rows are retrieved in sorted order. See Section 8.2.1.16, “ORDER BY Optimization”.

#### Using index (JSON property: using_index)
&nbsp;&nbsp;The column information is retrieved from the table using only information in the index tree without having to do an additional seek<sup>v. 寻找；寻求，谋求；请求</sup> to read the actual row. This strategy can be used when the query uses only columns that are part of a single index.
> 使用了覆盖索引，即不用回表查询行数据。

&nbsp;&nbsp;For InnoDB tables that have a user-defined clustered index, that index can be used even when Using index is absent<sup>adj. 缺勤的，缺席的；不存在的，缺乏的；</sup> from the Extra column. This is the case if type is index and key is PRIMARY.

&nbsp;&nbsp;Information about any covering indexes used is shown for EXPLAIN FORMAT=TRADITIONAL and EXPLAIN FORMAT=JSON. Beginning with MySQL 8.0.27, it is also shown for EXPLAIN FORMAT=TREE.

#### Using index condition (JSON property: using_index_condition)
&nbsp;&nbsp;Tables are read by accessing index tuples<sup>n. [计]元组（tuple 的复数）</sup> and testing them first to determine whether to read full table rows. In this way, index information is used to defer<sup>v. 延期，推迟；听从，遵从</sup> (“push down”) reading full table rows unless<sup>conj. 除非，除非在……情况下；若非，如果不</sup> it is necessary. See Section 8.2.1.6, “Index Condition Pushdown Optimization”.
> 通过访问索引元组并首先对其进行测试以确定是否读取完整的表行来读取表。通过这种方式，索引信息被用来推迟（“下推”）读取完整的表行，除非有必要。
>> 是否使用了ICP优化

#### Using index for group-by (JSON property: using_index_for_group_by)
&nbsp;&nbsp;Similar to the Using index table access method, Using index for group-by indicates that MySQL found an index that can be used to retrieve all columns of a GROUP BY or DISTINCT query without any extra disk access to the actual table. Additionally, the index is used in the most efficient way so that for each group, only a few index entries are read. For details, see Section 8.2.1.17, “GROUP BY Optimization”.

#### Using index for skip scan (JSON property: using_index_for_skip_scan)
&nbsp;&nbsp;Indicates that the Skip Scan access method is used. See Skip Scan Range Access Method.

#### Using join buffer (Block Nested Loop), Using join buffer (Batched Key Access), Using join buffer (hash join) (JSON property: using_join_buffer)
&nbsp;&nbsp;Tables from earlier joins are read in portions<sup>部分</sup> into the join buffer, and then their rows are used from the buffer to perform the join with the current table. (Block Nested Loop) indicates use of the Block Nested-Loop algorithm, (Batched Key Access) indicates use of the Batched Key Access algorithm, and (hash join) indicates use of a hash join. That is, the keys from the table on the preceding<sup>adj.先前的，前面的</sup> line of the EXPLAIN output are buffered, and the matching rows are fetched in batches from the table represented<sup>v.代表；表现；描写</sup> by the line in which Using join buffer appears.

&nbsp;&nbsp;In JSON-formatted output, the value of using_join_buffer is always one of Block Nested Loop, Batched Key Access, or hash join.

&nbsp;&nbsp;Hash joins are available beginning with MySQL 8.0.18; the Block Nested-Loop algorithm is not used in MySQL 8.0.20 or later MySQL releases. For more information about these optimizations, see Section 8.2.1.4, “Hash Join Optimization”, and Block Nested-Loop Join Algorithm.

&nbsp;&nbsp;See Batched Key Access Joins, for information about the Batched Key Access algorithm.

#### Using MRR (JSON property: message)
&nbsp;&nbsp;Tables are read using the Multi-Range Read optimization strategy. 

#### Using sort_union(...), Using union(...), Using intersect(...) (JSON property: message)
&nbsp;&nbsp;These indicate the particular algorithm showing how index scans are merged for the index_merge join type. See Section 8.2.1.3, “Index Merge Optimization”.

#### Using temporary (JSON property: using_temporary_table)
&nbsp;&nbsp;To resolve the query, MySQL needs to create a temporary table to hold the result. This typically happens if the query contains GROUP BY and ORDER BY clauses that list columns differently.

#### Using where (JSON property: attached_condition)
&nbsp;&nbsp;A WHERE clause is used to restrict<sup>v.限制，控制（大小、数量、范围）；限制（活动或行为），妨碍；约束，管束；（以法规）限制；封锁（消息）</sup> which rows to match against<sup>将…与…相比较 </sup> the next table or send to the client. Unless you specifically intend to fetch or examine<sup>v.检查，调查；考核，测验；</sup> all rows from the table, you may have something wrong in your query if the Extra value is not Using where and the table join type is ALL or index.
> 即应用WHERE条件,在MySQL Server层应用WHERE条件

&nbsp;&nbsp;Using where has no direct counterpart<sup>n.对应的人</sup> in JSON-formatted output; the attached_condition property contains any WHERE condition used.

#### Using where with pushed condition (JSON property: message)
&nbsp;&nbsp;This item applies to NDB tables only. It means that NDB Cluster is using the Condition Pushdown optimization to improve the efficiency of a direct comparison between a nonindexed column and a constant. In such cases, the condition is “pushed down” to the cluster's data nodes and is evaluated on all data nodes simultaneously. This eliminates the need to send nonmatching rows over the network, and can speed up such queries by a factor of 5 to 10 times over cases where Condition Pushdown could be but is not used. For more information, see Section 8.2.1.5, “Engine Condition Pushdown Optimization”.

#### Zero limit (JSON property: message)
&nbsp;&nbsp;The query had a LIMIT 0 clause and cannot select any rows.

---

### EXPLAIN Join Types
&nbsp;&nbsp;The type column of EXPLAIN output describes how tables are joined. In JSON-formatted output, these are found as values of the access_type property. The following list describes the join types, ordered from the best type to the worst:(性能从好到查排)

#### system
The table has only one row (= system table). This is a special case of the const join type.

#### const
&nbsp;&nbsp;The table has at most<sup>at most:至多</sup> one matching row, which is read at the start of the query. Because there is only one row, values from the column in this row can be regarded<sup>认为</sup> as constants by the rest of the optimizer. const tables are very fast because they are read only once.

&nbsp;&nbsp;const is used when you compare all parts of a PRIMARY KEY or UNIQUE index to constant values. In the following queries, tbl_name can be used as a const table:
```sql
   SELECT * FROM tbl_name WHERE primary_key=1;

   SELECT * FROM tbl_name
     WHERE primary_key_part1=1 AND primary_key_part2=2;
```

#### ref
&nbsp;&nbsp;All rows with matching index values are read from this table for each combination of rows from the previous tables. ref is used if the join uses only a leftmost prefix of the key or if the key is not a PRIMARY KEY or UNIQUE index (in other words, if the join cannot select a single row based on the key value). If the key that is used matches only a few rows, this is a good join type.
> 连接使用了索引，但数据多(大于一行)

&nbsp;&nbsp;ref can be used for indexed columns that are compared using the = or <=> operator. In the following examples, MySQL can use a ref join to process ref_table:

```sql
SELECT * FROM ref_table WHERE key_column=expr;

SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column=other_table.column;

SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column_part1=other_table.column
  AND ref_table.key_column_part2=1;
```

#### fulltext
&nbsp;&nbsp;The join is performed using a FULLTEXT index.

#### ref_or_null
&nbsp;&nbsp;This join type is like ref, but with the addition that MySQL does an extra search for rows that contain NULL values. This join type optimization is used most often in resolving subqueries. In the following examples, MySQL can use a ref_or_null join to process ref_table:

```sql
SELECT * FROM ref_table
  WHERE key_column=expr OR key_column IS NULL;
```

#### index_merge
&nbsp;&nbsp;This join type indicates that the Index Merge optimization is used. In this case, the key column in the output row contains a list of indexes used, and key_len contains a list of the longest key parts for the indexes used. For more information, see Section 8.2.1.3, “Index Merge Optimization”.

#### unique_subquery
&nbsp;&nbsp;This type replaces eq_ref for some IN subqueries of the following form:

```sql
value IN (SELECT primary_key FROM single_table WHERE some_expr)
```
&nbsp;&nbsp;unique_subquery is just an index lookup function that replaces the subquery completely for better efficiency.

#### index_subquery
&nbsp;&nbsp;This join type is similar to unique_subquery. It replaces IN subqueries, but it works for nonunique indexes in subqueries of the following form:
```sql
value IN (SELECT key_column FROM single_table WHERE some_expr)
```

#### range
&nbsp;&nbsp;Only rows that are in a given range are retrieved<sup>v.找回，收回；检索（储存于计算机的信息）；</sup>, using an index to select the rows. The key column in the output row indicates which index is used. The key_len contains the longest key part that was used. The ref column is NULL for this type.

&nbsp;&nbsp;range can be used when a key column is compared to a constant using any of the =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, LIKE, or IN() operators:
```sql
    SELECT * FROM tbl_name
     WHERE key_column = 10;
   
   SELECT * FROM tbl_name
     WHERE key_column BETWEEN 10 and 20;
   
   SELECT * FROM tbl_name
     WHERE key_column IN (10,20,30);
   
   SELECT * FROM tbl_name
     WHERE key_part1 = 10 AND key_part2 IN (10,20,30);
```

#### index
&nbsp;&nbsp;The index join type is the same as ALL, except that the index tree is scanned. This occurs two ways: (即扫描整个索引)
- If the index is a covering index for the queries and can be used to satisfy all data required from the table, only the index tree is scanned. In this case, the Extra column says Using index. An index-only scan usually is faster than ALL because the size of the index usually is smaller than the table data.
- A full table scan is performed using reads from the index to look up data rows in index order. Uses index does not appear in the Extra column.

&nbsp;&nbsp;MySQL can use this join type when the query uses only columns that are part of a single index.

#### ALL
&nbsp;&nbsp;A full table scan is done for each combination of rows from the previous tables. This is normally not good if the table is the first table not marked const, and usually very bad in all other cases. Normally, you can avoid ALL by adding indexes that enable row retrieval from the table based on constant values or column values from earlier tables.

---
### Merge Derived Table
&nbsp;&nbsp;Derived table实际上是一种特殊的subquery，它位于SQL语句中FROM子句里面，可以看做是一个单独的表。MySQL5.7之前的处理都是对Derived table进行Materialize，生成一个临时表保存Derived table的结果，然后利用临时表来协助完成其他父查询的操作，比如JOIN等操作。MySQL5.7中对Derived table做了一个新特性。该特性允许将符合条件的Derived table中的子表与父查询的表合并进行直接JOIN。
#### 实践如下
```sql
    # 环境
    mysql> select version();
    +-----------+
    | version() |
    +-----------+
    | 5.7.35    |
    +-----------+
    1 row in set (0.00 sec)

    ## 数据准备
    mysql> show create table trade \G
    *************************** 1. row ***************************
           Table: trade
    Create Table: CREATE TABLE `trade` (
      `trade_id` bigint(20) NOT NULL AUTO_INCREMENT,
      `total_price` bigint(20) NOT NULL,
      `buyer_id` varchar(20) NOT NULL,
      PRIMARY KEY (`trade_id`)
    ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=latin1
    1 row in set (0.00 sec)
    
    mysql> select * from trade;
    +----------+-------------+------------+
    | trade_id | total_price | buyer_id   |
    +----------+-------------+------------+
    |        1 |          20 | Wei.Wang.1 |
    |        2 |          30 | Wei.Wang.2 |
    +----------+-------------+------------+
    2 rows in set (0.00 sec)

    mysql> show create table order_ \G
    *************************** 1. row ***************************
           Table: order_
    Create Table: CREATE TABLE `order_` (
      `order_id` bigint(20) NOT NULL AUTO_INCREMENT,
      `trade_id` bigint(20) NOT NULL,
      `item_id` varchar(50) NOT NULL,
      `price` bigint(20) NOT NULL,
      PRIMARY KEY (`order_id`)
    ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=latin1
    1 row in set (0.00 sec)
    
    mysql> select * from order_;
    +----------+----------+-----------+-------+
    | order_id | trade_id | item_id   | price |
    +----------+----------+-----------+-------+
    |        1 |        1 | item_id_1 |    10 |
    |        2 |        1 | item_id_2 |    10 |
    |        3 |        2 | item_id_1 |    10 |
    |        4 |        2 | item_id_3 |    20 |
    +----------+----------+-----------+-------+
    4 rows in set (0.00 sec)

    ## 关闭 'derived_merge'
       set optimizer_switch='derived_merge=off';
    mysql> explain select * from (select * from trade where trade_id = 1) as trade inner join (select * from order_ where trade_id=1) as orderT on orderT.trade_id = trade.trade_id;
    +----+-------------+------------+------------+--------+---------------+-------------+---------+-------+------+----------+-------------+
    | id | select_type | table      | partitions | type   | possible_keys | key         | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+------------+------------+--------+---------------+-------------+---------+-------+------+----------+-------------+
    |  1 | PRIMARY     | <derived2> | NULL       | system | NULL          | NULL        | NULL    | NULL  |    1 |   100.00 | NULL        |
    |  1 | PRIMARY     | <derived3> | NULL       | ref    | <auto_key0>   | <auto_key0> | 8       | const |    1 |   100.00 | NULL        |
    |  3 | DERIVED     | order_     | NULL       | ALL    | NULL          | NULL        | NULL    | NULL  |    4 |    25.00 | Using where |
    |  2 | DERIVED     | trade      | NULL       | const  | PRIMARY       | PRIMARY     | 8       | const |    1 |   100.00 | NULL        |
    +----+-------------+------------+------------+--------+---------------+-------------+---------+-------+------+----------+-------------+
    4 rows in set, 1 warning (0.01 sec)
    
    mysql> 
    ## 打开 'derived_merge'
       set optimizer_switch='derived_merge=on';
   
    mysql> explain select * from (select * from trade where trade_id = 1) as trade inner join (select * from order_ where trade_id=1) as orderT on orderT.trade_id = trade.trade_id;
    +----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
    | id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
    |  1 | SIMPLE      | trade  | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL        |
    |  1 | SIMPLE      | order_ | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  |    4 |    25.00 | Using where |
    +----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
    2 rows in set, 1 warning (0.00 sec)
    
    mysql> 

    # 可以发现，当 ‘derived_merge’ 打开，3,2两个DERIVED查询被合并到了1这个主查询上,尽而简化了执行计划，同时也提高了执行效率。
    ## 只要Derived table里不包含如下条件就可以利用该特性进行优化：
           UNION clause
           GROUP BY
           DISTINCT
           Aggregation
           LIMIT or OFFSET
           Derived table里面包含用户变量的设置。
```

## 参考资料
1. [13.8.2 EXPLAIN Statement](https://dev.mysql.com/doc/refman/8.0/en/explain.html)
2. [8.8.2 EXPLAIN Output Format](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-extra-information)