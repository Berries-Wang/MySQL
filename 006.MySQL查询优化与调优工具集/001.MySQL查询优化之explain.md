# Explain
## EXPLAIN Statement
```sql
  {EXPLAIN | DESCRIBE | DESC}
    tbl_name [col_name | wild]

  {EXPLAIN | DESCRIBE | DESC}
      [explain_type]
      {explainable_stmt | FOR CONNECTION connection_id}
  
  {EXPLAIN | DESCRIBE | DESC} ANALYZE [FORMAT = TREE] select_statement
  
  explain_type: {
      FORMAT = format_name
  }
  
  format_name: {
      TRADITIONAL
    | JSON
    | TREE
  }
  
  explainable_stmt: {
      SELECT statement
    | TABLE statement
    | DELETE statement
    | INSERT statement
    | REPLACE statement
    | UPDATE statement
  }
```
---

## 功能
可以使用explain来获取关于**查询执行计划**的信息，即:explain命令是查看查询优化器如何决定执行查询的主要方法，这个功能存在局限性，并不总会说出真相，但是他的输出是可以获取的最好信息。
   + explain 仅仅能解释SELECT查询(高版本中也能支持其他的)，不能对存储过程，INSERT,UPDATE,DELETE以及其他的语句做解释
## 使用方式
要使用explain，则只需要在查询的select关键字之前添加EXPLAIN即可。但是，需要注意的是：
   1. MySQL会在查询上设置一个标记，当执行查询是，这个标记会使其**返回关于在查询计划中每一步的信息，而不是执行他**(不是真正执行)
   2. 他会返回一行或者多行信息，显示出执行计划中的每一部分和执行顺序。
   3. 在查询中，每个表在输出中只有一行。若：
        + 若查询的是两个表的联接，则输出中将有两行。
        + 别名表单算一个表，因此，若将一个表与自己联接，输出行中也会有两行。
        + 这里的表意义较广，可以是一个子查询，一个union结果等。
### 请注意
**认为增加EXPLAIN时MySQL不会执行查询，这是错误的**，如果查询在FROM子句中包括子查询，则MySQL实际上会执行子查询，将其结果放在一个临时表中，然后完成**外层查询优化**，他必须在可以完成外层查询优化之前处理掉所有类似的子查询，这对于EXPLAIN是必须要做的(可能会在高版本中去掉该限制)。
### EXPLAIN只是一个近似的结果，别无其他，有时候他是一个很好的近似，但在其他时候，可能与真相相差甚远。见如下限制：
  1. explain不会反馈触发器，存储过程或者UDF会如何影响查询
  2. 不支持存储过程，仅支持select操作
  3. 不会反馈MySQL在执行查询的时候所做的特定优化
  4. 不会反馈关于查询的执行计划的所有信息
  5. 不区分具有相同名字的事物。例如，他对内存排序和临时文件都使用filesort，并且对磁盘上和内存中的临时表都显示为Using Temporary
  6. 可能会误导。例如，对一个有着很小limit的查询显示为全索引扫描。

---

## EXPLAIN 输出
&nbsp;&nbsp;EXPLAIN的每个输出行提供关于一个表的信息。每行包含表“EXPLAIN Output Columns”中总结的值，并在表中进行了更详细的描述。列名显示在表的第一列中;第二列提供了当使用FORMAT=JSON时在输出中显示的等价属性名。
### EXPLAIN Output Columns
|Column|	JSON Name|	Meaning|
|---|---|---|
|id	         |select_id     |The SELECT identifier|
|select_type	|None          |The SELECT type|
|table	      |table_name    |The table for the output row|
|partitions    |partitions    |The matching partitions|
|type          |access_type	|The join type|
|possible_keys	|possible_keys |The possible indexes to choose|
|key           |key           |The index actually chosen|
|key_len       |key_length    |The length of the chosen key|
|ref	         |ref           |The columns compared to the index|
|rows          |rows	         |Estimate of rows to be examined|
|filtered      |filtered      |Percentage of rows filtered by table condition|
|Extra	      |None          |Additional information|

```txt
   # Attensions
     a. JSON properties which are NULL are not displayed in JSON-formatted EXPLAIN output.
```
### EXPLAIN OUTPUT 列说明
#### id (JSON name: select_id)
&nbsp;&nbsp;The SELECT identifier. This is the sequential number of the SELECT within the query. The value can be NULL if the row refers to the union result of other rows. In this case, the table column shows a value like <unionM,N> to indicate that the row refers to the union of the rows with id values of M and N.(SELECT标识符。这是查询中的SELECT序号。如果该行引用其他行的并集结果时该值可能为NULL。在这种情况下,这一列可能会展示类似于<unionM,N>这样一个值，以指示该行引用 id 值为 M 和 N 的行的并集)

#### select_type (JSON name: none)
&nbsp;&nbsp;The type of SELECT, which can be any of those shown in the following table. A JSON-formatted EXPLAIN exposes the SELECT type as a property of a query_block, unless it is SIMPLE or PRIMARY. The JSON names (where applicable) are also shown in the table.(SELECT的类型，可以是下表中所示的任何类型。json格式的EXPLAIN将SELECT类型作为query_block的属性公开，除非它是SIMPLE或PRIMARY。JSON名称(如适用)也显示在表中)
|select_type Value|	JSON Name|	Meaning|
|---|---|---|
|SIMPLE	             |None	                     |Simple SELECT (not using UNION or subqueries)|
|PRIMARY	             |None	                     |Outermost(最外层) SELECT|
|UNION	             |None	                     |Second or later SELECT statement in a UNION|
|DEPENDENT UNION      |dependent (true)            |Second or later SELECT statement in a UNION, dependent on outer query|
|UNION RESULT	       |union_result	               |Result of a UNION.|
|SUBQUERY	          |None	                     |First SELECT in subquery|
|DEPENDENT SUBQUERY   |dependent (true)            |First SELECT in subquery, dependent on outer query|
|DERIVED	             |None	                     |Derived(派生的) table <sub>Derived table实际上是一种特殊的subquery，它位于SQL语句中FROM子句里面，可以看做是一个单独的表。MySQL5.7之前的处理都是对Derived table进行Materialize，生成一个临时表保存Derived table的结果，然后利用临时表来协助完成其他父查询的操作，比如JOIN等操作。MySQL5.7中对Derived table做了一个新特性（MySQL5.7 Merge derived table特性:见附录'Merge Derived Table'）。该特性允许将符合条件的Derived table中的子表与父查询的表合并进行直接JOIN。</sub>|
|DEPENDENT DERIVED    |dependent (true)            |Derived table dependent on another table|
|MATERIALIZED	       |materialized_from_subquery	|Materialized(实体化) subquery (说明MySQL对于此查询会创建临时表)|
|UNCACHEABLE SUBQUERY |cacheable (false)	         |A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query(不能将结果缓存的子查询，必须重新计算外部查询的每一行)|
|UNCACHEABLE UNION	 |cacheable (false)	         |The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)|

#### table (JSON name: table_name)
&nbsp;&nbsp; The name of the table to which the row of output refers. This can also be one of the following values:(输出行所指向的表的名称。这也可以是以下值之一)
- <unionM,N>: The row refers to the union of the rows with id values of M and N.(行是指id值为M和N的行的并集。)
- <derivedN>: The row refers to the derived table result for the row with an id value of N. A derived table may result, for example, from a subquery in the FROM clause.(The row refers to the derived table result for the row with an id value of N. A derived table may result, for example, from a subquery in the FROM clause.)
- <subqueryN>: The row refers to the result of a materialized subquery for the row with an id value of N.(行引用id值为N的行的物化子查询的结果)

#### partitions (JSON name: partitions)
&nbsp;&nbsp;The partitions from which records would be matched by the query. The value is NULL for nonpartitioned tables. (查询将从其中匹配记录的分区。对于非分区表，该值为NULL。)

#### type (JSON name: access_type)
&nbsp;&nbsp;The join type. For descriptions of the different types, see EXPLAIN Join Types.(连接类型，见附录 'EXPLAIN Join Types')

#### possible_keys (JSON name: possible_keys)
&nbsp;&nbsp;The possible_keys column indicates the indexes from which MySQL can choose to find the rows in this table. Note that this column is totally independent of the order of the tables as displayed in the output from EXPLAIN. That means that some of the keys in possible_keys might not be usable in practice with the generated table order.（possible_keys列表示MySQL可以从中选择查找该表中的行的索引。注意，这一列完全独立于EXPLAIN输出中显示的表的顺序。这意味着'possible_keys'中的一些索引在实际中可能无法用于生成的表顺序）

#### key (JSON name: key)
&nbsp;&nbsp;The key column indicates the key (index) that MySQL actually decided to use. If MySQL decides to use one of the possible_keys indexes to look up rows, that index is listed as the key value.(key列表示MySQL实际决定使用的键(索引)。如果MySQL决定使用一个'possible_keys'索引来查找行，那么该索引将被列为键值。).

&nbsp;&nbsp;It is possible that key may name an index that is not present in the possible_keys value. This can happen if none of the possible_keys indexes are suitable for looking up rows, but all the columns selected by the query are columns of some other index. That is, the named index covers the selected columns, so although it is not used to determine which rows to retrieve, an index scan is more efficient than a data row scan.(可能索引的名称没有出现在possible_keys中。这种情况出现在possible_keys中的索引都不适合查找行，但是所有的列可以通过其他索引查询到，也就是说，索引覆盖所选的列，因此尽管不使用索引来确定要检索哪些行，但索引扫描比数据行扫描更有效)

&nbsp;&nbsp;For InnoDB, a secondary index might cover the selected columns even if the query also selects the primary key because InnoDB stores the primary key value with each secondary index. If key is NULL, MySQL found no index to use for executing the query more efficiently.(对于InnoDB，即使查询也选择了主键，二级索引也可能覆盖所选的列，因为InnoDB将主键值存储在每个二级索引中。如果key为NULL, MySQL找不到索引来更有效地执行查询。)

&nbsp;&nbsp;To force MySQL to use or ignore an index listed in the possible_keys column, use FORCE INDEX, USE INDEX, or IGNORE INDEX in your query.(强制使用或忽略索引)

#### key_len (JSON name: key_length)
&nbsp;&nbsp;The key_len column indicates the length of the key that MySQL decided to use. The value of key_len enables you to determine how many parts of a multiple-part key MySQL actually uses. If the key column says NULL, the key_len column also says NULL.(key_len 字段表明MySQL决定使用key的多长部分，key_len的值让你确定了多字段索引的多少部分被MySQL实际使用。如果key列为NULL，那么key_len列也是NULL)

&nbsp;&nbsp;Due to the key storage format, the key length is one greater for a column that can be NULL than for a NOT NULL colum。(由于索引存储格式的原因，允许为NULL列的长度比NOT NULL列的长度大1)

#### ref (JSON name: ref)
&nbsp;&nbsp;The ref column shows which columns or constants are compared to the index named in the key column to select rows from the table.(ref列显示哪些列或常量与key列指定的索引进行比较，以便从表中选择行)

&nbsp;&nbsp;If the value is func, the value used is the result of some function. To see which function, use SHOW WARNINGS following EXPLAIN to see the extended EXPLAIN output. The function might actually be an operator such as an arithmetic<sup>算数</sup> operator.

#### rows (JSON name: rows)
&nbsp;&nbsp;The rows column indicates the number of rows MySQL believes it must examine<sup>v.检查，调查；考核，测验；</sup> to execute the query.

&nbsp;&nbsp;For InnoDB tables, this number is an estimate<sup>v.估计；判断，评价n.估计，估价；估价单；看法，判断</sup>, and may not always be exact<sup>adj.确切的，精确的；严谨的，</sup>.

#### filtered (JSON name: filtered)
&nbsp;&nbsp;The filtered column indicates an estimated percentage of table rows that are filtered by the table condition. The maximum value is 100, which means no filtering of rows occurred. Values decreasing<sup>v.减少；缩减（decrease 的现在分词）</sup> from 100 indicate increasing amounts of filtering. rows shows the estimated number of rows examined<sup>v.检查；调查（examine 的过去式和过去分词）</sup> and rows × filtered shows the number of rows that are joined with the following table. For example, if rows is 1000 and filtered is 50.00 (50%), the number of rows to be joined with the following table is 1000 × 50% = 500. (那么有多少行被过滤掉了呢? 1-${filtered}) (filtered列表明被表条件过滤掉行数的估计百分比，最大值是100,这意味着没有对行进行过滤。从100开始递减表示过滤量在增加。rows行显示检查的估计行数，rows x filtered显示与下表连接的行数。)

#### Extra (JSON name: none)
&nbsp;&nbsp;This column contains additional information about how MySQL resolves the query. For descriptions of the different values,see ‘附录: EXPLAIN Extra Information.’

&nbsp;&nbsp;There is no single JSON property corresponding to the Extra column; however, values that can occur in this column are exposed as JSON properties, or as the text of the message property.(没有单独的JSON属性对应于Extra列;但是，可以在此列中出现的值将作为JSON属性或消息属性的文本公开。)


---
## 附录
### EXPLAIN Extra Information
&nbsp;&nbsp;The Extra column of EXPLAIN output contains additional information about how MySQL resolves the query. The following list explains the values that can appear in this column. Each item also indicates for JSON-formatted output which property displays the Extra value. For some of these, there is a specific property. The others display as the text of the message property.

### EXPLAIN Join Types
---
### Merge Derived Table
&nbsp;&nbsp;Derived table实际上是一种特殊的subquery，它位于SQL语句中FROM子句里面，可以看做是一个单独的表。MySQL5.7之前的处理都是对Derived table进行Materialize，生成一个临时表保存Derived table的结果，然后利用临时表来协助完成其他父查询的操作，比如JOIN等操作。MySQL5.7中对Derived table做了一个新特性。该特性允许将符合条件的Derived table中的子表与父查询的表合并进行直接JOIN。
#### 实践如下
```sql
    # 环境
    mysql> select version();
    +-----------+
    | version() |
    +-----------+
    | 5.7.35    |
    +-----------+
    1 row in set (0.00 sec)

    ## 数据准备
    mysql> show create table trade \G
    *************************** 1. row ***************************
           Table: trade
    Create Table: CREATE TABLE `trade` (
      `trade_id` bigint(20) NOT NULL AUTO_INCREMENT,
      `total_price` bigint(20) NOT NULL,
      `buyer_id` varchar(20) NOT NULL,
      PRIMARY KEY (`trade_id`)
    ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=latin1
    1 row in set (0.00 sec)
    
    mysql> select * from trade;
    +----------+-------------+------------+
    | trade_id | total_price | buyer_id   |
    +----------+-------------+------------+
    |        1 |          20 | Wei.Wang.1 |
    |        2 |          30 | Wei.Wang.2 |
    +----------+-------------+------------+
    2 rows in set (0.00 sec)

    mysql> show create table order_ \G
    *************************** 1. row ***************************
           Table: order_
    Create Table: CREATE TABLE `order_` (
      `order_id` bigint(20) NOT NULL AUTO_INCREMENT,
      `trade_id` bigint(20) NOT NULL,
      `item_id` varchar(50) NOT NULL,
      `price` bigint(20) NOT NULL,
      PRIMARY KEY (`order_id`)
    ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=latin1
    1 row in set (0.00 sec)
    
    mysql> select * from order_;
    +----------+----------+-----------+-------+
    | order_id | trade_id | item_id   | price |
    +----------+----------+-----------+-------+
    |        1 |        1 | item_id_1 |    10 |
    |        2 |        1 | item_id_2 |    10 |
    |        3 |        2 | item_id_1 |    10 |
    |        4 |        2 | item_id_3 |    20 |
    +----------+----------+-----------+-------+
    4 rows in set (0.00 sec)

    ## 关闭 'derived_merge'
       set optimizer_switch='derived_merge=off';
    mysql> explain select * from (select * from trade where trade_id = 1) as trade inner join (select * from order_ where trade_id=1) as orderT on orderT.trade_id = trade.trade_id;
    +----+-------------+------------+------------+--------+---------------+-------------+---------+-------+------+----------+-------------+
    | id | select_type | table      | partitions | type   | possible_keys | key         | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+------------+------------+--------+---------------+-------------+---------+-------+------+----------+-------------+
    |  1 | PRIMARY     | <derived2> | NULL       | system | NULL          | NULL        | NULL    | NULL  |    1 |   100.00 | NULL        |
    |  1 | PRIMARY     | <derived3> | NULL       | ref    | <auto_key0>   | <auto_key0> | 8       | const |    1 |   100.00 | NULL        |
    |  3 | DERIVED     | order_     | NULL       | ALL    | NULL          | NULL        | NULL    | NULL  |    4 |    25.00 | Using where |
    |  2 | DERIVED     | trade      | NULL       | const  | PRIMARY       | PRIMARY     | 8       | const |    1 |   100.00 | NULL        |
    +----+-------------+------------+------------+--------+---------------+-------------+---------+-------+------+----------+-------------+
    4 rows in set, 1 warning (0.01 sec)
    
    mysql> 
    ## 打开 'derived_merge'
       set optimizer_switch='derived_merge=on';
   
    mysql> explain select * from (select * from trade where trade_id = 1) as trade inner join (select * from order_ where trade_id=1) as orderT on orderT.trade_id = trade.trade_id;
    +----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
    | id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |
    +----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
    |  1 | SIMPLE      | trade  | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL        |
    |  1 | SIMPLE      | order_ | NULL       | ALL   | NULL          | NULL    | NULL    | NULL  |    4 |    25.00 | Using where |
    +----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------------+
    2 rows in set, 1 warning (0.00 sec)
    
    mysql> 

    # 可以发现，当 ‘derived_merge’ 打开，3,2两个DERIVED查询被合并到了1这个主查询上,尽而简化了执行计划，同时也提高了执行效率。
    ## 只要Derived table里不包含如下条件就可以利用该特性进行优化：
           UNION clause
           GROUP BY
           DISTINCT
           Aggregation
           LIMIT or OFFSET
           Derived table里面包含用户变量的设置。
```

## 参考资料
1. [13.8.2 EXPLAIN Statement](https://dev.mysql.com/doc/refman/8.0/en/explain.html)
2. http://mysql.taobao.org/monthly/2017/03/05/