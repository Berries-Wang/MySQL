# ORDER BY Optimization
&nbsp;&nbsp;This section describes when MySQL can use an index to satisfy an ORDER BY clause, the filesort operation used when an index cannot be used, and execution plan information available from the optimizer about ORDER BY.(本节描述MySQL在什么情况下可以使用索引来满足ORDER BY子句，在不能使用索引时使用的filesort操作，以及关于ORDER BY的优化器提供的执行计划信息。)

### Use of Indexes to Satisfy ORDER BY
&nbsp;&nbsp;In some cases, MySQL may use an index to satisfy an ORDER BY clause and avoid the extra sorting involved in performing a filesort operation.(在某些情况下，MySQL可能使用索引来满足ORDER BY子句，从而避免执行filesort操作时涉及的额外排序。)

&nbsp;&nbsp;The index may also be used even if the ORDER BY does not match the index exactly, as long as all unused portions of the index and all extra ORDER BY columns are constants in the WHERE clause. If the index does not contain all columns accessed by the query, the index is used only if index access is cheaper than other access methods.(即使ORDER BY与索引不完全匹配，也可以使用索引，只要索引中所有未使用的部分和所有额外的ORDER BY列在WHERE子句中是常量。如果索引不包含查询访问的所有列<sub>即不是覆盖索引</sub>，则仅当索引访问比其他访问方法更便宜时才使用该索引。)

&nbsp;&nbsp;Assuming that there is an index on (key_part1, key_part2), the following queries may use the index to resolve the ORDER BY part. Whether the optimizer actually does so depends on whether reading the index is more efficient than a table scan if columns not in the index must also be read.(假设在(key_part1, key_part2)上有一个索引，下面的查询可以使用该索引来按部分解析顺序。优化器是否真的这样做，取决于在必须读取不在索引中的列的情况下，读取索引是否比表扫描更高效。)
+ In this query, the index on (key_part1, key_part2) enables the optimizer to avoid sorting:
  ```sql
      SELECT * FROM t1 ORDER BY key_part1, key_part2;
  ```
  - However, the query uses SELECT *, which may select more columns than key_part1 and key_part2. In that case, scanning an entire index and looking up table rows to find columns not in the index may be more expensive than scanning the table and sorting the results. If so, the optimizer probably does not use the index. If SELECT * selects only the index columns, the index is used and sorting avoided.(但是，查询使用SELECT *，可能比key_part1和key_part2选择更多的列。在这种情况下，扫描整个索引并查找表行以查找不在索引中的列<sub>遍历索引和回表查询其他列</sub>可能比扫描表并对结果进行排序更耗时。如果是这样，优化器可能不会使用索引。如果SELECT *只选择索引列，则使用索引并避免排序。)
  - If t1 is an InnoDB table, the table primary key is implicitly part of the index, and the index can be used to resolve the ORDER BY for this query:(如果t1是一张InnoDB表，表的主键是索引的隐式部分，并且可以使用索引来解析此查询的顺序:)
    ```sql
       SELECT pk, key_part1, key_part2 FROM t1 ORDER BY key_part1, key_part2;
    ```
+ In this query, key_part1 is constant, so all rows accessed through the index are in key_part2 order, and an index on (key_part1, key_part2) avoids sorting if the WHERE clause is selective enough to make an index range scan cheaper than a table scan:(在这个查询中，key_part1是常量，因此通过索引访问的所有行都是按key_part2顺序访问的，并且(key_part1, key_part2)上的索引会在WHERE子句的选择性足以使索引范围扫描比表扫描更便宜的情况下进行排序:)
  ```sql
      SELECT * FROM t1
         WHERE key_part1 = constant
         ORDER BY key_part2;
  ```
+ In the next two queries, whether the index is used is similar to the same queries without DESC shown previously:(在接下来的两个查询中，是否使用索引与前面没有DESC的查询类似:)
  ```sql
    SELECT * FROM t1
      ORDER BY key_part1 DESC, key_part2 DESC;

    SELECT * FROM t1
      WHERE key_part1 = constant
        ORDER BY key_part2 DESC;
  ```
