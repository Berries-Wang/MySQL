# 016.MySQL_The Optimizer Trace
## Introduction
&nbsp;&nbsp;This optimizer trace is aimed at producing output, which is readable by humans and by programs, to aid understanding of decisions and actions taken by the MySQL Optimizer. (优化器跟踪的目的是生成人类和程序都可读的输出，以帮助理解MySQL优化器所做的决策和操作。)

## Output format
&nbsp;&nbsp;The chosen output format is JSON (JavaScript Object Notation) (输出是JSON格式的)

## How a user enables/views the trace
```sql
  SET SESSION OPTIMIZER_TRACE="enabled=on"; # enable tracing
  <statement to trace>; # like SELECT, EXPLAIN SELECT, UPDATE, DELETE...
  SELECT * FROM information_schema.OPTIMIZER_TRACE;
  [ repeat last two steps at will ]
  SET SESSION OPTIMIZER_TRACE="enabled=off"; # disable tracing
```

&nbsp;&nbsp;SELECT and EXPLAIN SELECT produce the same trace. But there are exceptions regarding subqueries because the two commands treat subqueries differently, for example in (SELECT 和 EXPLAIN SELECT 产生相同的轨迹。但子查询也有例外，因为这两个命令对子查询的处理不同，例如在)
```sql
     SELECT ... WHERE x IN (subq1) AND y IN (subq2)
```

&nbsp;&nbsp;SELECT terminates after executing the first subquery if the related IN predicate is false, so we won't see JOIN::optimize() tracing for subq2; whereas EXPLAIN SELECT analyzes all subqueries (see loop at the end of select_describe()).(如果相关的IN谓词为false, SELECT会在执行第一个子查询后终止，因此我们不会看到subq2的JOIN::optimize()跟踪;而EXPLAIN SELECT分析所有子查询(参见select_describe()末尾的循环)。)

## How a user traces only certain <sup>用户如何只跟踪确定的</sup>
&nbsp;&nbsp;When tracing is in force, each SQL statement generates a trace; more exactly, so does any of SELECT, EXPLAIN SELECT, INSERT or REPLACE ( with VALUES or SELECT), UPDATE/DELETE and their multi-table variants, SET (unless it manipulates @@optimizer_trace), DO, DECLARE/CASE/IF/RETURN (stored routines language elements), CALL. If a command above is prepared and executed in separate steps, preparation and execution are separately traced. By default each new trace overwrites the previous trace. Thus, if a statement contains sub-statements (example: invokes stored procedures, stored functions, triggers), the top statement and sub-statements each generate traces, but at the execution's end only the last sub-statement's trace is visible. If the user wants to see the trace of another sub-statement, she/he can enable/disable tracing around the desired sub-statement, but this requires editing the routine's code, which may not be possible. Another solution is to use(当tracing生效时，每条SQL语句都会产生一个Trace,更准确地说，任何SELECT、EXPLAIN SELECT、INSERT 或REPLACE(with VALUES 或 SELECT)、UPDATE、DELETE和他们的多表变体、SET(除非他操作@@optimizer_trace)、DO, DECLARE/CASE/IF/RETURN （存储历程语言元素）、CALL。如果上面的命令是单独准备和执行的，那么准备和执行是分开跟踪的。默认情况下，每个新的跟踪都会覆盖以前的跟踪。因此，如果一个语句包含子语句(例如： 调用存储过程、存储函数、触发器)，则顶部语句和子语句都会生成跟踪，但在执行结束时，只有最后一个子语句的跟踪是可见的。如果用户想查看另一个子语句的跟踪，她可以enable/disable所需子语句的跟踪，但这需要编辑例程的代码，而这是不可能的。另一种解决方案是使用:)
```sql
   SET optimizer_trace_offset=<OFFSET>, optimizer_trace_limit=<LIMIT>
```
&nbsp;&nbsp;where OFFSET is a signed integer, and LIMIT is a positive integer. The effect of this SET is the following:(其中 OFFSET 是有符号整数，LIMIT 是正整数。 这个SET的效果如下：)
- all remembered traces are cleared
- a later SELECT on OPTIMIZER_TRACE returns the first LIMIT traces of the OFFSET oldest remembered traces (if OFFSET >= 0), or the first LIMIT traces of the -OFFSET newest remembered traces (if OFFSET < 0).（）

&nbsp;&nbsp;For example, a combination of OFFSET=-1 and LIMIT=1 will make the last trace be shown (as is default), OFFSET=-2 and LIMIT=1 will make the next-to-last be shown, OFFSET=-5 and LIMIT=5 will make the last five traces be shown. Such negative OFFSET can be useful when one knows that the interesting sub-statements are the few last ones of a stored routine, like this:（例如，OFFSET=-1 和 LIMIT=1 的组合将显示最后一条迹线（默认情况下），OFFSET=-2 和 LIMIT=1 将显示倒数第二条迹线，OFFSET=-5 LIMIT=5 将显示最后 5 条轨迹。 当人们知道有趣的子语句是存储例程的最后几个子语句时，这种负 OFFSET 会很有用，如下所示：）
```sql
  SET optimizer_trace_offset=-5, optimizer_trace_limit=5;
  CALL stored_routine(); # more than 5 sub-statements in this routine
  SELECT * FROM information_schema.OPTIMIZER_TRACE; # see only last 5 traces
```





## 参考资料
- [Tracing the Optimizer](https://dev.mysql.com/doc/dev/mysql-server/latest/PAGE_OPT_TRACE.html)
- [016.MySQL_The Optimizer Trace](./REF_Docs/016.MySQL_%20The%20Optimizer%20Trace.pdf)