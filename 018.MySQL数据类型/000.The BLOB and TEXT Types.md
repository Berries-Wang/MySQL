# The BLOB and TEXT Types
&nbsp;&nbsp;A BLOB is a binary large object that can hold a variable amount of data. The four BLOB types are TINYBLOB, BLOB, MEDIUMBLOB, and LONGBLOB. These differ only in the maximum length of the values they can hold. The four TEXT types are TINYTEXT, TEXT, MEDIUMTEXT, and LONGTEXT. These correspond to the four BLOB types and have the same maximum lengths and storage requirements. See Section 11.7, “[Data Type Storage Requirements](./001.Data%20Type%20Storage%20Requirements.md)”. (BLOB是二进制大对象，可以保存可变数量的数据，四种BLOB类型分别为:TINYBLOB, BLOB, MEDIUMBLOB, and LONGBLOB.这些唯一的区别就是他们能存储的值的最大长度。四种TEXT类型： TINYTEXT, TEXT, MEDIUMTEXT, and LONGTEXT。这对应着四种BLOB类型并且有着相同的最大长度和存储要求.见[Data Type Storage Requirements](./001.Data%20Type%20Storage%20Requirements.md)

&nbsp;&nbsp;BLOB values are treated as binary strings (byte strings). They have the binary character set and collation, and comparison and sorting are based on the numeric values of the bytes in column values. TEXT values are treated as nonbinary strings (character strings). They have a character set other than binary, and values are sorted and compared based on the collation of the character set.(BLOB值被作为二进制字符串(字节字符串)处理,他们有着二进制字符集和排序，比较和排序基于列值中字节的数量。TEXT值被视为非二进制字符串(字符串)，有着非二进制字符集，并且根据字符集的排序规则对值进行排序和比较)

&nbsp;&nbsp;If strict<sup>adj.要求严格的，严厉的</sup> SQL mode is not enabled and you assign a value to a BLOB or TEXT column that exceeds the column's maximum length, the value is truncated<sup>v.缩短(truncate过去分词)</sup> to fit and a warning is generated. For truncation<sup>n.截断；切掉顶端</sup> of nonspace characters, you can cause<sup>n.原因;v.导致，引起：使某事发生或产生某种结果</sup> an error to occur (rather than a warning) and suppress<sup>v.镇压,压制</sup> insertion of the value by using strict SQL mode. See Section 5.1.11, “[Server SQL Modes](https://dev.mysql.com/doc/refman/8.2/en/sql-mode.html)”.

&nbsp;&nbsp;[**TEXT超过就会被截断，不论SQL模式**]Truncation of excess<sup>adj.过多的，超额的；额外的，附加的.n.超过，过量；越轨行为，暴行；无节制，无度；</sup> trailing<sup>adj.（植物）蔓生的；后面的；拖尾的；牵引的；被拖动的；蔓延的</sup> spaces from values to be inserted into TEXT columns always generates a warning, regardless<sup>adv.不顾，不加理会；不管怎样，无论如何</sup> of the SQL mode.

&nbsp;&nbsp;[**插入时不会填充，查询时不会删除**]For TEXT and BLOB columns, there is no padding on insert and no bytes are stripped<sup>v.脱衣；表演脱衣舞；剥光；拆卸；剥夺（strip 的过去式和过去分词）</sup> on select.

&nbsp;&nbsp;If a TEXT column is indexed, index entry comparisons are space-padded at the end. This means that, if the index requires unique values, duplicate-key errors occur for values that differ only in the number of trailing spaces. For example, if a table contains 'a', an attempt to store 'a ' causes a duplicate-key error. This is not true for BLOB columns.(如果对TEXT列进行了索引，则索引条目比较时将在末尾填充空格。这意味着如果这个索引需要唯一值，  只在尾部有着不同数量的空格的值会导致重复键的错误出现)
```sql
    # 5.7.34-debug
    Create Table: CREATE TABLE `data_type_text` (
       `id` bigint(20) NOT NULL AUTO_INCREMENT,
       `context` text,
       PRIMARY KEY (`id`),
       UNIQUE KEY `uk_con` (`context`(10))
    ) ENGINE=InnoDB DEFAULT CHARSET=latin1;

    mysql> insert into data_type_text(context) values('a'),('   a');
    Query OK, 2 rows affected (0.01 sec)
    Records: 2  Duplicates: 0  Warnings: 0
    
    mysql> select * from data_type_text;
    +----+---------+
    | id | context |
    +----+---------+
    |  4 | a       |
    |  5 |    a    |
    +----+---------+
    2 rows in set (0.01 sec)
   
    mysql> insert into data_type_text(context) values('a  ');
    ERROR 1062 (23000): Duplicate entry 'a  ' for key 'uk_con'
    mysql> 
```







