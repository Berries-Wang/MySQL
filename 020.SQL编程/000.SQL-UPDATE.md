# UPDATE 语句
> 关键字: 数据行更新 、 多表联合更新

&nbsp;&nbsp;UPDATE is a DML statement that modifies rows in a table.(UPDATE是一条DML语句，用于修改表中的行)

&nbsp;&nbsp;An UPDATE statement can start with a WITH clause to define common table expressions accessible within the UPDATE.(UPDATE语句可以以with子句开始，以定义在UPDATE中可访问的公共表表达式。)

## 语法
1. Single-table syntax: (单表语法)
```sql
    UPDATE [LOW_PRIORITY] [IGNORE] table_reference
        SET assignment_list
        [WHERE where_condition]
        [ORDER BY ...]
        [LIMIT row_count]
    
    value:
        {expr | DEFAULT}
    
    assignment:
        col_name = value
    
    assignment_list:
        assignment [, assignment] ...
    
    # 使用示例
      常用，不列举
```

2. Multiple-table syntax:(多表语法)
```sql
    UPDATE [LOW_PRIORITY] [IGNORE] table_references
        SET assignment_list
        [WHERE where_condition]

    > table_references (比table_reference多一个s，即多个表) 支持任何形式的连接,如下文所描述的
    
    # 使用示例
      UPDATE items INNER JOIN month ON items.a = month.a AND items.b = month.b SET items.d = month.d WHERE items.e = ${theValue};
```

&nbsp;&nbsp;[**单表更新**]For the single-table syntax, the UPDATE statement updates columns of existing rows in the named table with new values. The SET clause indicates which columns to modify and the values they should be given. Each value can be given as an expression, or the keyword DEFAULT to set a column explicitly to its default value. The WHERE clause, if given, specifies the conditions that identify which rows to update. With no WHERE clause, all rows are updated. If the ORDER BY clause is specified, the rows are updated in the order that is specified. The LIMIT clause places a limit on the number of rows that can be updated.(对于单表语法，UPDATE语句用新值更新已命名表中现有行的列。SET子句指出要修改哪些列，以及应该给它们指定哪些值。每个值可以通过表达式给出，也可以通过DEFAULT关键字显式地设置列的默认值。如果给出了WHERE子句，它指定了标识要更新哪些行。如果没有WHERE子句，则更新所有行。如果指定了ORDER BY子句，则按照指定的顺序更新行。LIMIT子句限制了可以更新的行数。)

&nbsp;&nbsp;[**多表更新**]For the multiple-table syntax, UPDATE updates rows in each table named in table_references that satisfy<sup>v.使满意;使满足;</sup> the conditions. Each matching row is updated once, even if it matches the conditions multiple times. For multiple-table syntax, ORDER BY and LIMIT cannot be used.(对于多表语法，UPDATE会更新每个table_references中满足条件的行。每个匹配的行只更新一次，即使它多次匹配条件也是如此。对于多表语法，ORDER BY和LIMIT不能使用。)

&nbsp;&nbsp;For partitioned tables, both the single-table and multiple-table forms of this statement support the use of a PARTITION clause as part of a table reference. This option takes a list of one or more partitions or subpartitions (or both). Only the partitions (or subpartitions) listed are checked for matches, and a row that is not in any of these partitions or subpartitions is not updated, whether it satisfies the where_condition or not.(对于已分区的表，该语句的单表和多表形式都支持使用分区子句作为表引用的一部分。该选项接受一个或多个分区或子分区(或两者)的列表。只检查列出的分区(或子分区)是否匹配，不属于这些分区或子分区的行不更新，无论它是否满足where_condition。)

&nbsp;&nbsp;The UPDATE statement supports the following modifiers:(UPDATE 支持如下的修饰符)
- With the LOW_PRIORITY modifier, execution of the UPDATE is delayed until no other clients are reading from the table. This affects only storage engines that use only table-level locking (such as MyISAM, MEMORY, and MERGE).(使用LOW_PRIORITY修饰符，更新的执行被延迟，直到没有其他客户端从表中读取数据。这只影响只使用表级锁的存储引擎(如MyISAM、MEMORY和MERGE)。)
- With the IGNORE modifier, the update statement does not abort even if errors occur during the update. Rows for which duplicate-key conflicts occur on a unique key value are not updated. Rows updated to values that would cause data conversion errors are updated to the closest valid values instead. (使用IGNORE修饰符，即使更新过程中发生错误，update语句也不会中止。在唯一键值上发生重复键冲突的行不会被更新。将更新为可能导致数据转换错误的行更新为最近的有效值。)

&nbsp;&nbsp;UPDATE IGNORE statements, including those having an ORDER BY clause, are flagged as unsafe for statement-based replication. (This is because the order in which the rows are updated determines which rows are ignored.) Such statements produce a warning in the error log when using statement-based mode and are written to the binary log using the row-based format when using MIXED mode. (Bug #11758262, Bug #50439) See Section 17.2.1.3, “[Determination of Safe and Unsafe Statements in Binary Logging](https://dev.mysql.com/doc/refman/8.2/en/replication-rbr-safe-unsafe.html)”, for more information.(UPDATE IGNORE语句(包括具有ORDER BY子句的语句)被标记为不安全，用于基于语句的复制。(这是因为更新行的顺序决定了哪些行会被忽略。)当使用基于语句的模式时，这些语句会在错误日志中产生一个警告，当使用混合模式时，这些语句会使用基于行的格式写入二进制日志。(Bug #11758262, Bug #50439)更多信息请参见17.2.1.3节，“确定二进制日志中的安全与不安全语句”。)

&nbsp;&nbsp;If you access a column from the table to be updated in an expression, UPDATE uses the current value of the column. For example, the following statement sets col1 to one more than its current value:(如果你在一个表达式中从表中访问一个要更新的列，UPDATE将使用该列的当前值。例如，下面的语句将col1设置为 当前值+1:)
```sql
   UPDATE t1 SET col1 = col1 + 1;
```

&nbsp;&nbsp;The second assignment in the following statement sets col2 to the current (updated) col1 value, not the original col1 value. The result is that col1 and col2 have the same value. This behavior differs from standard SQL.(第二个赋值语句将col2设置为当前(更新后)的col1值，而不是原来的col1值。结果是col1和col2的值相同。这种行为不同于标准SQL。)
```sql
    UPDATE t1 SET col1 = col1 + 1, col2 = col1;
```

&nbsp;&nbsp;Single-table UPDATE assignments are generally evaluated from left to right. For multiple-table updates, there is no guarantee that assignments are carried out in any particular order.(单表更新赋值一般从左到右计算。对于多表更新，不能保证赋值操作是按照特定的顺序进行的。)

&nbsp;&nbsp;If you set a column to the value it currently has, MySQL notices this and does not update it.(如果你将一列的值设置为它当前的值，MySQL会注意到这一点，并且不会对其进行更新。)

&nbsp;&nbsp;If you update a column that has been declared NOT NULL by setting to NULL, an error occurs if strict SQL mode is enabled; otherwise, the column is set to the implicit default value for the column data type and the warning count is incremented. The implicit default value is 0 for numeric types, the empty string ('') for string types, and the “zero” value for date and time types. See Section 11.6, “[Data Type Default Values](https://dev.mysql.com/doc/refman/8.2/en/data-type-defaults.html)”.(如果你将一个声明为NOT NULL的列设置为NULL，如果启用了严格的SQL模式，则会报错;否则，将列设置为列数据类型的隐式默认值，并增加警告计数。对于数值类型，隐式默认值为0;对于字符串类型，隐式默认值为空字符串(");对于日期和时间类型，隐式默认值为" 0 ")

&nbsp;&nbsp;UPDATE returns the number of rows that were actually changed.  The mysql_info() C API function returns the number of rows that were matched and updated and the number of warnings that occurred during the UPDATE.(UPDATE返回实际更改的行数。mysql_info() C API函数返回匹配和更新的行数以及更新期间发生的警告数。)

&nbsp;&nbsp;You can use LIMIT row_count to restrict the scope of the UPDATE. A LIMIT clause is a rows-matched restriction. The statement stops as soon as it has found row_count rows that satisfy the WHERE clause, whether or not they actually were changed.(可以使用LIMIT row_count来限制更新的范围。LIMIT子句是行匹配的限制。只要找到满足WHERE子句的row_count行，不管这些行是否被修改，语句就会立即停止。)

&nbsp;&nbsp;If an UPDATE statement includes an ORDER BY clause, the rows are updated in the order specified by the clause. This can be useful in certain situations that might otherwise result in an error. Suppose that a table t contains a column id that has a unique index. The following statement could fail with a duplicate-key error, depending on the order in which rows are updated:(如果UPDATE语句包含ORDER BY子句，则按照子句指定的顺序更新行。这在某些可能导致错误的情况下很有用。假设表t包含一个列id，它有一个唯一的索引。下面的语句可能会因为重复键错误而失败，这取决于更新行的顺序:)
```sql
    UPDATE t SET id = id + 1;
```

&nbsp;&nbsp;For example, if the table contains 1 and 2 in the id column and 1 is updated to 2 before 2 is updated to 3, an error occurs. To avoid this problem, add an ORDER BY clause to cause the rows with larger id values to be updated before those with smaller values:(例如，如果表中的id列包含1和2，并且1在2更新为3之前更新为2，则会报错。要避免这个问题，可以添加ORDER BY子句，让id值大的行在id值小的行之前更新)
```sql
   UPDATE t SET id = id + 1 ORDER BY id DESC;
```

&nbsp;&nbsp;You can also perform UPDATE operations covering multiple tables. However, you cannot use ORDER BY or LIMIT with a multiple-table UPDATE. The table_references clause lists the tables involved in the join. Its syntax is described in Section 13.2.13.2, “[JOIN Clause](https://dev.mysql.com/doc/refman/8.2/en/join.html)”. Here is an example:(您还可以执行覆盖多个表的更新操作。但是，对于多表更新，不能使用ORDER BY或LIMIT。table_references子句列出了联结所涉及的表。其语法在[JOIN Clause](https://dev.mysql.com/doc/refman/8.2/en/join.html)描述。下面是一个例子)
```sql
   # 多表更新语法
   UPDATE items,month SET items.price=month.price
   WHERE items.id=month.id;
   
   例如:
   UPDATE items INNER JOIN month ON items.a = month.a AND items.b = month.b SET items.d = month.d WHERE items.e = ${theValue};
```

&nbsp;&nbsp;[**多表连接可使用JOIN子句**]The preceding example shows an inner join that uses the comma operator, but multiple-table UPDATE statements can use any type of join permitted in SELECT statements, such as LEFT JOIN.(前面的例子展示了一个使用逗号操作符的内连接，但多表UPDATE语句可以使用SELECT语句允许的任何连接类型，例如LEFT连接。)

&nbsp;&nbsp;If you use a multiple-table UPDATE statement involving InnoDB tables for which there are foreign key constraints, the MySQL optimizer might process tables in an order that differs from that of their parent/child relationship. In this case, the statement fails and rolls back. Instead, update a single table and rely on the ON UPDATE capabilities that InnoDB provides to cause the other tables to be modified accordingly. See Section 13.1.20.5, “[FOREIGN KEY Constraints](https://dev.mysql.com/doc/refman/8.2/en/create-table-foreign-keys.html)”.（如果你使用了一个多表更新语句，涉及到有外键约束的InnoDB表，MySQL优化器可能会以不同于它们父子关系的顺序处理表。在这种情况下，语句失败并回滚。相反，更新一张表，并依赖于InnoDB提供的on update功能，从而导致其他表也相应地被修改）

&nbsp;&nbsp;You cannot update a table and select directly from the same table in a subquery. You can work around this by using a multi-table update in which one of the tables is derived from the table that you actually wish to update, and referring to the derived table using an alias. Suppose you wish to update a table named items which is defined using the statement shown here:(您不能在子查询中更新表并直接从同一张表中进行选择。您可以通过使用多表更新来解决这个问题，其中一个表是从您实际希望更新的表派生出来的，并使用别名引用派生表。假设你想更新一个名为items的表，该表是用下面的语句定义的:)
```sql
    CREATE TABLE items (
        id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
        wholesale DECIMAL(6,2) NOT NULL DEFAULT 0.00,
        retail DECIMAL(6,2) NOT NULL DEFAULT 0.00,
        quantity BIGINT NOT NULL DEFAULT 0
    );
```

&nbsp;&nbsp;To reduce the retail price of any items for which the markup is 30% or greater and of which you have fewer than one hundred in stock, you might try to use an UPDATE statement such as the one following, which uses a subquery in the WHERE clause. As shown here, this statement does not work:(要降低加价大于或等于30%且库存少于100的商品的零售价格，可以尝试使用如下所示的UPDATE语句，该语句在WHERE子句中使用子查询。如下所示，这条语句不起作用:)
```sql
     mysql> UPDATE items
          > SET retail = retail * 0.9
          > WHERE id IN
          >     (SELECT id FROM items
          >         WHERE retail / wholesale >= 1.3 AND quantity > 100);
     ERROR 1093 (HY000): You can't specify target table 'items' for update in FROM clause
```

&nbsp;&nbsp;Instead, you can employ a multi-table update in which the subquery is moved into the list of tables to be updated, using an alias to reference it in the outermost WHERE clause, like this:(相反，可以采用多表更新，将子查询移动到待更新的表列表中，在最外层的WHERE子句中使用别名来引用它，如下所示:)
```sql
    UPDATE items,
           (SELECT id FROM items
            WHERE id IN
                (SELECT id FROM items
                 WHERE retail / wholesale >= 1.3 AND quantity < 100))
            AS discounted
    SET items.retail = items.retail * 0.9
    WHERE items.id = discounted.id;
```

&nbsp;&nbsp;Because the optimizer tries by default to merge the derived table discounted into the outermost query block, this works only if you force materialization of the derived table. You can do this by setting the derived_merge flag of the optimizer_switch system variable to off before running the update, or by using the NO_MERGE optimizer hint, as shown here:(因为优化器默认情况下会尝试将派生表合并到最外层的查询块中，所以只有强制物化派生表时才会起作用。为此，可以在运行更新之前将optimizer_switch系统变量的derived_merge标志设置为off，或者使用NO_MERGE优化器提示，如下所示)
```sql
    UPDATE /*+ NO_MERGE(discounted) */ items,
           (SELECT id FROM items
            WHERE retail / wholesale >= 1.3 AND quantity < 100)
            AS discounted
        SET items.retail = items.retail * 0.9
        WHERE items.id = discounted.id;
```

&nbsp;&nbsp;The advantage of using the optimizer hint in such a case is that it applies only within the query block where it is used, so that it is not necessary to change the value of optimizer_switch again after executing the UPDATE.(在这种情况下使用优化器提示的好处是，它只适用于使用它的查询块，因此无需在执行更新后再次更改optimizer_switch的值)

&nbsp;&nbsp;Another possibility is to rewrite the subquery so that it does not use IN or EXISTS, like this:(另一种可能是重写子查询，使其不使用IN或不存在，如下所示:)
```sql
            UPDATE items,
               (SELECT id, retail / wholesale AS markup, quantity FROM items)
               AS discounted
            SET items.retail = items.retail * 0.9
            WHERE discounted.markup >= 1.3
            AND discounted.quantity < 100
            AND items.id = discounted.id;
```

&nbsp;&nbsp;In this case, the subquery is materialized by default rather than merged, so it is not necessary to disable merging of the derived table.(在这种情况下，子查询默认是物化的而不是合并的，因此没有必要禁用派生表的合并。)


---

## 参考资料
1. [MySQL - UPDATE](https://dev.mysql.com/doc/refman/8.2/en/update.html)










