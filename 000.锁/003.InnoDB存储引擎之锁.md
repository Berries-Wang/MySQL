# InnoDB存储引擎之锁


## 锁的类型
### 行级锁
&nbsp;&nbsp;InnoDB存储引擎实现了如下两种标准的**行级锁**:
1. 共享锁(S Lock),允许事务读一行数据
2. 排他锁(X Lock),允许事务删除或更新一行数据。

&nbsp;&nbsp;锁的兼容性如下：<sub>S、X都是行级锁，兼容性是指对同一记录锁的兼容性情况</sub>
1. 兼容： 如果一个事务T1已经获得了行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁，因为读取并没有改变行r的数据，称这种情况为锁兼容
2. 不兼容： 若有其他的事务T3想获得行r的排他锁，则必然等待事务T1、T2释放行r上的共享锁，这种情况称之为锁不兼容
    |锁类型|X|S|
    |--|--|--|
    |X|不兼容|不兼容|
    |S|不兼容|兼容|
### 表级锁
&nbsp;&nbsp;InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在，例如：**诸如此类的语句“LOCK TABLES ... WRITE”在指定的表上获取排他锁（一个X锁）**。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的加锁方式，即意向锁（Intention Lock）.意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。

&nbsp;&nbsp;若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。如下图:
  <img src="./pics/innodb-lock-001.png"/>

&nbsp;&nbsp;如果需要对页上的记录r行上X锁，那么分别需要对数据库A、表、页上意向锁IX，最后对记录r上X锁。若其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。
+ 例如：在对记录r加X锁之前，已经有事务对表1进行了S表锁，那么表1上已存在S锁<sup>这里的S锁是表级锁</sup>。之后事务需要对记录r在表1上加上IX，由于不兼容，所以该事务需要等待表锁操作的完成。

&nbsp;&nbsp;InnoDB存储引擎支持意向锁设计比较简练，其意向锁即为表级别的锁。设计的主要目的是为了在一个事务中揭示下一行被请求的锁类型<sup>原文: Intention locks are table-level locks that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table</sup>。其支持两种意向锁：
1. 意向共享锁("IS Lock")，事务想要获得一张表中某几行数据的共享锁
2. 意向排他锁("IX Lock"), 事务想要获得一张表中某几行的排他锁

&nbsp;&nbsp;由于InnoDB存储引擎支持的似乎行级别的锁，因此意向锁其实不会阻塞除全表扫描以外的任何请求。兼容性如下：
|锁类型|X|IX|S|IS|
|---|---|---|---|---|
|X	| 冲突 | 冲突 | 冲突 | 冲突 |
|IX	| 冲突 | 兼容 | 冲突 | 兼容 |
|S	| 冲突 | 冲突 |	兼容 | 兼容 |
|IS | 冲突 | 兼容 | 兼容 | 兼容 |

&nbsp;&nbsp;意向锁协议如下：
+ Before a transaction can acquire a shared lock on a row in a table, it must first acquire an IS lock or stronger on the table.
  - 在事务可以获取表中行的共享锁之前，它必须首先获取IS表上的锁或更强的锁。
+ Before a transaction can acquire an exclusive lock on a row in a table, it must first acquire an IX lock on the table.
  - 在事务获得表中行的排他锁之前，它必须首先获得IX 表的锁。


## [一致性非锁定读](https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html)
&nbsp;&nbsp;一致性非锁定读是指InnoDB存储引擎通过多版本并发控制(MVCC)的方式来读取当前执行时间数据库中行的数据（一致性读取意味着InnoDB使用多版本控制向查询提供数据库在某个时间点的快照。查询查看在该时间点之前提交的事务所做的更改，而不查看以后或未提交的事务所做的更改）。即若读取的行正在执行DELETE或UPDAE操作，这时读取操作不会因此去等待行上锁的释放。相反，InnoDB存储引擎会读取行的一个快照数据。
### 一致性非锁定读与事务隔离级别的关系
&nbsp;&nbsp;在事务隔离级别READ COMMITTED 和 REPEATABLE READ下，InnoDB存储引擎使用非锁定的一致性读。然而，对于快照数据的定义却不同：
- 在READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据
- 在REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的数据版本。

## 一致性锁定读 
&nbsp;&nbsp;在MySQL默认的配置下，即事务的隔离级别为REPEATABLE READ，InnoDB存储引擎的SELECT操作使用一致性非锁定读。但是在某些情况下，用户需要显式地对数据库读操作进行加锁以保证数据逻辑的一致性。而这要求数据库支持加锁语句，即使是对于SELECT的只读操作。InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读(Locking Read)操作:
1. SELECT .... FOR UPDATE;
2. SELECT .... LOCK IN SHARED MODE;

&nbsp;&nbsp;SELECT .... FOR UPDATE对读取的行记录加一个X锁，其他事务不能对已锁定的行加上任何锁。SELECT .... LOCK IN SHARED MODE 对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，但是如果加X锁，则会被阻塞。

&nbsp;&nbsp;对于一致性非锁定读，即使读取的行已经执行了SELECT .... FOR UPDATE;，也是可以进行读取的。此外，SELECT .... FOR UPDATE; SELECT .... LOCK IN SHARED MODE;必须在一个事务中，当事务提交了，锁也就释放了。因此在上述两句SELECT锁定语句时，务必加上BEGIN，START TRANSACTION或者AUTOCOMMIT=0;


-----------

## 参考资料
1. 官方文档:[https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.htm](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.htm)
2. 《MySQL技术内幕InnoDB存储引擎第2版》
